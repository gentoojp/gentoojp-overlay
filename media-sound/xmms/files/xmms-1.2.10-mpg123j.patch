diff -upNr xmms-1.2.10/Input/mpg123/common.c xmms-1.2.10-mpg123j/Input/mpg123/common.c
--- xmms-1.2.10/Input/mpg123/common.c	2004-01-12 01:36:20.000000000 +0900
+++ xmms-1.2.10-mpg123j/Input/mpg123/common.c	2004-08-11 00:11:58.000000000 +0900
@@ -8,6 +8,16 @@
 
 #include "config.h"
 
+#ifdef HAVE_ICONV
+#include <iconv.h>
+#endif
+
+#include <errno.h>
+
+#ifdef HAVE_CODESET
+#include <langinfo.h>
+#endif
+
 #include "mpg123.h"
 #include "id3.h"
 #include "id3_header.h"
@@ -15,6 +25,13 @@
 /* max = 1728 */
 #define MAXFRAMESIZE 1792
 
+/* Japanese charset list for mpg123_strdup_lconv() */
+#define MAXCHARSET 6
+char *mpg123_lconv_from[MAXCHARSET] =
+{
+	"ISO-2022-JP", "SJIS", "EUCJP", "UTF8", "UTF16", "UTF16BE"
+};
+
 const int tabsel_123[2][3][16] = {
 {{0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448,},
  {0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384,},
@@ -509,3 +526,95 @@ double mpg123_relative_pos(void)
 		return 0;
 	return ((double) stream_tell()) / mpg123_info->filesize;
 }
+
+gchar *mpg123_strdup_lconv(char *string, char *outto, size_t allow_trunc)
+{
+#if !defined(HAVE_ICONV) || !defined(HAVE_CODESET)
+	return g_strdup(string);
+#else
+	size_t length, bufsize, outleft, inleft, ret;
+	iconv_t cd;
+	char *out, *outptr, *inptr;
+	char *from, *to, *froml;
+	int i;
+
+	if (!string)
+		return NULL;
+	length = strlen(string);
+
+	if (outto) {
+		froml = nl_langinfo(CODESET);
+		to    = outto;
+	} else {
+		froml = NULL;
+		to    = nl_langinfo(CODESET);
+	}
+	if ((outto && !froml) || (!outto && !to)) {
+		g_warning("mpg123_strdup_lconv(): Cannot get current character set.");
+		return g_strdup(string);
+	}
+
+	/* Iconv() requires extra work area to outbuf.
+	   Round outbuf_size up to 3 multiple of 4 */
+	bufsize = (length + 11) & ~3;
+	out = g_malloc(bufsize);
+	if (!out) {
+		g_warning("mpg123_strdup_lconv(): Cannot allocate %d bytes buffer.",
+			bufsize);
+		return NULL;
+	}
+
+	/* One shot for froml, or loop for mpg123_lconv_from[] */
+	for (i=0, from = froml ? froml : mpg123_lconv_from[0];
+		from && i < MAXCHARSET;
+		from = froml ? NULL : mpg123_lconv_from[++i])
+	{
+		inptr = string;
+		inleft = length;
+		outptr = out;
+		outleft = bufsize - 1;
+
+		cd = iconv_open(to, from);
+		if (cd == (iconv_t)-1) {
+			g_warning("mpg123_strdup_lconv(): iconv_open %s %s -> %s",
+				strerror(errno), from, to);
+			continue;
+		}
+
+		ret = iconv(cd, (ICONV_CONST char **) &inptr, &inleft, &outptr, &outleft);
+		if (ret == (size_t)-1) {
+			switch (errno) {
+			case E2BIG:
+				g_warning("mpg123_strdup_lconv(): iconv err %d; %s -> %s \"%s\"",
+					errno, from, to, string);
+				iconv_close(cd);
+				continue;
+			case EINVAL:
+			case EILSEQ:
+				if (inleft > allow_trunc) {
+					iconv_close(cd);
+					continue;
+				}
+				/* Truncate trailing incomplete or invalid character(s) */
+				g_message("xmms mpg123: Truncate %d byte.",
+					inleft);
+				break;
+			default:
+				g_warning("mpg123_strdup_lconv(): iconv err %d; %s -> %s \"%s\"",
+					errno, from, to, string);
+				iconv_close(cd);
+				continue;
+			}
+		}
+		/* Conversion suceeded */
+		*outptr = '\0';
+		iconv_close(cd);
+		return out;
+	}
+	/* All Conversion failed */
+	g_warning("mpg123_strdup_lconv(): Failed to convert to %s. \"%s\"",
+		outto ? outto : "locale", string);
+	g_free(out);
+	return g_strdup(string);
+#endif
+}
diff -upNr xmms-1.2.10/Input/mpg123/fileinfo.c xmms-1.2.10-mpg123j/Input/mpg123/fileinfo.c
--- xmms-1.2.10/Input/mpg123/fileinfo.c	2004-01-12 03:20:30.000000000 +0900
+++ xmms-1.2.10-mpg123j/Input/mpg123/fileinfo.c	2004-08-11 00:11:58.000000000 +0900
@@ -26,6 +26,10 @@
 #include <libxmms/xentry.h>
 #include "mpg123.h"
 
+#ifdef HAVE_CODESET
+#include <langinfo.h>
+#endif
+
 static GtkWidget *window = NULL;
 static GtkWidget *filename_entry, *id3_frame;
 static GtkWidget *title_entry, *artist_entry, *album_entry, *year_entry;
@@ -53,17 +57,29 @@ G_GNUC_PRINTF(2, 3);
 static void set_entry_tag(GtkEntry * entry, char * tag, int length)
 {
 	int stripped_len;
-	char *text;
+	char *text, *tmp;
 
 	stripped_len = mpg123_strip_spaces(tag, length);
-	text = g_strdup_printf("%-*.*s", stripped_len, stripped_len, tag);
-	gtk_entry_set_text(entry, text);
+	text = g_strndup(tag, stripped_len);
+	tmp = mpg123_strdup_lconv(text, NULL, 0);
+	gtk_entry_set_text(entry, tmp);
+	g_free(tmp);
 	g_free(text);
 }
 
 static void get_entry_tag(GtkEntry * entry, char * tag, int length)
 {
-	strncpy(tag, gtk_entry_get_text(entry), length);
+	char *text, *tmp;
+
+	text = gtk_entry_get_text(entry);
+	tmp  = g_strndup(text, length);
+	if (strlen(text) - strlen(tmp) > 0)
+	        g_message("xmms mpg123: Truncate to \"%s\"", tmp);
+	text = mpg123_strdup_lconv(tmp, "SJIS", 1);
+
+	strncpy(tag, text, length);
+	g_free(text);
+	g_free(tmp);
 }
 
 static int genre_find_index(GList *genre_list, int id)
diff -upNr xmms-1.2.10/Input/mpg123/id3_frame_content.c xmms-1.2.10-mpg123j/Input/mpg123/id3_frame_content.c
--- xmms-1.2.10/Input/mpg123/id3_frame_content.c	2003-05-20 06:22:06.000000000 +0900
+++ xmms-1.2.10-mpg123j/Input/mpg123/id3_frame_content.c	2004-08-11 00:11:58.000000000 +0900
@@ -51,12 +51,18 @@ char *id3_get_content(struct id3_frame *
     /* Check if frame is compressed */
     if (id3_decompress_frame(frame) == -1)
 	    return NULL;
-
-    if (*(guint8 *) frame->fr_data == ID3_ENCODING_ISO_8859_1)
-	text_beg = text = g_strdup((char *) frame->fr_data + 1);
-    else
-	text_beg = text = 
-	    id3_utf16_to_ascii((char *) frame->fr_data + 1);
+	
+	switch( *(guint8 *) frame->fr_data ) {
+		case ID3_ENCODING_ISO_8859_1:
+		case ID3_ENCODING_UTF8:
+			text_beg = text = g_strdup((char *) frame->fr_data + 1);
+			break;
+		case ID3_ENCODING_UTF16:
+		case ID3_ENCODING_UTF16BE:
+		default:
+		text_beg = text = 
+			id3_utf16_to_ascii((char *) frame->fr_data + 1);
+	}
 
     /*
      * If content is just plain text, return it.
diff -upNr xmms-1.2.10/Input/mpg123/id3_frame_text.c xmms-1.2.10-mpg123j/Input/mpg123/id3_frame_text.c
--- xmms-1.2.10/Input/mpg123/id3_frame_text.c	2003-05-20 06:22:06.000000000 +0900
+++ xmms-1.2.10-mpg123j/Input/mpg123/id3_frame_text.c	2004-08-11 00:11:58.000000000 +0900
@@ -127,28 +127,36 @@ int id3_set_encoding(struct id3_frame *f
 char *id3_get_text(struct id3_frame *frame)
 {
     /* Type check */
-    if ( frame->fr_desc->fd_idstr[0] != 'T' )
+    if ( frame->fr_desc->fd_idstr[0] != 'T' &&
+         frame->fr_desc->fd_id != ID3_COMM )
 	return NULL;
 
     /* Check if frame is compressed */
     if (id3_decompress_frame(frame) == -1)
 	    return NULL;
 
-    if ( frame->fr_desc->fd_id == ID3_TXXX ) {
+    if ( frame->fr_desc->fd_id == ID3_TXXX ||
+         frame->fr_desc->fd_id == ID3_COMM )
+    {
 	/*
 	 * This is a user defined text frame.  Skip the description.
 	 */
 	switch ( *(guint8 *) frame->fr_data ) {
 	case ID3_ENCODING_ISO_8859_1:
+	case ID3_ENCODING_UTF8:
 	{
 	    char *text = (char *) frame->fr_data + 1;
+	    guint len = frame->fr_size - 1;
 
-	    while ( *text != 0 )
+	    while ( *text != 0 ) {
 		text++;
+		len--;
+	    }
 
-	    return g_strdup(++text);
+	    return g_strndup(++text,--len);
 	}
 	case ID3_ENCODING_UTF16:
+	case ID3_ENCODING_UTF16BE:
 	{
 	    char *text16 = (char *) frame->fr_data + 1;
 
@@ -161,11 +169,15 @@ char *id3_get_text(struct id3_frame *fra
 	    return NULL;
 	}
     }
-
-    if (*(guint8 *) frame->fr_data == ID3_ENCODING_ISO_8859_1)
-	return g_strdup((char *) frame->fr_data + 1);
-    else
-	return id3_utf16_to_ascii(((char *) frame->fr_data + 1));
+	switch (*(guint8 *) frame->fr_data) {
+		case ID3_ENCODING_ISO_8859_1:
+		case ID3_ENCODING_UTF8:
+			return g_strdup((char *) frame->fr_data + 1);
+		case ID3_ENCODING_UTF16:
+		case ID3_ENCODING_UTF16BE:
+		default:
+		return id3_utf16_to_ascii(((char *) frame->fr_data + 1));
+	}
 }
 
 
diff -upNr xmms-1.2.10/Input/mpg123/mpg123.c xmms-1.2.10-mpg123j/Input/mpg123/mpg123.c
--- xmms-1.2.10/Input/mpg123/mpg123.c	2004-02-20 08:00:04.000000000 +0900
+++ xmms-1.2.10-mpg123j/Input/mpg123/mpg123.c	2004-08-11 00:11:58.000000000 +0900
@@ -556,6 +556,33 @@ gchar *mpg123_format_song_title(struct i
 
 	if (tag)
 	{
+		gchar *tmp;
+		
+		tmp = mpg123_strdup_lconv(tag->artist, NULL, 0);
+		strncpy(tag->artist, tmp, sizeof(tag->artist)-1);
+		tag->artist[sizeof(tag->artist)-1] = '\0';
+		g_free(tmp);
+                
+		tmp = mpg123_strdup_lconv(tag->album, NULL, 0);
+		strncpy(tag->album, tmp, sizeof(tag->album)-1);
+		tag->album[sizeof(tag->album)-1] = '\0';
+		g_free(tmp);
+                
+		tmp = mpg123_strdup_lconv(tag->title, NULL, 0);
+		strncpy(tag->title, tmp, sizeof(tag->title)-1);
+		tag->title[sizeof(tag->title)-1] = '\0';
+		g_free(tmp);
+                
+		tmp = mpg123_strdup_lconv(tag->genre, NULL, 0);
+		strncpy(tag->genre, tmp, sizeof(tag->genre)-1);
+		tag->genre[sizeof(tag->genre)-1] = '\0';
+		g_free(tmp);
+                
+		tmp = mpg123_strdup_lconv(tag->comment, NULL, 0);
+		strncpy(tag->comment, tmp, sizeof(tag->comment)-1);
+		tag->comment[sizeof(tag->comment)-1] = '\0';
+		g_free(tmp);
+                
 		input->performer = mpg123_getstr(tag->artist);
 		input->album_name = mpg123_getstr(tag->album);
 		input->track_name = mpg123_getstr(tag->title);
diff -upNr xmms-1.2.10/Input/mpg123/mpg123.h xmms-1.2.10-mpg123j/Input/mpg123/mpg123.h
--- xmms-1.2.10/Input/mpg123/mpg123.h	2003-09-05 05:59:05.000000000 +0900
+++ xmms-1.2.10-mpg123j/Input/mpg123/mpg123.h	2004-08-11 00:11:58.000000000 +0900
@@ -299,6 +299,7 @@ guint mpg123_strip_spaces(char *src, siz
 void mpg123_get_id3v2(struct id3_tag * id3d, struct id3tag_t *tag);
 gchar *mpg123_format_song_title(struct id3tag_t *tag, gchar *filename);
 double mpg123_relative_pos(void);
+gchar *mpg123_strdup_lconv(char *string, char *to, size_t allow_trunc);
 
 
 
