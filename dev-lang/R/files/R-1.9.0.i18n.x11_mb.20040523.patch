diff -ruN R-1.9.0.orig/etc/Makefile.in R-1.9.0.i18n.x11_mb/etc/Makefile.in
--- R-1.9.0.orig/etc/Makefile.in	2003-01-05 21:31:18.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/etc/Makefile.in	2004-04-22 21:15:30.000000000 +0900
@@ -18,6 +18,8 @@
 distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
 DISTFILES = Makefile.in $(SOURCES)
 
+RX11XRMFILES = R_X11 R_X11.*
+
 EXPORTFILES = @USE_EXPORTFILES_TRUE@ R.exp Rlapack.exp
 
 CLEANFILES = $(EXPORTFILES)
@@ -42,7 +44,7 @@
 
 install: installdirs
 	@echo "installing $(subdir) ..."
-	@for f in $(OBJECTS) $(EXPORTFILES); do \
+	@for f in $(OBJECTS) $(EXPORTFILES) $(RX11XRMFILES); do \
 	  $(INSTALL_DATA) $${f} $(rhome)/etc; \
 	done
 installdirs:
diff -ruN R-1.9.0.orig/etc/R_X11 R-1.9.0.i18n.x11_mb/etc/R_X11
--- R-1.9.0.orig/etc/R_X11	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/etc/R_X11	2003-08-20 15:24:14.000000000 +0900
@@ -0,0 +1,5 @@
+*fontSet1: -*-helvetica-medium-r-*-*-%d-*-*-*-*-*-*-*
+*fontSet2: -*-helvetica-bold-r-*-*-%d-*-*-*-*-*-*-*
+*fontSet3: -*-helvetica-medium-o-*-*-%d-*-*-*-*-*-*-*
+*fontSet4: -*-helvetica-bold-o-*-*-%d-*-*-*-*-*-*-*
+*fontSet5: -adobe-symbol-*-*-*-*-%d-*-*-*-*-*-*-*
diff -ruN R-1.9.0.orig/etc/R_X11.ja_JP.eucJP R-1.9.0.i18n.x11_mb/etc/R_X11.ja_JP.eucJP
--- R-1.9.0.orig/etc/R_X11.ja_JP.eucJP	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/etc/R_X11.ja_JP.eucJP	2003-08-20 08:57:04.000000000 +0900
@@ -0,0 +1,13 @@
+*fontSet1: -*-kochi gothic-medium-r-*-*-%d-*-*-*-*-*-iso8859-1, \
+	   -*-kochi gothic-medium-r-*-*-%d-*-*-*-*-*-jisx0201.1976-0, \
+	   -*-kochi gothic-medium-r-*-*-%d-*-*-*-*-*-jisx0208.1983-0
+*fontSet2: -*-kochi gothic-bold-r-*-*-%d-*-*-*-*-*-iso8859-1, \
+	   -*-kochi gothic-bold-r-*-*-%d-*-*-*-*-*-jisx0201.1976-0, \
+	   -*-kochi gothic-bold-r-*-*-%d-*-*-*-*-*-jisx0208.1983-0
+*fontSet3: -*-kochi gothic-medium-i-*-*-%d-*-*-*-*-*-iso8859-1, \
+	   -*-kochi gothic-medium-i-*-*-%d-*-*-*-*-*-jisx0201.1976-0, \
+	   -*-kochi gothic-medium-i-*-*-%d-*-*-*-*-*-jisx0208.1983-0
+*fontSet4: -*-kochi gothic-bold-i-*-*-%d-*-*-*-*-*-iso8859-1, \
+	   -*-kochi gothic-bold-i-*-*-%d-*-*-*-*-*-jisx0201.1976-0, \
+	   -*-kochi gothic-bold-i-*-*-%d-*-*-*-*-*-jisx0208.1983-0
+*fontSet5: -adobe-symbol-*-*-*-*-%d-*-*-*-*-*-*-*
diff -ruN R-1.9.0.orig/etc/R_X11.ko_KR.eucKR R-1.9.0.i18n.x11_mb/etc/R_X11.ko_KR.eucKR
--- R-1.9.0.orig/etc/R_X11.ko_KR.eucKR	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/etc/R_X11.ko_KR.eucKR	2003-08-20 08:57:26.000000000 +0900
@@ -0,0 +1,5 @@
+*fontSet1: -*-gothic-medium-r-*-*-%d-*-*-*-*-*-ksc5601.1987-0
+*fontSet2: -*-gothic-medium-r-*-*-%d-*-*-*-*-*-ksc5601.1987-0
+*fontSet3: -*-mincho-medium-r-*-*-%d-*-*-*-*-*-ksc5601.1987-0
+*fontSet4: -*-mincho-medium-r-*-*-%d-*-*-*-*-*-ksc5601.1987-0
+*fontSet5: -adobe-symbol-*-*-*-*-%d-*-*-*-*-*-*-*
diff -ruN R-1.9.0.orig/etc/R_X11.ru_RU.KOI8-R R-1.9.0.i18n.x11_mb/etc/R_X11.ru_RU.KOI8-R
--- R-1.9.0.orig/etc/R_X11.ru_RU.KOI8-R	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/etc/R_X11.ru_RU.KOI8-R	2003-08-20 08:57:48.000000000 +0900
@@ -0,0 +1,5 @@
+*fontSet1: -*-helvetica-medium-r-normal-*-%d-*-*-*-*-*-koi8-r
+*fontSet2: -*-helvetica-bold-r-normal-*-%d-*-*-*-*-*-koi8-r
+*fontSet3: -*-helvetica-medium-o-normal-*-%d-*-*-*-*-*-koi8-r
+*fontSet4: -*-helvetica-bold-o-normal-*-%d-*-*-*-*-*-koi8-r
+*fontSet5: -adobe-symbol-*-*-*-*-%d-*-*-*-*-*-*-*
diff -ruN R-1.9.0.orig/src/modules/X11/Makefile.in R-1.9.0.i18n.x11_mb/src/modules/X11/Makefile.in
--- R-1.9.0.orig/src/modules/X11/Makefile.in	2003-09-21 17:13:10.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/Makefile.in	2004-04-22 21:16:48.000000000 +0900
@@ -15,10 +15,10 @@
 ALL_CFLAGS_LO = $(R_XTRA_CFLAGS) $(CPICFLAGS) $(SHLIB_CFLAGS) $(CFLAGS)
 ALL_X_LIBS = $(X_PRE_LIBS) $(X_LIBS) $(X_EXTRA_LIBS)
 
-SOURCES = dataentry.c devX11.c rotated.c rbitmap.c 
+SOURCES = dataentry.c devX11.c rotated.c rbitmap.c devX11_mb.c rotated_mb.c xrm.c dataentry_mb.c
 DEPENDS = $(SOURCES:.c=.d)
 OBJECTS = $(SOURCES:.c=.lo)
-HEADERS = devX11.h rotated.h
+HEADERS = devX11.h rotated.h devX11_mb.h rotated_mb.h xrm.h
 
 distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
 DISTFILES = \
diff -ruN R-1.9.0.orig/src/modules/X11/dataentry.c R-1.9.0.i18n.x11_mb/src/modules/X11/dataentry.c
--- R-1.9.0.orig/src/modules/X11/dataentry.c	2004-03-27 22:46:11.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/dataentry.c	2004-04-22 21:18:00.000000000 +0900
@@ -1,3 +1,4 @@
+#ifndef I18N_MB
 /*
  *  R : A Computer Langage for Statistical Data Analysis
  *  Copyright (C) 1995, 1996  Robert Gentleman and Ross Ihaka
@@ -1732,3 +1733,4 @@
     closerect();
     highlightrect();
 }
+#endif /* I18N_MB */
diff -ruN R-1.9.0.orig/src/modules/X11/dataentry_mb.c R-1.9.0.i18n.x11_mb/src/modules/X11/dataentry_mb.c
--- R-1.9.0.orig/src/modules/X11/dataentry_mb.c	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/dataentry_mb.c	2004-04-24 22:49:03.000000000 +0900
@@ -0,0 +1,1801 @@
+#ifdef I18N_MB
+/*
+ *  R : A Computer Langage for Statistical Data Analysis
+ *  Copyright (C) 1995, 1996  Robert Gentleman and Ross Ihaka
+ *  Copyright (C) 1998--2004  Robert Gentleman, Ross Ihaka and the
+ *                            R Development Core Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+
+/* don't use X11 function prototypes (which tend to ...): */
+#define NeedFunctionPrototypes 0
+/* XFree 4.4.0 forgets to define this if NeedFunctionPrototypes=0 */
+#ifndef _Xconst
+#define _Xconst const
+#endif
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/keysym.h>
+#include <X11/cursorfont.h>
+
+#include "Defn.h"
+#include "Print.h"
+
+#include <locale.h>
+#include "xrm.h"
+#include "xmb_xutf8.h"
+
+/* <FIXME> this is wrong  as KeySym is defined nowadays */
+#define KeySym int
+/* </FIXME> */
+#define DEEvent XEvent
+
+typedef enum { UP, DOWN, LEFT, RIGHT } DE_DIRECTION;
+
+typedef enum {UNKNOWNN, NUMERIC, CHARACTER} CellType;
+
+/* EXPORTS : */
+SEXP RX11_dataentry(SEXP call, SEXP op, SEXP args, SEXP rho);
+
+/* Local Function Definitions */
+ 
+static void advancerect(DE_DIRECTION);
+static int  CheckControl(DEEvent*);
+static int  CheckShift(DEEvent*);
+static int  checkquit(int);
+static void clearrect(void);
+static void clearwindow(void);
+static void closerect(void);
+static void closewin(void);
+static void copycell(void);
+static void doControl(DEEvent*);
+static int  doMouseDown(DEEvent*);
+static void eventloop(void);
+static void doSpreadKey(int, DEEvent*);
+static void downlightrect(void);
+static void drawwindow(void);
+static void drawcol(int);
+static void drawrow(int);
+static void find_coords(int, int, int*, int*);
+static int  findcell(void);
+static char GetCharP(DEEvent*);
+static KeySym GetKey(DEEvent*);
+static void handlechar(char*);
+static void highlightrect(void);
+static Rboolean initwin(void);
+static void jumppage(DE_DIRECTION);
+static void jumpwin(int, int);
+static void pastecell(int, int);
+static void popdownmenu(void);
+static void popupmenu(int, int, int, int);
+static void printlabs(void);
+static void printrect(int, int);
+static void printstring(char*, int, int, int, int);
+static void printelt(SEXP, int, int, int);
+static void RefreshKeyboardMapping(DEEvent*);
+ 
+/* Functions to hide Xlib calls */
+static void bell(void);
+static void cleararea(int, int, int, int);
+static void copyH(int, int, int);
+static void copyarea(int, int, int, int);
+static void doConfigure(DEEvent *ioevent);
+#if 0
+static void drawline(int, int, int, int);
+#endif
+static void drawrectangle(int, int, int, int, int, int);
+static void drawtext(int, int, char*, int);
+static int  NextEvent(DEEvent *ioevent);
+static void RefreshKeyboardMapping(DEEvent *ioevent);
+static void Rsync(void);
+static int textwidth(char*, int);
+static int WhichEvent(DEEvent ioevent);
+
+static SEXP work, names, lens;
+static PROTECT_INDEX wpi, npi, lpi;
+static SEXP ssNA_STRING;
+static double ssNA_REAL;
+
+/* Global variables needed for the graphics */
+ 
+static int box_w;                       /* width of a box */
+static int boxw[100];
+static int box_h;                       /* height of a box */
+static int windowWidth;                 /* current width of the window */
+static int fullwindowWidth;
+static int windowHeight;                /* current height of the window */
+static int fullwindowHeight;
+static int currentexp;                  /* boolean: whether an cell is active */
+static int crow;                        /* current row */
+static int ccol;                        /* current column */
+static int nwide, nhigh;
+static int colmax, colmin, rowmax, rowmin;
+static int ndecimal;                    /* count decimal points */
+static int ne;                          /* count exponents */
+static int nneg;			/* indicate whether its a negative */
+static int clength;                     /* number of characters currently entered */
+static char buf[30];
+static char *bufp;
+static int bwidth;			/* width of the border */
+static int hwidth;			/* width of header  */
+static int text_offset;
+ 
+static SEXP ssNewVector(SEXPTYPE, int);
+static SEXP ssNA_STRING;
+static double ssNA_REAL;
+
+static Atom _XA_WM_PROTOCOLS, protocol;
+
+static Rboolean newcol, CellModified;
+static int nboxchars;
+static int xmaxused, ymaxused;
+static int box_coords[6];
+static char copycontents[sizeof(buf)+1] ;
+static int labdigs=4;
+static char labform[6];
+
+
+/* Xwindows Globals */
+ 
+static Display          *iodisplay;
+static Window           iowindow, menuwindow, menupanes[4];
+static GC               iogc;
+static XSizeHints       iohint;
+static char             font_name[BUFSIZ];
+static XFontSet         font_info;
+static XrmDatabase      xrmdb;
+
+#define mouseDown 	ButtonPress
+#define keyDown		KeyPress
+#define activateEvt	MapNotify
+#define updateEvt	Expose
+  
+#ifndef max
+#define max(a, b) (((a)>(b))?(a):(b))
+#endif
+#ifndef min
+#define min(a, b) (((a)<(b))?(a):(b))
+#endif
+#define BOXW(x) (min(((x<100 && nboxchars==0)?boxw[x]:box_w), fullwindowWidth-boxw[0]-2*bwidth-2))
+
+/*
+  Underlying assumptions (for this version R >= 1.8.0)
+
+  The data are stored in a list `work', with unused columns having
+  NULL entries.  The names for the list are in `names', which should
+  have a name for all displayable columns (up to xmaxused). 
+  The *used* lengths of the columns are in `lens': this needs only be
+  set for non-NULL columns.
+
+  If the list was originally length(0), that should work with 
+  0 pre-defined rows.  (It used to have 1 pre-defined numeric column.)
+
+  All row and col numbers are 1-based.
+
+  BDR May 2003
+ */
+
+/*
+   The spreadsheet function returns a list of vectors. The types of
+   these vectors can be specified by the user as can their names. It
+   the names are specified they are set during initialization. The
+   user can change these via a menu interface, they can also change
+   the type.
+
+   The vectors are created too long and if they need to be increased
+   this is done by using the next higher power of 2. They start 100
+   long. To cut them to the correct length for return you need to know
+   the largest row number that was assigned to. LEVELS (sxpinfo.gp) is
+   used to keep track of this, separately for each vector. Vectors are
+   initialized to NA when they are created so that NA is returned for
+   any cell that was not set by the user.  So that coercion back and
+   forth maintains values of ssNA_REAL and ssNA_STRING I have set
+   ssNA_STRING to be coerceVector(ssNA_REAL), very weird but easy.
+
+   In Macintosh we needed to call the main event loop to get
+   events. This ensures that the spreadsheet interacts well with the
+   other windows. Under X windows we let the window manager handle
+   those sorts of details.
+
+ */
+
+static char *menu_label[] =
+{
+    "Real",
+    "Character",
+    "Change Name",
+};
+
+/*
+   ssNewVector is just an interface to allocVector but it lets us
+   set the fields to NA. We need to have a special NA for reals and
+   strings so that we can differentiate between uninitialized elements
+   in the vectors and user supplied NA's; hence ssNA_REAL and ssNA_STRING
+ */
+
+static SEXP ssNewVector(SEXPTYPE type, int vlen)
+{
+    SEXP tvec;
+    int j;
+
+    tvec = allocVector(type, vlen);
+    for (j = 0; j < vlen; j++)
+	if (type == REALSXP)
+	    REAL(tvec)[j] = ssNA_REAL;
+	else if (type == STRSXP)
+	    SET_STRING_ELT(tvec, j, STRING_ELT(ssNA_STRING, 0));
+    SETLEVELS(tvec, 0);
+    return (tvec);
+}
+
+static void closewin_cend(void *data)
+{
+    closewin();
+}
+
+SEXP RX11_dataentry(SEXP call, SEXP op, SEXP args, SEXP rho)
+{
+    SEXP colmodes, tnames, tvec, tvec2, work2;
+    SEXPTYPE type;
+    int i, j, cnt, len, nprotect;
+    RCNTXT cntxt;
+    char clab[25];
+
+    nprotect = 0;/* count the PROTECT()s */
+    PROTECT_WITH_INDEX(work = duplicate(CAR(args)), &wpi); nprotect++;
+    colmodes = CADR(args);
+    tnames = getAttrib(work, R_NamesSymbol);
+
+    if (TYPEOF(work) != VECSXP || TYPEOF(colmodes) != VECSXP)
+	errorcall(call, "invalid argument");
+
+    /* initialize the constants */
+
+    bufp = buf;
+    ne = 0;
+    currentexp = 0;
+    nneg = 0;
+    ndecimal = 0;
+    clength = 0;
+    ccol = 1;
+    crow = 1;
+    colmin = 1;
+    rowmin = 1;
+    ssNA_REAL = -NA_REAL;
+    tvec = allocVector(REALSXP, 1);
+    REAL(tvec)[0] = ssNA_REAL;
+    PROTECT(ssNA_STRING = coerceVector(tvec, STRSXP)); nprotect++;
+    bwidth = 5;
+    hwidth = 30;
+
+    /* setup work, names, lens  */
+    xmaxused = length(work); ymaxused = 0;
+    PROTECT_WITH_INDEX(lens = allocVector(INTSXP, xmaxused), &lpi);
+    nprotect++;
+
+    if (isNull(tnames)) {
+	PROTECT_WITH_INDEX(names = allocVector(STRSXP, xmaxused), &npi);
+	for(i = 0; i < xmaxused; i++) {
+	    sprintf(clab, "var%d", i);
+	    SET_STRING_ELT(names, i, mkChar(clab));
+	}
+    } else
+	PROTECT_WITH_INDEX(names = duplicate(tnames), &npi);
+    nprotect++;
+    for (i = 0; i < xmaxused; i++) {
+	int len = LENGTH(VECTOR_ELT(work, i));
+	INTEGER(lens)[i] = len;
+	ymaxused = max(len, ymaxused);
+	type = TYPEOF(VECTOR_ELT(work, i));
+	if (LENGTH(colmodes) > 0 && !isNull(VECTOR_ELT(colmodes, i)))
+	    type = str2type(CHAR(STRING_ELT(VECTOR_ELT(colmodes, i), 0)));
+	if (type != STRSXP) type = REALSXP;
+	if (isNull(VECTOR_ELT(work, i))) {
+	    if (type == NILSXP) type = REALSXP;
+	    SET_VECTOR_ELT(work, i, ssNewVector(type, 100));
+	} else if (!isVector(VECTOR_ELT(work, i)))
+	    errorcall(call, "invalid type for value");
+	else {
+	    if (TYPEOF(VECTOR_ELT(work, i)) != type)
+		SET_VECTOR_ELT(work, i, 
+			       coerceVector(VECTOR_ELT(work, i), type));
+	}
+    }
+
+
+    /* start up the window, more initializing in here */
+    if (initwin())
+	errorcall(call, "invalid device");
+
+    /* set up a context which will close the window if there is an error */
+    begincontext(&cntxt, CTXT_CCODE, R_NilValue, R_NilValue, R_NilValue,
+		 R_NilValue, R_NilValue);
+    cntxt.cend = &closewin_cend;
+    cntxt.cenddata = NULL;
+
+    highlightrect();
+
+    eventloop();
+
+    endcontext(&cntxt);
+    closewin();
+
+    /* drop out unused columns */
+    for(i = 0, cnt = 0; i < xmaxused; i++)
+	if(!isNull(VECTOR_ELT(work, i))) cnt++;
+    if (cnt < xmaxused) {
+	PROTECT(work2 = allocVector(VECSXP, cnt)); nprotect++;
+	for(i = 0, j = 0; i < xmaxused; i++) {
+	    if(!isNull(VECTOR_ELT(work, i))) {
+		SET_VECTOR_ELT(work2, j, VECTOR_ELT(work, i));
+		INTEGER(lens)[j] = INTEGER(lens)[i];
+		SET_STRING_ELT(names, j, STRING_ELT(names, i));
+		j++;
+	    }
+	}
+	REPROTECT(names = lengthgets(names, cnt), npi);
+    } else work2 = work;
+
+    for (i = 0; i < LENGTH(work2); i++) {
+	len = INTEGER(lens)[i];
+	tvec = VECTOR_ELT(work2, i);
+	if (LENGTH(tvec) != len) {
+	    tvec2 = ssNewVector(TYPEOF(tvec), len);
+	    for (j = 0; j < len; j++) {
+		if (TYPEOF(tvec) == REALSXP) {
+		    if (REAL(tvec)[j] != ssNA_REAL)
+			REAL(tvec2)[j] = REAL(tvec)[j];
+		    else
+			REAL(tvec2)[j] = NA_REAL;
+		} else if (TYPEOF(tvec) == STRSXP) {
+		    if (!streql(CHAR(STRING_ELT(tvec, j)),
+				CHAR(STRING_ELT(ssNA_STRING, 0))))
+			SET_STRING_ELT(tvec2, j, STRING_ELT(tvec, j));
+		    else
+			SET_STRING_ELT(tvec2, j, NA_STRING);
+		} else
+		    error("dataentry: internal memory problem");
+	    }
+	    SET_VECTOR_ELT(work2, i, tvec2);
+	}
+    }
+
+    setAttrib(work2, R_NamesSymbol, names);    
+    UNPROTECT(nprotect);
+    return work2;
+}
+
+
+/* Window Drawing Routines */
+
+static void setcellwidths(void)
+{
+    int i, w, dw;
+
+    windowWidth = w = 2*bwidth + boxw[0] + BOXW(colmin);
+    nwide = 2;
+    for (i = 2; i < 100; i++) { /* 100 on-screen columns cannot occur */
+	dw = BOXW(i + colmin - 1);
+	if((w += dw) > fullwindowWidth) {
+	    nwide = i;
+	    windowWidth = w - dw;
+	    break;
+	}
+    }
+}
+
+static void drawwindow(void)
+{
+    int i, st;
+    XWindowAttributes attribs;
+
+    /* if there is an active cell enter the data in it */
+    closerect();
+
+    /* now set up the window with the new dimensions */
+    XGetWindowAttributes(iodisplay, iowindow, &attribs);
+    bwidth = attribs.border_width;
+    fullwindowWidth = attribs.width;
+    fullwindowHeight = attribs.height;
+    setcellwidths();
+    nhigh = (fullwindowHeight - 2 * bwidth - hwidth) / box_h;
+    windowHeight = nhigh * box_h + 2 * bwidth;
+
+    clearwindow();
+
+
+    for (i = 1; i < nhigh; i++)
+	drawrectangle(0, hwidth + i * box_h, boxw[0], box_h, 1, 1);
+     /* so row 0 and col 0 are reserved for labels */
+    colmax = colmin + (nwide - 2);
+    rowmax = rowmin + (nhigh - 2);
+    printlabs();
+    for (i = colmin; i <= colmax; i++) drawcol(i);
+
+    /* draw the quit etc boxes */
+
+    i = textwidth("Quit", 4);
+    box_coords[0] = st = fullwindowWidth - 6 - bwidth;
+    box_coords[1] = st - i;
+    drawrectangle(st - i, 3, i + 4, hwidth - 6, 1, 1);
+    drawtext(st + 2 - i, hwidth - 7, "Quit", 4);
+
+    box_coords[4] = st = st - 5*i;
+    i = textwidth("Paste", 5);
+    box_coords[5] = st - i;
+    drawrectangle(st - i, 3, i + 4, hwidth - 6, 1, 1);
+    drawtext(st + 2 - i, hwidth - 7, "Paste", 5);
+
+    box_coords[2] = st = st - 2*i;
+    i = textwidth("Copy", 4);
+    box_coords[3] = st - i;
+    drawrectangle(st - i, 3, i + 4, hwidth - 6, 1, 1);
+    drawtext(st + 2 - i, hwidth - 7, "Copy", 4);
+
+    highlightrect();
+
+    Rsync();
+
+}
+
+static void doHscroll(int oldcol)
+{
+    int i, dw;
+    int oldnwide = nwide, oldwindowWidth = windowWidth;
+
+    /* horizontal re-position */
+    setcellwidths();
+    colmax = colmin + (nwide - 2);
+    if (oldcol < colmin) { /* drop oldcol...colmin - 1 */
+	dw = boxw[0];
+	for (i = oldcol; i < colmin; i++) dw += BOXW(i);
+	copyH(dw, boxw[0], oldwindowWidth - dw + 1);
+	dw = oldwindowWidth - BOXW(oldcol) + 1;
+	cleararea(dw, hwidth, fullwindowWidth-dw, fullwindowHeight);
+	/* oldnwide includes the row labels */
+	for (i = oldcol+oldnwide-1; i <= colmax; i++) drawcol(i);
+    } else {
+	/* move one or more cols left */
+	dw = BOXW(colmin);
+	copyH(boxw[0], boxw[0] + dw, windowWidth - dw + 1);
+	dw = windowWidth + 1;
+	cleararea(dw, hwidth, fullwindowWidth-dw, fullwindowHeight);
+	drawcol(colmin);
+    }
+
+    highlightrect();
+
+    Rsync();
+}
+
+/* find_coords finds the coordinates of the upper left corner of the
+   given cell on the screen: row and col are on-screen coords */
+
+static void find_coords(int row, int col, int *xcoord, int *ycoord)
+{
+    int i, w;
+    w = bwidth;
+    if (col > 0) w += boxw[0];
+    for(i = 1; i < col; i ++) w += BOXW(i + colmin - 1);
+    *xcoord = w;
+    *ycoord = bwidth + hwidth + box_h * row;
+}
+
+/* draw the window with the top left box at column wcol and row wrow */
+
+static void jumpwin(int wcol, int wrow)
+{
+    if (wcol < 0 || wrow < 0) {
+	bell();
+	return;
+    }
+    closerect();
+    if (colmin != wcol || rowmin != wrow) {
+	colmin = wcol;
+	rowmin = wrow;
+	drawwindow();
+    } else highlightrect();
+}
+
+static void advancerect(DE_DIRECTION which)
+{
+
+    /* if we are in the header, changing a name then only down is
+       allowed */
+    if (crow < 1 && which != DOWN) {
+	bell();
+	return;
+    }
+
+    closerect();
+
+    switch (which) {
+    case UP:
+	if (crow == 1) {
+	    if (rowmin == 1)
+		bell();
+	    else
+		jumppage(UP);
+	} else
+	    crow--;
+	break;
+    case DOWN:
+	if (crow == (nhigh - 1))
+	    jumppage(DOWN);
+	else
+	    crow++;
+	break;
+    case RIGHT:
+	if (ccol == (nwide - 1))
+	    jumppage(RIGHT);
+	else
+	    ccol++;
+	break;
+    case LEFT:
+	if (ccol == 1) {
+	    if (colmin == 1)
+		bell();
+	    else
+		jumppage(LEFT);
+	} else
+	    ccol--;
+	break;
+    default:
+	UNIMPLEMENTED("advancerect");
+    }
+
+    highlightrect();
+}
+
+static char *get_col_name(int col)
+{
+    static char clab[25];
+    if (col <= xmaxused) {
+	/* don't use NA labels */
+	SEXP tmp = STRING_ELT(names, col - 1);
+	if(tmp != NA_STRING) return(CHAR(tmp));
+    }
+    sprintf(clab, "var%d", col);
+    return clab;
+}
+
+static int get_col_width(int col)
+{
+    int i, w = 0, w1;
+    char *strp;
+    SEXP tmp, lab;
+
+    if (nboxchars > 0) return box_w;
+    if (col <= xmaxused) {
+	tmp = VECTOR_ELT(work, col - 1);
+	if (isNull(tmp)) return box_w;
+	/* don't use NA labels */
+	lab = STRING_ELT(names, col - 1);
+	if(lab != NA_STRING) strp = CHAR(lab); else strp = "var12";
+	PrintDefaults(R_NilValue);
+	w = textwidth(strp, strlen(strp));
+	for (i = 0; i < INTEGER(lens)[col - 1]; i++) {
+	    strp = EncodeElement(tmp, i, 0);
+	    w1 = textwidth(strp, strlen(strp));
+	    if (w1 > w) w = w1;
+	}
+	if(w < 0.5*box_w) w = 0.5*box_w;
+	if(w < 0.8*box_w) w+= 0.1*box_w;
+	if(w > 600) w = 600;
+	return w+8;
+    }
+    return box_w;
+}
+
+static CellType get_col_type(int col)
+{
+    SEXP tmp;
+    CellType res = UNKNOWNN;
+
+    if (col <= xmaxused) {
+	tmp = VECTOR_ELT(work, col - 1);
+	if(TYPEOF(tmp) == REALSXP) res = NUMERIC;
+	if(TYPEOF(tmp) == STRSXP) res = CHARACTER;
+    }
+    return res;
+}
+
+
+/* whichcol is absolute col no, col is position on screen */
+static void drawcol(int whichcol)
+{
+    int i, src_x, src_y, len, col = whichcol - colmin + 1, bw = BOXW(whichcol);
+    char *clab;
+    SEXP tmp;
+
+    find_coords(0, col, &src_x, &src_y);
+    cleararea(src_x, src_y, bw, windowHeight);
+    for (i = 0; i < nhigh; i++)
+	drawrectangle(src_x, hwidth + i * box_h, bw, box_h, 1, 1);
+
+    /* now fill it in if it is active */
+    clab = get_col_name(whichcol);
+    printstring(clab, strlen(clab), 0, col, 0);
+
+   if (xmaxused >= whichcol) {
+	tmp = VECTOR_ELT(work, whichcol - 1);
+	if (!isNull(tmp)) {
+	    len = min(rowmax, INTEGER(lens)[whichcol - 1]);
+	    for (i = (rowmin - 1); i < len; i++)
+		printelt(tmp, i, i - rowmin + 2, col);
+	}
+    }
+    Rsync();
+}
+
+
+/* whichrow is absolute row no */
+static void drawrow(int whichrow)
+{
+    int i, src_x, src_y, row = whichrow - rowmin + 1, w;
+    char rlab[15];
+    SEXP tvec;
+
+    find_coords(row, 0, &src_x, &src_y);
+    cleararea(src_x, src_y, windowWidth, box_h);
+    drawrectangle(src_x, src_y, boxw[0], box_h, 1, 1);
+
+    sprintf(rlab, labform, whichrow);
+    printstring(rlab, strlen(rlab), row, 0, 0);
+
+    w = bwidth + boxw[0];
+    for (i = colmin; i <= colmax; i++) {
+	drawrectangle(w, src_y, BOXW(i), box_h, 1, 1);
+	w += BOXW(i);
+    }
+
+    for (i = colmin; i <= colmax; i++) {
+	if (i > xmaxused) break;
+	if (!isNull(tvec = VECTOR_ELT(work, i - 1)))
+	    if (whichrow <= INTEGER(lens)[i - 1])
+		printelt(tvec, whichrow - 1, row, i - colmin + 1);
+    }
+
+    Rsync();
+}
+
+/* printelt: print the correct value from vector[vrow] into the
+   spreadsheet in row ssrow and col sscol */
+
+/* WARNING: This has no check that you're not beyond the end of the
+   vector. Caller must check. */
+
+static void printelt(SEXP invec, int vrow, int ssrow, int sscol)
+{
+    char *strp;
+    PrintDefaults(R_NilValue);
+    if (TYPEOF(invec) == REALSXP) {
+	if (REAL(invec)[vrow] != ssNA_REAL) {
+	    strp = EncodeElement(invec, vrow, 0);
+	    printstring(strp, strlen(strp), ssrow, sscol, 0);
+	}
+    }
+    else if (TYPEOF(invec) == STRSXP) {
+	if (!streql(CHAR(STRING_ELT(invec, vrow)),
+		    CHAR(STRING_ELT(ssNA_STRING, 0)))) {
+	    strp = EncodeElement(invec, vrow, 0);
+	    printstring(strp, strlen(strp), ssrow, sscol, 0);
+	}
+    }
+    else
+	error("dataentry: internal memory error");
+}
+
+
+static void drawelt(int whichrow, int whichcol)
+{
+    int i;
+    char *clab;
+    SEXP tmp;
+
+    if (whichrow == 0) {
+	clab = get_col_name(whichcol + colmin - 1);
+	printstring(clab, strlen(clab), 0, whichcol, 0);
+    } else {
+	if (xmaxused >= whichcol + colmin - 1) {
+	    tmp = VECTOR_ELT(work, whichcol + colmin - 2);
+	    if (!isNull(tmp) && (i = rowmin + whichrow - 2) < 
+		INTEGER(lens)[whichcol + colmin - 2] )
+		printelt(tmp, i, whichrow, whichcol);
+	} else
+	    printstring("", 0, whichrow,  whichcol, 0);
+    }
+
+    Rsync();
+}
+
+static void jumppage(DE_DIRECTION dir)
+{
+    int i, w, oldcol, wcol;
+
+    switch (dir) {
+    case UP:
+	rowmin--;
+	rowmax--;
+	copyarea(0, hwidth + box_h, 0, hwidth + 2 * box_h);
+	drawrow(rowmin);
+	break;
+    case DOWN:
+	if (rowmax >= 65535) return;
+	rowmin++;
+	rowmax++;
+	copyarea(0, hwidth + 2 * box_h, 0, hwidth + box_h);
+	drawrow(rowmax);
+	break;
+    case LEFT:
+	colmin--;
+	doHscroll(colmin+1);
+	break;
+    case RIGHT:
+	oldcol = colmin;
+	wcol = colmin + ccol + 1; /* column to be selected */
+        /* There may not be room to fit the next column in */
+	w = fullwindowWidth - boxw[0] - BOXW(colmax + 1);
+	for (i = colmax; i >= oldcol; i--) {
+	    w -= BOXW(i);
+	    if(w < 0) {
+		colmin = i + 1;
+		break;
+	    }
+	}
+	ccol = wcol - colmin;
+	doHscroll(oldcol);
+	break;
+    }
+}
+/* draw a rectangle, used to highlight/downlight the current box */
+
+static void printrect(int lwd, int fore)
+{
+    int x, y;
+    find_coords(crow, ccol, &x, &y);
+    drawrectangle(x + lwd - 1, y + lwd - 1,
+		  BOXW(ccol+colmin-1) - lwd + 1,
+		  box_h - lwd + 1, lwd, fore);
+    Rsync();
+}
+
+static void downlightrect(void)
+{
+    printrect(2, 0);
+    printrect(1, 1);
+}
+
+static void highlightrect(void)
+{
+    printrect(2, 1);
+}
+
+
+static void getccol()
+{
+    SEXP tmp, tmp2;
+    int i, len, newlen, wcol, wrow;
+    SEXPTYPE type;
+    char clab[25];
+
+    wcol = ccol + colmin - 1;
+    wrow = crow + rowmin - 1;
+    if (wcol > xmaxused) {
+	/* extend work, names and lens */
+	REPROTECT(work = lengthgets(work, wcol), wpi);
+	REPROTECT(names = lengthgets(names, wcol), npi);
+	for (i = xmaxused; i < wcol; i++) {
+	    sprintf(clab, "var%d", i + 1);
+	    SET_STRING_ELT(names, i, mkChar(clab));
+	}
+	REPROTECT(lens = lengthgets(lens, wcol), lpi);
+	xmaxused = wcol;
+    }
+    newcol = FALSE;
+    if (isNull(VECTOR_ELT(work, wcol - 1))) {
+	newcol = TRUE;
+	SET_VECTOR_ELT(work, wcol - 1, ssNewVector(REALSXP, max(100, wrow)));
+	INTEGER(lens)[wcol - 1] = 0;
+    }
+    if (!isVector(tmp = VECTOR_ELT(work, wcol - 1)))
+	error("internal type error in dataentry");
+    len = INTEGER(lens)[wcol - 1];
+    type = TYPEOF(tmp);
+    if (len < wrow) {
+	for (newlen = max(len * 2, 10) ; newlen < wrow ; newlen *= 2)
+	    ;
+	tmp2 = ssNewVector(type, newlen);
+	for (i = 0; i < len; i++)
+	    if (type == REALSXP)
+		REAL(tmp2)[i] = REAL(tmp)[i];
+	    else if (type == STRSXP)
+		SET_STRING_ELT(tmp2, i, STRING_ELT(tmp, i));
+	    else
+		error("internal type error in dataentry");
+	SET_VECTOR_ELT(work, wcol - 1, tmp2);
+    }
+}
+
+/* close up the entry to a cell, put the value that has been entered
+   into the correct place and as the correct type */
+
+static void closerect(void)
+{
+    SEXP cvec;
+    int i, wcol = ccol + colmin - 1, wrow = rowmin + crow - 1, wrow0;
+    char clab[25];
+
+    *bufp = '\0';
+
+    /* first check to see if anything has been entered */
+    if (CellModified) {
+	if (crow == 0) {
+	    if (clength != 0) {
+		/* then we are entering a new column name */
+		if (xmaxused < wcol) {
+		    /* extend work, names and lens */
+		    REPROTECT(work = lengthgets(work, wcol), wpi);
+		    REPROTECT(names = lengthgets(names, wcol), npi);
+		    for (i = xmaxused; i < wcol - 1; i++) {
+			sprintf(clab, "var%d", i + 1);
+			SET_STRING_ELT(names, i, mkChar(clab));
+		    }
+		    REPROTECT(lens = lengthgets(lens, wcol), lpi);
+		    xmaxused = wcol;
+		}
+		SET_STRING_ELT(names, wcol - 1, mkChar(buf));
+		printstring(buf, strlen(buf), 0, wcol, 0);
+	    } else {
+		sprintf(buf, "var%d", ccol);
+		printstring(buf, strlen(buf), 0, wcol, 0);
+	    }
+	} else {
+	    getccol();
+	    cvec = VECTOR_ELT(work, wcol - 1);
+	    wrow0 = INTEGER(lens)[wcol - 1];
+	    if (wrow > wrow0) INTEGER(lens)[wcol - 1] = wrow;
+	    ymaxused = max(ymaxused, wrow);
+	    if (clength != 0) {
+		/* do it this way to ensure NA, Inf, ...  can get set */
+		char *endp;
+		double new = R_strtod(buf, &endp);
+		Rboolean warn = !isBlankString(endp);
+		if (TYPEOF(cvec) == STRSXP)
+		    SET_STRING_ELT(cvec, wrow - 1, mkChar(buf));
+		else
+		    REAL(cvec)[wrow - 1] = new;
+		if (newcol & warn) {
+		    /* change mode to character */
+		    SET_VECTOR_ELT(work, wcol - 1, coerceVector(cvec, STRSXP));
+		    SET_STRING_ELT(VECTOR_ELT(work, wcol - 1), wrow - 1, 
+				   mkChar(buf));
+		}
+	    } else {
+		if (TYPEOF(cvec) == STRSXP)
+		    SET_STRING_ELT(cvec, wrow - 1, NA_STRING);
+		else
+		    REAL(cvec)[wrow - 1] = NA_REAL;
+	    }
+	    drawelt(crow, ccol);  /* to get the cell scrolling right */
+	    if(wrow > wrow0) drawcol(wcol); /* to fill in NAs */
+	}
+    }
+    CellModified = FALSE;
+
+    downlightrect();
+
+    ndecimal = 0;
+    nneg = 0;
+    ne = 0;
+    currentexp = 0;
+    clength = 0;
+    bufp = buf;
+}
+
+/* print a null terminated string, check to see if it is longer than
+   the print area and print it, left adjusted if necessary; clear the
+   area of previous text; */
+
+/* This version will only display 200 chars, but the maximum col width
+   will not allow that many */
+static void printstring(char *ibuf, int buflen, int row, int col, int left)
+{
+    int i, x_pos, y_pos, bw, bufw;
+    char pbuf[201], *pc = pbuf;
+
+    find_coords(row, col, &x_pos, &y_pos);
+    if (col == 0) bw = boxw[0]; else bw = BOXW(col+colmin-1);
+    cleararea(x_pos + 2, y_pos + 2, bw - 3, box_h - 3);
+    bufw = (buflen > 200) ? 200 : buflen;
+    strncpy(pbuf, ibuf, bufw);
+    if(left) {
+	for (i = bufw; i > 1; i--) {
+	    if (textwidth(pc, i) < (bw - text_offset)) break;
+	    *(++pc) = '<';
+	}
+    } else {
+	for (i = bufw; i > 1; i--) {
+	    if (textwidth(pbuf, i) < (bw - text_offset)) break;
+	    *(pbuf + i - 2) = '>';
+	}
+    }
+    drawtext(x_pos + text_offset, y_pos + box_h - text_offset, pc, i);
+    Rsync();
+}
+
+static void clearrect(void)
+{
+    int x_pos, y_pos;
+
+    find_coords(crow, ccol, &x_pos, &y_pos);
+    cleararea(x_pos, y_pos, BOXW(ccol+colmin-1), box_h);
+    Rsync();
+}
+
+/* handlechar has to be able to parse decimal numbers and strings,
+   depending on the current column type, only printing characters
+   should get this far */
+
+/* --- Not true! E.g. ESC ends up in here... */
+
+static void handlechar(char *text)
+{
+    int c = text[0];
+
+    if ( c == '\033' ) {
+	CellModified = FALSE;
+	clength = 0;
+	bufp = buf;
+	drawelt(crow, ccol);
+	return;
+    } else
+	CellModified = TRUE;
+
+    if (clength == 0) {
+
+	if (crow == 0)	                        /* variable name */
+	    currentexp = 3;
+	else
+	    switch(get_col_type(ccol + colmin - 1)) {
+	    case NUMERIC:
+		currentexp = 1;
+		break;
+	    default:
+		currentexp = 2;
+	    }
+	clearrect();
+	highlightrect();
+    }
+
+    if (currentexp == 1)	/* we are parsing a number */
+	switch (c) {
+	case '-':
+	    if (nneg == 0)
+		nneg++;
+	    else
+		goto donehc;
+	    break;
+	case '.':
+	    if (ndecimal == 0)
+		ndecimal++;
+	    else
+		goto donehc;
+	    break;
+	case 'e':
+	case 'E':
+	    if (ne == 0) {
+		nneg = ndecimal = 0;	/* might have decimal in exponent */
+		ne++;
+	    }
+	    else
+		goto donehc;
+	    break;
+	default:
+	    if (!isdigit((int)text[0]))
+		goto donehc;
+	    break;
+	}
+    if (currentexp == 3) {
+	if (isspace(c))
+	    goto donehc;
+	if (clength == 0) {
+	    if (c != '.' && !isalpha(c))
+		goto donehc;
+	    else if (c != '.' && !isalnum(c))
+		goto donehc;
+	}
+    }
+
+    if (clength++ > 29) {
+	warning("dataentry: expression too long");
+	clength--;
+	goto donehc;
+    }
+
+    *bufp++ = text[0];
+    printstring(buf, clength, crow, ccol, 1);
+    return;
+
+ donehc:
+    bell();
+}
+
+static void printlabs(void)
+{
+    char clab[15], *p;
+    int i;
+
+    for (i = colmin; i <= colmax; i++) {
+	p = get_col_name(i);
+	printstring(p, strlen(p), 0, i - colmin + 1, 0);
+    }
+    for (i = rowmin; i <= rowmax; i++) {
+	sprintf(clab, labform, i);
+	printstring(clab, strlen(clab), i - rowmin + 1, 0, 0);
+    }
+}
+
+               /* ================ X11-specific ================ */
+
+/* find out whether the button click was in the quit box */
+static int checkquit(int xw)
+{
+    if (xw > box_coords[1] && xw < box_coords[0]) return 1;
+    if (xw > box_coords[3] && xw < box_coords[2]) return 2;
+    if (xw > box_coords[5] && xw < box_coords[4]) return 3;
+    return 0;
+}
+
+/* when a buttonpress event happens find the square that is being
+   pointed to if the pointer is in the header we need to see if the
+   quit button was pressed and if so quit. This is done by having
+   findcell return an int which is zero if we should quit and one
+   otherwise */
+
+static int findcell(void)
+{
+
+    int xw, yw, xr, yr, wcol=0, wrow, i, w;
+    unsigned int keys;
+    Window root, child;
+
+    closerect();
+    XQueryPointer(iodisplay, iowindow, &root, &child,
+		  &xr, &yr, &xw, &yw, &keys);
+
+    if (keys & Button1Mask) { /* left click */
+
+	/* check to see if the click was in the header */
+
+	if (yw < hwidth + bwidth) {
+	    i =  checkquit(xw);
+	    if (i == 1) return 1;
+	    else if (i == 2) copycell();
+	    else if (i == 3) pastecell(crow, ccol);
+	    return 0;
+	}
+	    
+
+	/* see if it is in the row labels */
+	if (xw < bwidth + boxw[0]) {
+	    bell();
+	    highlightrect();
+	    return 0;
+	}
+	/* translate to box coordinates */
+	wrow = (yw - bwidth - hwidth) / box_h;
+	w = bwidth + boxw[0];
+	for (i = 1; i <= nwide; i++)
+	    if((w += BOXW(i+colmin-1)) > xw) {
+		wcol = i;
+		break;
+	    }
+
+	/* next check to see if it is in the column labels */
+
+	if (yw < hwidth + bwidth + box_h) {
+	    if (xw > bwidth + boxw[0])
+		popupmenu(xr, yr, wcol, wrow);
+	    else {
+		highlightrect();
+		bell();
+	    }
+	} else if (wrow > nhigh - 1 || wcol > nwide -1) {
+		/* off the grid */
+		highlightrect();
+		bell();
+	} else if (wcol != ccol || wrow != crow) {
+	    ccol = wcol;
+	    crow = wrow;
+	}
+    }
+    if (keys & Button2Mask) { /* Paste */
+	int row, col = 0;
+	
+	if (yw < hwidth + bwidth || xw < bwidth + boxw[0]) return 0;
+
+	/* translate to box coordinates */
+	row = (yw - bwidth - hwidth) / box_h;
+	w = bwidth + boxw[0];
+	for (i = 1; i <= nwide; i++)
+	    if ((w += BOXW(i+colmin-1)) > xw) {
+		col = i;
+		break;
+	    }
+	pastecell(row, col);
+    }
+    highlightrect();
+    return 0;
+}
+
+
+/* Event Loop Functions */
+
+static void eventloop(void)
+{
+    int done;
+    DEEvent ioevent;
+
+
+    done = 0;
+    while (done == 0) {
+	if (NextEvent(&ioevent)) {
+	    switch (WhichEvent(ioevent)) {
+	    case activateEvt:
+		drawwindow();
+ 		break;
+	    case mouseDown:
+		done  = doMouseDown(&ioevent);
+		break;
+	    case keyDown:
+		doSpreadKey(0, &ioevent);
+		break;
+	    case MappingNotify:
+		RefreshKeyboardMapping(&ioevent);
+		break;
+	    case ConfigureNotify:
+		doConfigure(&ioevent);
+		break;
+	    case ClientMessage:
+		if(ioevent.xclient.message_type == _XA_WM_PROTOCOLS
+		   && ioevent.xclient.data.l[0] == protocol) {
+		    /* user clicked on `close' aka `destroy' */
+		       done = 1;
+		}
+		break;
+	    }
+	}
+    }
+}
+
+static int doMouseDown(DEEvent * event)
+{
+    return findcell();
+}
+
+static void doSpreadKey(int key, DEEvent * event)
+{
+    KeySym iokey;
+    char text[1];
+
+    iokey = GetKey(event);
+    text[0] = GetCharP(event);
+
+    if (CheckControl(event))
+	doControl(event);
+    else if ((iokey == XK_Return)  || (iokey == XK_KP_Enter) || 
+	     (iokey == XK_Linefeed)|| (iokey == XK_Down))
+	advancerect(DOWN);
+    else if (iokey == XK_Left)
+	advancerect(LEFT);
+    else if (iokey == XK_Right)
+	advancerect(RIGHT);
+    else if (iokey == XK_Up)
+	advancerect(UP);
+#ifdef XK_Page_Up
+    else if (iokey == XK_Page_Up) {
+	int i = rowmin - nhigh + 2;
+	jumpwin(colmin, max(1, i));
+    }
+#elif defined(XK_Prior)
+    else if (iokey == XK_Prior) {
+	int i = rowmin - nhigh + 2;
+	jumpwin(colmin, max(1, i));
+    }
+#endif
+#ifdef XK_Page_Down
+    else if (iokey == XK_Page_Down)
+	jumpwin(colmin, rowmax);
+#elif defined(XK_Next)
+    else if (iokey == XK_Next)
+	jumpwin(colmin, rowmax);
+#endif
+    else if ((iokey == XK_BackSpace) || (iokey == XK_Delete)) {
+	if (clength > 0) {
+	    clength--;
+	    bufp--;
+	    printstring(buf, clength, crow, ccol, 1);
+	} else bell();
+    }
+    else if (iokey == XK_Tab) {
+	if(CheckShift(event)) advancerect(LEFT);
+	else advancerect(RIGHT);
+    }
+    else if (iokey == XK_Home) {
+	jumpwin(1, 1);
+	downlightrect();
+	crow = ccol = 1;
+	highlightrect();
+    }
+    else if (iokey == XK_End) {
+	int i = ymaxused - nhigh + 2;
+	jumpwin(xmaxused, max(i, 1));
+	downlightrect();
+	crow = ymaxused - rowmin + 1;
+	ccol = 1;
+	highlightrect();
+    }
+    else if (IsModifierKey(iokey)) {
+    }
+    else
+	handlechar(text);
+}
+
+static int NextEvent(DEEvent * ioevent)
+{
+    XNextEvent(iodisplay, ioevent);
+    return 1;
+}
+
+static int WhichEvent(DEEvent ioevent)
+{
+    return ioevent.type;
+}
+
+static KeySym GetKey(DEEvent * event)
+{
+    char text[1];
+    KeySym iokey;
+
+    XLookupString((XKeyEvent *)event, text, 1, &iokey, 0);
+    return iokey;
+}
+
+static char GetCharP(DEEvent * event)
+{
+    char text[1];
+    KeySym iokey;
+
+    XLookupString((XKeyEvent *)event, text, 1, &iokey, 0);
+    return text[0];
+}
+
+static int CheckControl(DEEvent * event)
+{
+    return (*event).xkey.state & ControlMask;
+}
+
+static int CheckShift(DEEvent * event)
+{
+    return (*event).xkey.state & ShiftMask;
+}
+
+static void doControl(DEEvent * event)
+{
+    int i;
+    char text[1];
+    KeySym iokey;
+
+    (*event).xkey.state = 0;
+    XLookupString((XKeyEvent *)event, text, 1, &iokey, 0);
+    /* one row overlap when scrolling: top line <--> bottom line */
+    switch (text[0]) {
+	case 'b':
+	    i = rowmin - nhigh + 2;
+	    jumpwin(colmin, max(1, i));
+	    break;
+	case 'f':
+	    jumpwin(colmin, rowmax);
+	    break;
+	case 'l':
+	    closerect();
+	    for (i = 1 ; i <= min(100, xmaxused); i++)
+		boxw[i] = get_col_width(i);
+	    drawwindow();
+	    break;
+    }
+}
+
+
+static void doConfigure(DEEvent * event)
+{
+    if ((fullwindowWidth != (*event).xconfigure.width) ||
+	(fullwindowHeight != (*event).xconfigure.height))
+	drawwindow();
+}
+
+static void RefreshKeyboardMapping(DEEvent * event)
+{
+    XRefreshKeyboardMapping((XKeyEvent *)event);
+}
+
+/* Initialize/Close Windows */
+
+void closewin(void)
+{
+    XFreeGC(iodisplay, iogc);
+    XDestroyWindow(iodisplay, iowindow);
+    XCloseDisplay(iodisplay);
+    XrmDestroyDatabase(xrmdb);
+}
+
+static int R_X11Err(Display *dsp, XErrorEvent *event)
+{
+    char buff[1000];
+    XGetErrorText(dsp, event->error_code, buff, 1000);
+    warning("X11 protocol error: %s", buff);
+    return 0;
+}
+
+static int R_X11IOErr(Display *dsp)
+{
+    error("X11 fatal IO error: please save work and shut down R");
+    return 0; /* but should never get here */
+}
+
+static XFontSet XLoadQueryFontSet(Display *display,
+                                  const char *fontset_name)
+{
+    XFontSet fontset;
+    int  missing_charset_count;
+    char **missing_charset_list;
+    char *def_string;
+  
+    fontset = XCreateFontSet(display,
+			     fontset_name,
+			     &missing_charset_list,
+			     &missing_charset_count,
+			     &def_string);
+    if (missing_charset_count) {
+        Rprintf("Missing charsets in FontSet(%s) creation.\n", fontset_name);
+	XFreeStringList(missing_charset_list);
+    }
+    return fontset;
+}
+
+static void XSetFontSet(Display *display,
+			GC gc,
+			XFontSet font
+			)
+{
+    char **ml;
+    XFontStruct **fs_list;
+    int i;
+    int cnt;
+
+    cnt = XFontsOfFontSet(font, &fs_list, &ml);
+    for(i=0;i<cnt;i++){
+        XSetFont(display,gc,fs_list[i]->fid);
+    }
+}
+
+/* set up the window, print the grid and column/row labels */
+
+static Rboolean initwin(void) /* TRUE = Error */
+{
+    int i, twidth, w, minwidth;
+    int ioscreen;
+    unsigned long iowhite, ioblack;
+    char ioname[] = "R DataEntryWindow";
+    char digits[] = "123456789.0";
+    Window root;
+    XEvent ioevent;
+    XSetWindowAttributes winattr;
+    XWindowAttributes attribs;
+    XFontSetExtents *extent;
+    XFontStruct **fs_list;
+    char **ml;
+    unsigned long fevent=0UL;
+
+    strcpy(copycontents,"");
+
+    XrmInitialize();
+
+    if (!XSupportsLocale ()) {
+        Rprintf("locale not supported by Xlib, locale set to C\n");
+        setlocale (LC_ALL, "C");
+    }
+    if (!XSetLocaleModifiers ("")) {
+        Rprintf("can not set locale modifiers\n");
+    }
+
+    if ((iodisplay = XOpenDisplay(NULL)) == NULL) 
+	return TRUE;
+    XSetErrorHandler(R_X11Err);
+    XSetIOErrorHandler(R_X11IOErr);
+
+    /* Get Font Loaded if we can */
+
+    xrmdb = CreateDB(iodisplay);
+    GetFontResource(xrmdb, font_name, sizeof(font_name), 1, 14);
+    font_info = XLoadQueryFontSet(iodisplay, font_name);
+    if (font_info == NULL) 
+	return TRUE; /* ERROR */
+
+    /* find out how wide the input boxes should be and set up the
+       window size defaults */
+
+    nboxchars = asInteger(GetOption(install("de.cellwidth"), R_GlobalEnv));
+    if (nboxchars == NA_INTEGER || nboxchars < 0) nboxchars = 0;
+
+    twidth = textwidth(digits, strlen(digits));
+    if (nboxchars > 0) twidth = (twidth * nboxchars)/10;
+    box_w = twidth + 4;
+    extent = XExtentsOfFontSet(font_info);
+    box_h = (extent->max_logical_extent.height)
+          + (extent->max_logical_extent.height / 5) + 4;
+    XFontsOfFontSet(font_info, &fs_list, &ml);
+    text_offset = 2 + fs_list[0]->max_bounds.descent;
+    windowHeight = 26 * box_h + hwidth + 2;
+    /* this used to presume 4 chars sufficed for row numbering */
+    labdigs = max(3, 1+floor(log10((double)ymaxused)));
+    sprintf(labform, "%%%dd", labdigs);
+    boxw[0] = 0.1*labdigs*textwidth("0123456789", 10) + textwidth(" ", 1) + 8;
+    for(i = 1; i < 100; i++) boxw[i] = get_col_width(i);
+    /* try for a window width that covers all the columns, or is around
+       800 pixels */
+    w = windowWidth = 0;
+    for(i = 0; i <= xmaxused; i++) {
+	w += boxw[i];
+	if(w > 800) {
+	    windowWidth = w - boxw[i];
+	    break;
+	}
+    }
+    if(windowWidth == 0) windowWidth = w;
+    windowWidth += 2;
+    /* allow enough width for buttons */
+    minwidth = 7.5 * textwidth("Paste", 5);
+    if(windowWidth < minwidth) windowWidth = minwidth;
+
+    ioscreen = DefaultScreen(iodisplay);
+    iowhite = WhitePixel(iodisplay, ioscreen);
+    ioblack = BlackPixel(iodisplay, ioscreen);
+
+
+    iohint.x = 0;
+    iohint.y = 0;
+    iohint.width = windowWidth;
+    iohint.height = windowHeight;
+    iohint.flags = PPosition | PSize;
+    root = DefaultRootWindow(iodisplay);
+
+    if ((iowindow = XCreateSimpleWindow(
+	iodisplay,
+	root,
+	iohint.x,
+	iohint.y,
+	iohint.width,
+	iohint.height,
+	bwidth,
+	ioblack,
+	iowhite)) == 0)
+	return TRUE;
+
+    XSetStandardProperties(iodisplay, iowindow, ioname, ioname, None,
+			   (char **)NULL, 0, &iohint);
+
+    winattr.backing_store = Always;
+    XChangeWindowAttributes(iodisplay, iowindow, CWBackingStore, &winattr);
+
+    /* set up protocols so that window manager sends */
+    /* me an event when user "destroys" window */
+    _XA_WM_PROTOCOLS = XInternAtom(iodisplay, "WM_PROTOCOLS", 0);
+    protocol = XInternAtom(iodisplay, "WM_DELETE_WINDOW", 0);
+    XSetWMProtocols(iodisplay, iowindow, &protocol, 1);
+
+
+    iogc = XCreateGC(iodisplay, iowindow, 0, 0);
+    XSetFontSet(iodisplay, iogc, font_info);
+    XSetBackground(iodisplay, iogc, iowhite);
+    XSetForeground(iodisplay, iogc, BlackPixel(iodisplay,
+					       DefaultScreen(iodisplay)));
+    XSetLineAttributes(iodisplay, iogc, 1, LineSolid, CapRound, JoinRound);
+
+    XSelectInput(iodisplay, iowindow,
+		 ButtonPressMask | KeyPressMask
+		 | ExposureMask | StructureNotifyMask);
+    XMapRaised(iodisplay, iowindow);
+
+
+    /* now set up the menu-window, for now use the same text
+       dimensions as above */
+
+    menuwindow = XCreateSimpleWindow(iodisplay, root, 0, 0, twidth,
+				     4 * box_h, 2, ioblack, iowhite);
+    for (i = 0; i < 4; i++) {
+	menupanes[i] = XCreateSimpleWindow(iodisplay, menuwindow, 0,
+					   box_h * i, twidth, box_h,
+					   1, ioblack, iowhite);
+	XSelectInput(iodisplay, menupanes[i],
+		     ButtonPressMask | ButtonReleaseMask | ExposureMask);
+    }
+
+    /* XMapSubwindows(iodisplay, menuwindow); */
+
+
+    winattr.override_redirect = True;
+    XChangeWindowAttributes(iodisplay, menuwindow,
+			    CWBackingStore | CWOverrideRedirect, &winattr);
+    Rsync();
+
+    /* this next sequence makes sure the window is up and ready before
+       you start drawing in it */
+
+    XNextEvent(iodisplay, &ioevent);
+    if (ioevent.xany.type == Expose) {
+	while (ioevent.xexpose.count)
+	    XNextEvent(iodisplay, &ioevent);
+    }
+    XGetWindowAttributes(iodisplay, iowindow, &attribs);
+    bwidth = attribs.border_width;
+    fullwindowWidth = attribs.width;
+    fullwindowHeight = attribs.height;
+
+
+    /* set the active rectangle to be the upper left one */
+    crow = 1;
+    ccol = 1;
+    CellModified = FALSE;
+    return FALSE;/* success */
+}
+
+/* MAC/X11 BASICS */
+
+static void bell(void)
+{
+    XBell(iodisplay, 20);
+}
+
+static void cleararea(int xpos, int ypos, int width, int height)
+{
+    XClearArea(iodisplay, iowindow, xpos, ypos, width, height, 0);
+}
+
+static void clearwindow(void)
+{
+    XClearWindow(iodisplay, iowindow);
+}
+
+static void copyarea(int src_x, int src_y, int dest_x, int dest_y)
+{
+    int mx = max(src_x, dest_x), my = max(src_y, dest_y);
+    XCopyArea(iodisplay, iowindow, iowindow, iogc, src_x, src_y,
+	      fullwindowWidth - mx, fullwindowHeight - my,
+	      dest_x, dest_y);
+    Rsync();
+}
+
+static void copyH(int src_x, int dest_x, int width)
+{
+    XCopyArea(iodisplay, iowindow, iowindow, iogc, src_x+bwidth, hwidth,
+	      width, windowHeight+1, dest_x+bwidth, hwidth);
+}
+
+#if 0
+static void drawline(int fromx, int fromy, int tox, int toy)
+{
+    XDrawLine(iodisplay, iowindow, iogc, fromx, fromy, tox, toy);
+}
+#endif
+
+static void drawrectangle(int xpos, int ypos, int width, int height,
+			  int lwd, int fore)
+{
+    if (fore == 0)
+	XSetForeground(iodisplay, iogc, WhitePixel(iodisplay,
+						   DefaultScreen(iodisplay)));
+    else
+	XSetForeground(iodisplay, iogc, BlackPixel(iodisplay,
+						   DefaultScreen(iodisplay)));
+    XSetLineAttributes(iodisplay, iogc, lwd, LineSolid, CapRound, JoinRound);
+    XDrawRectangle(iodisplay, iowindow, iogc, xpos, ypos, width, height);
+}
+
+static void drawtext(int xpos, int ypos, char *text, int len)
+{
+    XRfDrawImageString(iodisplay, iowindow, font_info,iogc, xpos,
+		       ypos, text, len);
+    Rsync();
+}
+
+static void Rsync()
+{
+    XSync(iodisplay, 0);
+}
+
+static int textwidth(char *text, int nchar)
+{
+    int t1;
+
+    t1 = XRfTextEscapement(font_info, text, nchar);
+    return t1;
+}
+
+/* Menus */
+
+void popupmenu(int x_pos, int y_pos, int col, int row)
+{
+    int i, button, popupcol = col + colmin - 1;
+    char *name, clab[20];
+    XEvent event;
+    Window selected_pane;
+    SEXP tvec;
+
+    XMapSubwindows(iodisplay, menuwindow);
+    XMapRaised(iodisplay, menuwindow);
+    XMoveWindow(iodisplay, menuwindow, x_pos, y_pos);
+
+    /* now fill in the menu panes with the correct information */
+
+    if (popupcol > xmaxused) {
+	/* extend work, names and lens */
+	REPROTECT(work = lengthgets(work, popupcol), wpi);
+	REPROTECT(names = lengthgets(names, popupcol), npi);
+	for (i = xmaxused+1; i < popupcol; i++) {
+	    sprintf(clab, "var%d", i + 1);
+	    SET_STRING_ELT(names, i, mkChar(clab));
+	}
+	REPROTECT(lens = lengthgets(lens, popupcol), lpi);
+	xmaxused = popupcol;
+    }
+    tvec = VECTOR_ELT(work, popupcol - 1);
+    name = CHAR(STRING_ELT(names, popupcol - 1));
+    XDrawString(iodisplay,
+		menupanes[0], iogc, 3, box_h - 3, name, strlen(name));
+    for (i = 1; i < 4; i++)
+	XDrawString(iodisplay,
+		    menupanes[i], iogc, 3, box_h - 3,
+		    menu_label[i - 1], strlen(menu_label[i - 1]));
+    if (isNull(tvec) || TYPEOF(tvec) == REALSXP)
+	XDrawString(iodisplay, menupanes[1], iogc, box_w - 20, box_h - 3,
+		    "X", 1);
+    else
+	XDrawString(iodisplay, menupanes[2], iogc, box_w - 20, box_h - 3,
+		    "X", 1);
+
+/*
+  start an event loop; we're looking for a button press and a button
+  release in the same window
+*/
+
+    while (1) {
+	XNextEvent(iodisplay, &event);
+	if (event.type == ButtonPress) {
+	    button = event.xbutton.button;
+	    selected_pane = event.xbutton.window;
+	    for (i = 0; selected_pane != menupanes[i]; i++)
+		if (i >= 4) goto done;
+	    while (1) {
+		while (XCheckTypedEvent(iodisplay, ButtonPress, &event));
+		XMaskEvent(iodisplay, ButtonReleaseMask, &event);
+		if (event.xbutton.button == button)
+		    break;
+	    }
+	    if (selected_pane == event.xbutton.window) {
+		for (i = 0; selected_pane != menupanes[i]; i++);
+		switch (i) {
+		case 0:
+		    bell();
+		    break;
+		case 1:
+		    if (isNull(tvec)) 
+			SET_VECTOR_ELT(work, popupcol - 1, 
+				       ssNewVector(REALSXP, 100));
+		    else
+			SET_VECTOR_ELT(work, popupcol - 1,
+				       coerceVector(tvec, REALSXP));
+		    goto done;
+		case 2:
+		    if (isNull(tvec)) 
+			SET_VECTOR_ELT(work, popupcol - 1, 
+				       ssNewVector(STRSXP, 100));
+		    else
+			SET_VECTOR_ELT(work, popupcol - 1, 
+				       coerceVector(tvec, STRSXP));
+		    goto done;
+		case 3:
+		    closerect();
+		    ccol = col;
+		    crow = 0;
+		    clearrect();
+		    goto done;
+		}
+	    }
+	}
+        /* this doesn't work and perhaps I should move it up to the
+           main control loop */
+	else if (event.type == Expose) {
+	    if (event.xexpose.window == menuwindow) {
+		XDrawString(iodisplay, menupanes[0], iogc, 3, box_h - 3,
+			    name, strlen(name));
+		for (i = 1; i < 4; i++)
+		    XDrawString(iodisplay, menupanes[i], iogc, 3, box_h - 3,
+				menu_label[i - 1], strlen(menu_label[i - 1]));
+	    }
+	}
+    }
+ done:
+    popdownmenu();
+    highlightrect();
+}
+
+void popdownmenu(void)
+{
+    XUnmapWindow(iodisplay, menuwindow);
+    XUnmapSubwindows(iodisplay, menuwindow);
+}
+
+static void copycell(void)
+{
+    int i, whichrow = crow + colmin - 1, whichcol = ccol + colmin -1;
+    SEXP tmp;
+    
+    if (whichrow == 0) {
+	/* won't have  cell here */
+    } else {
+	strcpy(copycontents, "");
+	if (length(work) >= whichcol) {
+	  tmp = VECTOR_ELT(work, whichcol - 1);
+	    if (tmp != R_NilValue &&
+		(i = whichrow - 1) < LENGTH(tmp) ) {
+		PrintDefaults(R_NilValue);
+		if (TYPEOF(tmp) == REALSXP) {
+		    if (REAL(tmp)[i] != ssNA_REAL)
+			strcpy(copycontents, EncodeElement(tmp, i, 0));
+		} else if (TYPEOF(tmp) == STRSXP) {
+		    if (!streql(CHAR(STRING_ELT(tmp, i)),
+				CHAR(STRING_ELT(ssNA_STRING, 0))))
+			strcpy(copycontents, EncodeElement(tmp, i, 0));
+		}
+	    }
+	}
+    }
+    highlightrect();
+}
+
+static void pastecell(int row, int col)
+{
+    downlightrect();
+    crow = row; ccol = col;
+    if (strlen(copycontents)) {
+	strcpy(buf, copycontents);
+	clength = strlen(copycontents);
+	bufp = buf + clength;
+	CellModified = TRUE;
+    }
+    closerect();
+    highlightrect();
+}
+#endif /* I18N_MB */
diff -ruN R-1.9.0.orig/src/modules/X11/devX11.c R-1.9.0.i18n.x11_mb/src/modules/X11/devX11.c
--- R-1.9.0.orig/src/modules/X11/devX11.c	2003-12-19 01:51:36.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/devX11.c	2004-04-22 21:19:05.000000000 +0900
@@ -1,3 +1,4 @@
+#ifndef I18N_MB
 /*
  *  R : A Computer Language for Statistical Data Analysis
  *  Copyright (C) 1995, 1996  Robert Gentleman and Ross Ihaka
@@ -1998,3 +1999,4 @@
     tmp->image = in_R_GetX11Image;
     R_setX11Routines(tmp);
 }
+#endif /* I18N_MB */
diff -ruN R-1.9.0.orig/src/modules/X11/devX11.h R-1.9.0.i18n.x11_mb/src/modules/X11/devX11.h
--- R-1.9.0.orig/src/modules/X11/devX11.h	2003-11-15 16:31:04.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/devX11.h	2004-04-22 21:19:55.000000000 +0900
@@ -1,3 +1,4 @@
+#ifndef I18N_MB
 #ifndef _DEV_X11_H
 #define _DEV_X11_H
 
@@ -123,3 +124,4 @@
 
 #endif
 
+#endif /* I18N_MB */
diff -ruN R-1.9.0.orig/src/modules/X11/devX11_mb.c R-1.9.0.i18n.x11_mb/src/modules/X11/devX11_mb.c
--- R-1.9.0.orig/src/modules/X11/devX11_mb.c	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/devX11_mb.c	2004-04-24 22:48:24.000000000 +0900
@@ -0,0 +1,2101 @@
+#ifdef I18N_MB
+/*
+ *  R : A Computer Language for Statistical Data Analysis
+ *  Copyright (C) 1995, 1996  Robert Gentleman and Ross Ihaka
+ *  Copyright (C) 1997--2003  Robert Gentleman, Ross Ihaka and the
+ *			      R Development Core Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#ifdef HAVE_RINT
+#define R_rint(x) rint(x)
+#else
+#define R_rint(x) ((int) x + 0.5)
+#endif
+
+#include <stdio.h>
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
+#include <X11/Intrinsic.h>	/*->	Xlib.h	Xutil.h Xresource.h .. */
+
+#include <locale.h>
+
+#include "Defn.h"
+#include "Graphics.h"
+#include "Fileio.h"		/* R_fopen */
+#include "rotated.h"		/* 'Public' routines from here */
+#include "rotated_mb.h"		/* 'Public' routines from here */
+/* For the input handlers of the event loop mechanism: */
+#include <R_ext/eventloop.h>
+#include <R_ext/Memory.h>	/* vmaxget */
+#include "Rdevices.h"
+
+#define R_X11_DEVICE 1
+#include "devX11_mb.h"
+#include "xrm.h"
+#include "xmb_xutf8.h"
+
+#include <R_ext/RX11.h>
+
+#define CURSOR		XC_crosshair		/* Default cursor */
+#define MM_PER_INCH	25.4			/* mm -> inch conversion */
+
+#define IS_100DPI ((int) (1./pixelHeight() + 0.5) == 100)
+
+
+#define X_BELL_VOLUME 0 /* integer between -100 and 100 for the volume
+                            of the bell in locator. */
+			/* Note: This is in relation to
+			the general bell level. Was 50, but if > 0
+			then "xset b off" will not disable the
+			locator bell - pd 2002-3-11 */
+/* a colour used to represent the background on png if transparent
+   NB: must be grey as used as RGB and BGR
+*/
+#define PNG_TRANS 0xfefefe
+
+	/********************************************************/
+	/* If there are resources that are shared by all devices*/
+	/* of this type, you may wish to make them globals	*/
+	/* rather than including them in the device-specific	*/
+	/* parameters structure (especially if they are large !)*/
+	/********************************************************/
+
+	/* X11 Driver Specific parameters
+	 * with only one copy for all x11 devices */
+
+static Display *display;			/* Display */
+static int screen;				/* Screen */
+static Window rootwin;				/* Root Window */
+static Visual *visual;				/* Visual */
+static int depth;				/* Pixmap depth */
+static int Vclass;				/* Visual class */
+static X_COLORTYPE model;			/* User color model */
+static int maxcubesize;				/* Max colorcube size */
+static XSetWindowAttributes attributes;		/* Window attributes */
+static Colormap colormap;			/* Default color map */
+static int blackpixel;				/* Black */
+static int whitepixel;				/* White */
+static XContext devPtrContext;
+static Atom _XA_WM_PROTOCOLS, protocol;
+
+static Rboolean displayOpen = FALSE;
+static Rboolean inclose = FALSE;
+static int numX11Devices = 0;
+
+	/********************************************************/
+	/* There must be an entry point for the device driver	*/
+	/* which will create device-specific resources,		*/
+	/* initialise the device-specific parameters structure	*/
+	/* and return whether the setup succeeded		*/
+	/* This is called by the graphics engine when the user	*/
+	/* creates a new device of this type			*/
+	/********************************************************/
+
+
+	/********************************************************/
+	/* There are a number of actions that every device	*/
+	/* driver is expected to perform (even if, in some	*/
+	/* cases it does nothing - just so long as it doesn't	*/
+	/* crash !).  this is how the graphics engine interacts */
+	/* with each device. ecah action will be documented	*/
+	/* individually.					*/
+	/* hooks for these actions must be set up when the	*/
+	/* device is first created				*/
+	/********************************************************/
+
+	/* Device Driver Actions */
+
+static void newX11_Activate(NewDevDesc *dd);
+static void newX11_Circle(double x, double y, double r,
+			  R_GE_gcontext *gc,
+			  NewDevDesc *dd);
+static void newX11_Clip(double x0, double x1, double y0, double y1,
+		     NewDevDesc *dd);
+static void newX11_Close(NewDevDesc *dd);
+static void newX11_Deactivate(NewDevDesc *dd);
+static void newX11_Hold(NewDevDesc *dd);
+static Rboolean newX11_Locator(double *x, double *y, NewDevDesc *dd);
+static void newX11_Line(double x1, double y1, double x2, double y2,
+			R_GE_gcontext *gc,
+			NewDevDesc *dd);
+static void newX11_MetricInfo(int c,
+			      R_GE_gcontext *gc,
+			      double* ascent, double* descent,
+			      double* width, NewDevDesc *dd);
+static void newX11_Mode(int mode, NewDevDesc *dd);
+static void newX11_NewPage(R_GE_gcontext *gc, NewDevDesc *dd);
+Rboolean newX11_Open(NewDevDesc *dd, newX11Desc *xd,
+		     char *dsp, double w, double h,
+		     double gamma_fac, X_COLORTYPE colormodel,
+		     int maxcube, int canvascolor);
+static void newX11_Polygon(int n, double *x, double *y,
+			   R_GE_gcontext *gc,
+			   NewDevDesc *dd);
+static void newX11_Polyline(int n, double *x, double *y,
+			    R_GE_gcontext *gc,
+			    NewDevDesc *dd);
+static void newX11_Rect(double x0, double y0, double x1, double y1,
+			R_GE_gcontext *gc,
+			NewDevDesc *dd);
+static void newX11_Size(double *left, double *right,
+		     double *bottom, double *top,
+		     NewDevDesc *dd);
+static double newX11_StrWidth(char *str, 
+			      R_GE_gcontext *gc,
+			      NewDevDesc *dd);
+static void newX11_Text(double x, double y, char *str,
+			double rot, double hadj,
+			R_GE_gcontext *gc,
+			NewDevDesc *dd);
+
+	/*************************************************/
+	/* End of list of required device driver actions */
+	/*************************************************/
+
+	/* Support Routines */
+
+static XFontSet XLoadQueryFontSet(Display *, const char *);
+static void *RLoadFont(newX11Desc*,int, int);
+static double pixelHeight(void);
+static double pixelWidth(void);
+static int SetBaseFont(newX11Desc*);
+static void SetColor(int, NewDevDesc*);
+static void SetFont(int, int, NewDevDesc*);
+static void SetLinetype(int, double, NewDevDesc*);
+static void X11_Close_bitmap(newX11Desc *xd);
+
+
+
+	/************************/
+	/* X11 Color Management */
+	/************************/
+
+static double RedGamma	 = 0.6;
+static double GreenGamma = 0.6;
+static double BlueGamma	 = 0.6;
+
+
+/* Variables Used To Store Colormap Information */
+static struct { int red; int green; int blue; } RPalette[512];
+static XColor XPalette[512];
+static int PaletteSize;
+
+
+/* Monochome Displays : Compute pixel values by converting */
+/* RGB values to luminance and then thresholding. */
+/* See: Foley & van Damm. */
+
+static void SetupMonochrome()
+{
+    depth = 1;
+}
+
+static unsigned GetMonochromePixel(int r, int g, int b)
+{
+    if ((int)(0.299 * r + 0.587 * g + 0.114 * b) > 127)
+	return WhitePixel(display, screen);
+    else
+	return BlackPixel(display, screen);
+}
+
+
+/* Grayscale Displays : Compute pixel values by converting */
+/* RGB values to luminance.  See: Foley & van Damm. */
+
+static unsigned GetGrayScalePixel(int r, int g, int b)
+{
+    unsigned int d, dmin = 0xFFFFFFFF;
+    unsigned int dr;
+    int i;
+    unsigned int pixel = 0;  /* -Wall */
+    int gray = (0.299 * r + 0.587 * g + 0.114 * b) + 0.0001;
+    for (i = 0; i < PaletteSize; i++) {
+	dr = (RPalette[i].red - gray);
+	d = dr * dr;
+	if (d < dmin) {
+	    pixel = XPalette[i].pixel;
+	    dmin = d;
+	}
+    }
+    return pixel;
+}
+
+static Rboolean GetGrayPalette(Display *displ, Colormap cmap, int n)
+{
+    int status, i, m;
+    m = 0;
+    i = 0;
+    for (i = 0; i < n; i++) {
+	RPalette[i].red	  = (i * 0xff) / (n - 1);
+	RPalette[i].green = RPalette[i].red;
+	RPalette[i].blue  = RPalette[i].red;
+	/* Gamma correct here */
+	XPalette[i].red	  = (i * 0xffff) / (n - 1);
+	XPalette[i].green = XPalette[i].red;
+	XPalette[i].blue  = XPalette[i].red;
+	status = XAllocColor(displ, cmap, &XPalette[i]);
+	if (status == 0) {
+	    XPalette[i].flags = 0;
+	    m++;
+	}
+	else
+	    XPalette[i].flags = DoRed|DoGreen|DoBlue;
+    }
+    PaletteSize = n;
+    if (m > 0) {
+	for (i = 0; i < PaletteSize; i++) {
+	    if (XPalette[i].flags != 0)
+		XFreeColors(displ, cmap, &(XPalette[i].pixel), 1, 0);
+	}
+	PaletteSize = 0;
+	return FALSE;
+    }
+    else return TRUE;
+}
+
+static void SetupGrayScale()
+{
+    int res = 0, d;
+    PaletteSize = 0;
+    /* try for 128 grays on an 8-bit display */
+    if (depth > 8) d = depth = 8; else d = depth - 1;
+    /* try (256), 128, 64, 32, 16 grays */
+    while (d >= 4 && !(res = GetGrayPalette(display, colormap, 1 << d)))
+	d--;
+    if (!res) {
+	/* Can't find a sensible grayscale, so revert to monochrome */
+	warning("can't set grayscale: reverting to monochrome");
+	model = MONOCHROME;
+	SetupMonochrome();
+    }
+}
+
+/* PseudoColor Displays : There are two strategies here. */
+/* 1) allocate a standard color cube and match colors */
+/* within that based on (weighted) distances in RGB space. */
+/* 2) allocate colors exactly as they are requested until */
+/* all color cells are used.  Fail with an error message */
+/* when this happens. */
+
+static int RGBlevels[][3] = {  /* PseudoColor Palettes */
+    { 8, 8, 4 },
+    { 6, 7, 6 },
+    { 6, 6, 6 },
+    { 6, 6, 5 },
+    { 6, 6, 4 },
+    { 5, 5, 5 },
+    { 5, 5, 4 },
+    { 4, 4, 4 },
+    { 4, 4, 3 },
+    { 3, 3, 3 },
+    { 2, 2, 2 }
+};
+static int NRGBlevels = sizeof(RGBlevels) / (3 * sizeof(int));
+
+
+static int GetColorPalette(Display *dpy, Colormap cmap, int nr, int ng, int nb)
+{
+    int status, i, m, r, g, b;
+    m = 0;
+    i = 0;
+    for (r = 0; r < nr; r++) {
+	for (g = 0; g < ng; g++) {
+	    for (b = 0; b < nb; b++) {
+		RPalette[i].red	  = (r * 0xff) / (nr - 1);
+		RPalette[i].green = (g * 0xff) / (ng - 1);
+		RPalette[i].blue  = (b * 0xff) / (nb - 1);
+		/* Perform Gamma Correction Here */
+		XPalette[i].red	  = pow(r / (nr - 1.0), RedGamma) * 0xffff;
+		XPalette[i].green = pow(g / (ng - 1.0), GreenGamma) * 0xffff;
+		XPalette[i].blue  = pow(b / (nb - 1.0), BlueGamma) * 0xffff;
+		/* End Gamma Correction */
+		status = XAllocColor(dpy, cmap, &XPalette[i]);
+		if (status == 0) {
+		    XPalette[i].flags = 0;
+		    m++;
+		}
+		else
+		    XPalette[i].flags = DoRed|DoGreen|DoBlue;
+		i++;
+	    }
+	}
+    }
+    PaletteSize = nr * ng * nb;
+    if (m > 0) {
+	for (i = 0; i < PaletteSize; i++) {
+	    if (XPalette[i].flags != 0)
+		XFreeColors(dpy, cmap, &(XPalette[i].pixel), 1, 0);
+	}
+	PaletteSize = 0;
+	return 0;
+    }
+    else
+	return 1;
+}
+
+static void SetupPseudoColor()
+{
+    int i, size;
+    PaletteSize = 0;
+    if (model == PSEUDOCOLOR1) {
+	for (i = 0; i < NRGBlevels; i++) {
+	    size = RGBlevels[i][0] * RGBlevels[i][1] * RGBlevels[i][2];
+	    if (size < maxcubesize && GetColorPalette(display, colormap,
+				RGBlevels[i][0],
+				RGBlevels[i][1],
+				RGBlevels[i][2]))
+		break;
+	}
+	if (PaletteSize == 0) {
+	    warning("X11 driver unable to obtain color cube\n  reverting to monochrome");
+	    model = MONOCHROME;
+	    SetupMonochrome();
+	}
+    }
+    else {
+	PaletteSize = 0;
+    }
+}
+
+static unsigned int GetPseudoColor1Pixel(int r, int g, int b)
+{
+    unsigned int d, dmin = 0xFFFFFFFF;
+    unsigned int dr, dg, db;
+    unsigned int pixel;
+    int i;
+    pixel = 0;			/* -Wall */
+    for (i = 0; i < PaletteSize; i++) {
+	dr = (RPalette[i].red - r);
+	dg = (RPalette[i].green - g);
+	db = (RPalette[i].blue - b);
+	d = dr * dr + dg * dg + db * db;
+	if (d < dmin) {
+	    pixel = XPalette[i].pixel;
+	    dmin = d;
+	}
+    }
+    return pixel;
+}
+
+static unsigned int GetPseudoColor2Pixel(int r, int g, int b)
+{
+    int i;
+    /* Search for previously allocated color */
+    for (i = 0; i < PaletteSize ; i++) {
+	if (r == RPalette[i].red &&
+	    g == RPalette[i].green &&
+	    b == RPalette[i].blue) return XPalette[i].pixel;
+    }
+    /* Attempt to allocate a new color */
+    XPalette[PaletteSize].red	= pow(r / 255.0, RedGamma) * 0xffff;
+    XPalette[PaletteSize].green = pow(g / 255.0, GreenGamma) * 0xffff;
+    XPalette[PaletteSize].blue	= pow(b / 255.0, BlueGamma) * 0xffff;
+    if (PaletteSize == 256 ||
+	XAllocColor(display, colormap, &XPalette[PaletteSize]) == 0) {
+	error("Error: X11 cannot allocate additional graphics colors.\n"
+	      "Consider using X11 with colortype=\"pseudo.cube\" or \"gray\".");
+    }
+    RPalette[PaletteSize].red = r;
+    RPalette[PaletteSize].green = g;
+    RPalette[PaletteSize].blue = b;
+    PaletteSize++;
+    return XPalette[PaletteSize - 1].pixel;
+}
+
+static unsigned int GetPseudoColorPixel(int r, int g, int b)
+{
+    if (model == PSEUDOCOLOR1)
+	return GetPseudoColor1Pixel(r, g, b);
+    else
+	return GetPseudoColor2Pixel(r, g, b);
+}
+
+/* Truecolor Displays : Allocate the colors as they are requested */
+
+static unsigned int RMask, RShift;
+static unsigned int GMask, GShift;
+static unsigned int BMask, BShift;
+
+static void SetupTrueColor()
+{
+    RMask = visual->red_mask;
+    GMask = visual->green_mask;
+    BMask = visual->blue_mask;
+    RShift = 0; while ((RMask & 1) == 0) { RShift++; RMask >>= 1; }
+    GShift = 0; while ((GMask & 1) == 0) { GShift++; GMask >>= 1; }
+    BShift = 0; while ((BMask & 1) == 0) { BShift++; BMask >>= 1; }
+}
+
+static unsigned GetTrueColorPixel(int r, int g, int b)
+{
+    r = pow((r / 255.0), RedGamma) * 255;
+    g = pow((g / 255.0), GreenGamma) * 255;
+    b = pow((b / 255.0), BlueGamma) * 255;
+    return
+	(((r * RMask) / 255) << RShift) |
+	(((g * GMask) / 255) << GShift) |
+	(((b * BMask) / 255) << BShift);
+}
+
+/* Interface for General Visual */
+
+static unsigned int GetX11Pixel(int r, int g, int b)
+{
+    switch(model) {
+    case MONOCHROME:
+	return GetMonochromePixel(r, g, b);
+    case GRAYSCALE:
+	return GetGrayScalePixel(r, g, b);
+    case PSEUDOCOLOR1:
+    case PSEUDOCOLOR2:
+	return GetPseudoColorPixel(r, g, b);
+    case TRUECOLOR:
+	return GetTrueColorPixel(r, g, b);
+    default:
+	printf("Unknown Visual\n");
+    }
+    return 0;
+}
+
+static void FreeX11Colors()
+{
+    int i;
+    if (model == PSEUDOCOLOR2) {
+	for (i = 0; i < PaletteSize; i++)
+	    XFreeColors(display, colormap, &(XPalette[i].pixel), 1, 0);
+	PaletteSize = 0;
+    }
+}
+
+static Rboolean SetupX11Color()
+{
+    if (depth <= 1) {
+	/* On monchome displays we must use black/white */
+	model = MONOCHROME;
+	SetupMonochrome();
+    }
+    else if (Vclass ==	StaticGray || Vclass == GrayScale) {
+	if (model == MONOCHROME)
+	    SetupMonochrome();
+	else {
+	    model = GRAYSCALE;
+	    SetupGrayScale();
+	}
+    }
+    else if (Vclass == StaticColor) {
+	/* FIXME : Currently revert to mono. */
+	/* Should do the real thing. */
+	model = MONOCHROME;
+	SetupMonochrome();
+    }
+    else if (Vclass ==	PseudoColor) {
+	if (model == MONOCHROME)
+	    SetupMonochrome();
+	else if (model == GRAYSCALE)
+	    SetupGrayScale();
+	else {
+	    if (model == TRUECOLOR)
+		model = PSEUDOCOLOR2;
+	    SetupPseudoColor();
+	}
+    }
+    else if (Vclass == TrueColor) {
+	if (model == MONOCHROME)
+	    SetupMonochrome();
+	else if (model == GRAYSCALE)
+	    SetupGrayScale();
+	else if (model == PSEUDOCOLOR1 || model == PSEUDOCOLOR2)
+	    SetupPseudoColor();
+	else
+	    SetupTrueColor();
+    }
+    else if (Vclass == DirectColor) {
+	/* FIXME : Currently revert to mono. */
+	/* Should do the real thing. */
+	model = MONOCHROME;
+	SetupMonochrome();
+    }
+    else {
+	printf("Unknown Visual\n");
+	return FALSE;
+    }
+    return TRUE;
+}
+
+	/* Pixel Dimensions (Inches) */
+
+
+static double pixelWidth(void)
+{
+    double width, widthMM;
+    width = DisplayWidth(display, screen);
+    widthMM = DisplayWidthMM(display, screen);
+    return ((double)widthMM / (double)width) / MM_PER_INCH;
+}
+
+static double pixelHeight(void)
+{
+    double height, heightMM;
+    height = DisplayHeight(display, screen);
+    heightMM = DisplayHeightMM(display, screen);
+    return ((double)heightMM / (double)height) / MM_PER_INCH;
+}
+
+static void handleEvent(XEvent event)
+{
+    caddr_t temp;
+    NewDevDesc *dd = NULL;	/* -Wall */
+    newX11Desc *xd;
+    int devNum = 0;
+    int do_update = 0;
+
+    if (event.xany.type == Expose) {
+	while(XCheckTypedEvent(display, Expose, &event))
+	    ;
+	XFindContext(display, event.xexpose.window,
+		     devPtrContext, &temp);
+	dd = (NewDevDesc *) temp;
+	if (event.xexpose.count == 0)
+	    do_update = 1;
+    }
+    else if (event.type == ConfigureNotify) {
+	while(XCheckTypedEvent(display, ConfigureNotify, &event))
+	    ;
+	XFindContext(display, event.xconfigure.window,
+		     devPtrContext, &temp);
+	dd = (NewDevDesc *) temp;
+	xd = (newX11Desc *) dd->deviceSpecific;
+	if (xd->windowWidth != event.xconfigure.width ||
+	    xd->windowHeight != event.xconfigure.height)
+	    do_update = 1;
+	xd->windowWidth = event.xconfigure.width;
+	xd->windowHeight = event.xconfigure.height;
+        dd->size(&(dd->left), &(dd->right), &(dd->bottom), &(dd->top),
+		     dd);
+
+	if (do_update) /* Gobble Expose events; we'll redraw anyway */
+	    while(XCheckTypedEvent(display, Expose, &event))
+		;
+    }
+    else if ((event.type == ClientMessage) &&
+	     (event.xclient.message_type == _XA_WM_PROTOCOLS))
+	if (!inclose && event.xclient.data.l[0] == protocol) {
+	    XFindContext(display, event.xclient.window,
+			 devPtrContext, &temp);
+	    dd = (NewDevDesc *) temp;
+	    KillDevice((DevDesc*) GetDevice(devNumber((DevDesc*) dd)));
+	}
+
+    if (do_update) {
+	/* It appears possible that a device may receive an expose
+	 * event in the middle of the device being "kill"ed by R
+	 * This means that R knows nothing about the device
+	 * so devNumber becomes 0 (the null device) and it is not
+	 * a good idea to pass the null device to GEplayDisplayList
+	 */
+	devNum = devNumber((DevDesc*) dd);
+	if (devNum > 0)
+	    GEplayDisplayList((GEDevDesc*) GetDevice(devNum));
+    }
+}
+
+static void R_ProcessEvents(void *data)
+{
+    XEvent event;
+
+    while (displayOpen && XPending(display)) {
+	XNextEvent(display, &event);
+	/* printf("%i\n",event.type); */
+	handleEvent(event);
+    }
+}
+
+static char *fontname = "-adobe-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*";
+static char *symbolname  = "-adobe-symbol-*-*-*-*-%d-*-*-*-*-*-*-*";
+
+static XrmDatabase xrmdb;
+
+/* Bitmap of the Adobe design sizes */
+
+static unsigned int adobe_sizes = 0x0403165D;
+
+#define MAXFONTS 64
+#define CLRFONTS 16 /* Number to free when cache runs full */
+
+typedef struct {int face, size;	 void *font;} cacheentry;
+
+static cacheentry fontcache[MAXFONTS];
+static int nfonts = 0;
+static int force_nonscalable = 0; /* for testing */
+
+#define ADOBE_SIZE(I) ((I) > 7 && (I) < 35 && (adobe_sizes & (1<<((I)-8))))
+#define SMALLEST 2
+
+static XFontSet XLoadQueryFontSet(Display *display,
+                                  const char *fontset_name)
+{
+  XFontSet fontset;
+  int  missing_charset_count;
+  char **missing_charset_list;
+  char *def_string;
+  
+  fontset = XCreateFontSet(display,
+                           fontset_name,
+                           &missing_charset_list,
+                           &missing_charset_count,
+                           &def_string);
+  if (missing_charset_count) {
+    Rprintf("Missing charsets in FontSet(%s) creation.\n", fontset_name);
+    XFreeStringList(missing_charset_list);
+  }
+  return fontset;
+}
+
+static void *RLoadFont(newX11Desc *xd, int face, int size)
+{
+    int pixelsize, i;
+    cacheentry *f;
+    char buf[BUFSIZ];
+    XFontStruct *tmp;
+
+    if (size < SMALLEST) size = SMALLEST;
+    face--;
+
+    /* Here's a 1st class fudge: make sure that the Adobe design sizes
+       8, 10, 11, 12, 14, 17, 18, 20, 24, 25, 34 can be obtained via
+       an integer "size" at 100 dpi, namely 6, 7, 8, 9, 10, 12, 13,
+       14, 17, 18, 24 points. It's almost y = x * 100/72, but not
+       quite. The constants were found using lm(). --pd */
+    if (IS_100DPI) size = R_rint(size * 1.43 - 0.4);
+
+    /* search fontcache */
+    for ( i = nfonts ; i-- ; ) {
+	f = &fontcache[i];
+	if ( f->face == face && f->size == size ) return f->font;
+    }
+
+    /* 'size' is the requested size, 'pixelsize'  the size of the
+       actually allocated font*/
+    pixelsize = size;
+
+    GetFontResource(xrmdb, buf, sizeof(buf), face+1, pixelsize);
+#ifdef DEBUG_X11
+    Rprintf("loading:\n%s\n",buf);
+#endif
+    if (face == SYMBOL_FONTFACE - 1){
+      tmp = (void *)XLoadQueryFont(display, buf);
+    }else{
+      tmp = (void *)XLoadQueryFontSet(display, buf);
+    }
+#ifdef DEBUG_X11
+    if (tmp) Rprintf("success\n"); else Rprintf("failure\n");
+#endif
+    if (!tmp || (force_nonscalable && !ADOBE_SIZE(size)) ){
+	static int near[]=
+	  {14,14,14,17,17,18,20,20,20,20,24,24,24,25,25,25,25};
+	/* 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  */
+
+	/* If ADOBE_SIZE(pixelsize) is true at this point then
+	   the user's system does not have the standard ADOBE font set
+	   so we just have to use a "fixed" font.
+	   If we can't find a "fixed" font then something is seriously
+	   wrong */
+	if ( ADOBE_SIZE(pixelsize) ) {
+            tmp = (void *)XLoadQueryFontSet(display,
+                                            "-*-fixed-medium-r-*--13-*-*-*-*-*-*-*");
+	    if (tmp)
+		return tmp;
+	    else
+		error("Could not find any X11 fonts\nCheck that the Font Path is correct.");
+	}
+
+	if ( pixelsize < 8 )
+	    pixelsize = 8;
+	else if (pixelsize == 9)
+	    pixelsize = 8;
+	else if (pixelsize < 30) /* must be at least 13 */
+	    pixelsize = near[size-13];
+	else
+	    pixelsize = 34;
+
+
+        GetFontResource(xrmdb, buf,sizeof(buf), face+1, pixelsize);
+#ifdef DEBUG_X11
+	Rprintf("loading:\n%s\n",buf);
+#endif
+        if (face == SYMBOL_FONTFACE - 1)
+          tmp = (void *)XLoadQueryFont(display, buf);
+        else
+          tmp = (void *)XLoadQueryFontSet(display, buf);
+#ifdef DEBUG_X11
+	if (tmp) Rprintf("success\n"); else Rprintf("failure\n");
+#endif
+    }
+    if(!tmp && size > 24) {
+	/* final try, size 24 */
+	pixelsize = 24;
+        GetFontResource(xrmdb, buf, sizeof(buf),face+1, pixelsize);
+#ifdef DEBUG_X11
+	Rprintf("loading:\n%s\n",buf);
+#endif
+        if (face == SYMBOL_FONTFACE - 1){
+          tmp = (void *)XLoadQueryFont(display, buf);
+        }else{
+          tmp = (void *)XLoadQueryFontSet(display, buf);
+        }
+#ifdef DEBUG_X11
+	if (tmp) Rprintf("success\n"); else Rprintf("failure\n");
+#endif
+    }
+
+
+    if (tmp){
+	f = &fontcache[nfonts++];
+	f->face = face;
+	f->size = size;
+	f->font = tmp;
+	if (fabs( (pixelsize - size)/(double)size ) > 0.1)
+	    warning("X11 used font size %d when %d was requested",
+		    pixelsize, size);
+    }
+    if (nfonts == MAXFONTS) /* make room in the font cache */
+    {
+        for (i = 0 ; i < CLRFONTS ; i++)
+	  if (fontcache[i].face == SYMBOL_FONTFACE -1){
+	    XFreeFont(display, (XFontStruct *)(fontcache[i].font));
+	  }else{
+	    XFreeFontSet(display, (XFontSet)(fontcache[i].font));
+	  }
+      
+	for (i = CLRFONTS ; i < MAXFONTS ; i++)
+	    fontcache[i - CLRFONTS] = fontcache[i];
+	nfonts -= CLRFONTS;
+    }
+    return tmp;
+}
+
+static int SetBaseFont(newX11Desc *xd)
+{
+    xd->fontface = xd->basefontface;
+    xd->fontsize = xd->basefontsize;
+    xd->usefixed = 0;
+    xd->font = RLoadFont(xd, xd->fontface, xd->fontsize);
+    if (!xd->font) {
+	xd->usefixed = 1;
+	xd->font = xd->fixedfont = (void *)XLoadQueryFontSet(display,
+							     "-*-fixed-medium-r-*--13-*-*-*-*-*-*-*");
+	if (!xd->fixedfont)
+	    return 0;
+    }
+    return 1;
+}
+
+static void SetFont(int face, int size, NewDevDesc *dd)
+{
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+    void *tmp;
+    XGCValues gcv;
+    XGetGCValues(display, xd->wgc , GCFont, &gcv);
+
+    if (face < 1 || face > 5) face = 1;
+
+    if (!xd->usefixed && (size != xd->fontsize	|| face != xd->fontface)) {
+	tmp = RLoadFont(xd, face, size);
+	if(tmp) {
+	    xd->font = tmp;
+	    xd->fontface = face;
+	    xd->fontsize = size;
+            if (face == SYMBOL_FONTFACE)
+              XSetFont(display, xd->wgc, ((XFontStruct *)(xd->font))->fid);
+            else
+              XSetFontSet(display, xd->wgc, (XFontSet)(xd->font));
+	} else
+	    error("X11 font at size %d could not be loaded", size);
+    }
+}
+
+
+static void SetColor(int color, NewDevDesc *dd)
+{
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+    if (color != xd->col) {
+	blackpixel = GetX11Pixel(R_RED(color), R_GREEN(color), R_BLUE(color));
+	xd->col = color;
+	XSetState(display, xd->wgc, blackpixel, whitepixel, GXcopy, AllPlanes);
+    }
+}
+
+/* --> See "Notes on Line Textures" in ../../include/Rgraphics.h
+ *
+ *	27/5/98 Paul - change to allow lty and lwd to interact:
+ *	the line texture is now scaled by the line width so that,
+ *	for example, a wide (lwd=2) dotted line (lty=2) has bigger
+ *	dots which are more widely spaced.  Previously, such a line
+ *	would have "dots" which were wide, but not long, nor widely
+ *	spaced.
+ */
+static void SetLinetype(int newlty, double nlwd, NewDevDesc *dd)
+{
+    static char dashlist[8];
+    int i, newlwd;
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    newlwd = nlwd;/*cast*/
+    if (newlwd < 1)/* not less than 1 pixel */
+	newlwd = 1;
+    if (newlty != xd->lty || newlwd != xd->lwd) {
+	xd->lty = newlty;
+	xd->lwd = newlwd;
+	if (newlty == 0) {/* special hack for lty = 0 -- only for X11 */
+	    XSetLineAttributes(display,
+			       xd->wgc,
+			       newlwd,
+			       LineSolid,
+			       CapRound,
+			       JoinRound);
+	}
+	else {
+	    for(i = 0 ; i < 8 && (newlty != 0); i++) {
+		int j = newlty & 15;
+		if (j == 0) j = 1; /* Or we die with an X Error */
+		/* scale line texture for line width */
+		j = j*newlwd;
+		/* make sure that scaled line texture */
+		/* does not exceed X11 storage limits */
+		if (j > 255) j=255;
+		dashlist[i] = j;
+		newlty = newlty >> 4;
+	    }
+	    /* NB if i is odd the pattern will be interpreted as
+	       the original pattern concatenated with itself */
+	    XSetDashes(display, xd->wgc, 0, dashlist, i);
+	    XSetLineAttributes(display,
+			       xd->wgc,
+			       newlwd,
+			       LineOnOffDash,
+			       CapButt,
+			       JoinRound);
+	}
+    }
+}
+
+static int R_X11Err(Display *dsp, XErrorEvent *event)
+{
+    char buff[1000];
+    XGetErrorText(dsp, event->error_code, buff, 1000);
+    warning("X11 protocol error: %s", buff);
+    return 0;
+}
+
+static int R_X11IOErr(Display *dsp)
+{
+    int fd = ConnectionNumber(display);
+    /*
+    while (nfonts--)  XFreeFont(display, fontcache[nfonts].font);
+    nfonts = 0;
+    */
+    removeInputHandler(&R_InputHandlers,
+		       getInputHandler(R_InputHandlers,fd));
+    /*
+    XCloseDisplay(display);
+    displayOpen = FALSE;
+    */
+    error("X11 fatal IO error: please save work and shut down R");
+    return 0; /* but should never get here */
+}
+
+
+Rboolean
+newX11_Open(NewDevDesc *dd, newX11Desc *xd, char *dsp, double w, double h,
+	 double gamma_fac, X_COLORTYPE colormodel, int maxcube,
+	 int canvascolor)
+{
+    /* if we have to bail out with "error", then must free(dd) and free(xd) */
+    /* That means the *caller*: the X11DeviceDriver code frees xd, for example */
+
+    XEvent event;
+    int iw, ih;
+    X_GTYPE type;
+    char *p = dsp;
+    XGCValues gcv;
+    /* Indicates whether the display is created within this particular call: */
+    Rboolean DisplayOpened = FALSE;
+
+    XrmInitialize();
+
+    if (!XSupportsLocale ()) {
+        Rprintf("locale not supported by Xlib, locale set to C\n");
+        setlocale (LC_ALL, "C");
+    }
+
+    if (!XSetLocaleModifiers ("")) {
+        Rprintf("can not set locale modifiers\n");
+    }
+
+    if (!strncmp(dsp, "png::", 5)) {
+	char buf[PATH_MAX]; /* allow for pageno formats */
+	FILE *fp;
+#ifndef HAVE_PNG
+	warning("No png support in this version of R");
+	return FALSE;
+#else
+	if(strlen(dsp+5) >= PATH_MAX) error("filename too long in png() call");
+	strcpy(xd->filename, dsp+5);
+	snprintf(buf, PATH_MAX, dsp+5, 1); /* page 1 to start */
+	if (!(fp = R_fopen(R_ExpandFileName(buf), "w"))) {
+	    warning("could not open PNG file `%s'", buf);
+	    return FALSE;
+	}
+	xd->fp = fp;
+	type = PNG;
+	p = "";
+#endif
+    }
+    else if (!strncmp(dsp, "jpeg::", 6)) {
+	char buf[PATH_MAX]; /* allow for pageno formats */
+	FILE *fp;
+#ifndef HAVE_JPEG
+	warning("No jpeg support in this version of R");
+	return FALSE;
+#else
+	p = strchr(dsp+6, ':'); *p='\0';
+	xd->quality = atoi(dsp+6);
+	if(strlen(p+1) >= PATH_MAX) error("filename too long in jpeg() call");
+	strcpy(xd->filename, p+1);
+	snprintf(buf, PATH_MAX, p+1, 1); /* page 1 to start */
+	if (!(fp = R_fopen(R_ExpandFileName(buf), "w"))) {
+	    warning("could not open JPEG file `%s'", buf);
+	    return FALSE;
+	}
+	xd->fp = fp;
+	type = JPEG;
+	p = "";
+#endif
+    } else if (!strcmp(dsp, "XImage")) {
+	type = XIMAGE;
+	xd->fp = NULL;
+	p = "";
+    }
+    else type = WINDOW;
+    xd->type = type;
+
+    /* If there is no server connection, establish one and */
+    /* initialize the X11 device driver data structures. */
+
+    if (!displayOpen) {
+	if ((display = XOpenDisplay(p)) == NULL) {
+	    warning("unable to open connection to X11 display`%s'", p);
+	    return FALSE;
+	}
+	DisplayOpened = TRUE;
+	Rf_setX11Display(display, gamma_fac, colormodel, maxcube, TRUE);
+	displayOpen = TRUE;
+	if(xd->handleOwnEvents == FALSE)
+	    addInputHandler(R_InputHandlers, ConnectionNumber(display),
+			    R_ProcessEvents, XActivity);
+        xrmdb = CreateDB(display);
+    }
+    /* whitepixel = GetX11Pixel(255, 255, 255); */
+    whitepixel = GetX11Pixel(R_RED(canvascolor), R_GREEN(canvascolor),
+			     R_BLUE(canvascolor));
+    blackpixel = GetX11Pixel(0, 0, 0);
+
+    if (!SetBaseFont(xd)) {
+	Rprintf("can't find X11 font\n");
+	return FALSE;
+    }
+
+    /* Foreground and Background Colors */
+
+    xd->fill = 0xffffffff; /* transparent, was R_RGB(255, 255, 255); */
+    xd->col = R_RGB(0, 0, 0);
+    xd->canvas = canvascolor;
+    if(type == JPEG && !R_OPAQUE(xd->canvas)) {
+	warning("jpeg() does not support transparency: using white bg");
+	xd->canvas = 0xffffff;
+    }
+    if(type > WINDOW) xd->fill = xd->canvas;
+
+
+    /* Try to create a simple window. */
+    /* We want to know about exposures */
+    /* and window-resizes and locations. */
+
+    attributes.background_pixel = whitepixel;
+    attributes.border_pixel = blackpixel;
+    attributes.backing_store = Always;
+    attributes.event_mask = ButtonPressMask
+	| ExposureMask
+	| StructureNotifyMask;
+
+
+    if (type == WINDOW) {
+	int alreadyCreated = (xd->window != (Window)NULL);
+	if(alreadyCreated == 0) {
+	    xd->windowWidth = iw = w/pixelWidth();
+	    xd->windowHeight = ih = h/pixelHeight();
+	    if ((xd->window = XCreateWindow(
+		display, rootwin,
+		DisplayWidth(display, screen) - iw - 10, 10, iw, ih, 1,
+		DefaultDepth(display, screen),
+		InputOutput,
+		DefaultVisual(display, screen),
+		CWEventMask | CWBackPixel | CWBorderPixel | CWBackingStore,
+		&attributes)) == 0) {
+		warning("unable to create X11 window");
+		return FALSE;
+	    }
+
+	    XChangeProperty(display, xd->window, XA_WM_NAME, XA_STRING,
+			    8, PropModeReplace,
+			    (unsigned char*)"R Graphics", 13);
+
+	    xd->gcursor = XCreateFontCursor(display, CURSOR);
+	    XDefineCursor(display, xd->window, xd->gcursor);
+
+	    /* set up protocols so that window manager sends */
+	    /* me an event when user "destroys" window */
+	    _XA_WM_PROTOCOLS = XInternAtom(display, "WM_PROTOCOLS", 0);
+	    protocol = XInternAtom(display, "WM_DELETE_WINDOW", 0);
+	    XSetWMProtocols(display, xd->window, &protocol, 1);
+
+	}
+	/* Save the NewDevDesc* with the window for event dispatching */
+	XSaveContext(display, xd->window, devPtrContext, (caddr_t) dd);
+
+	/* Map the window */
+	if(alreadyCreated == 0) {
+	    XSelectInput(display, xd->window,
+			 ExposureMask | ButtonPressMask | StructureNotifyMask);
+	    XMapWindow(display, xd->window);
+	    XSync(display, 0);
+
+	    /* Gobble expose events */
+
+	    while ( XPeekEvent(display, &event),
+		    !XCheckTypedEvent(display, Expose, &event))
+                ;
+	    /* XNextEvent(display, &event);
+	       if (event.xany.type == Expose) {
+	       while (event.xexpose.count)
+	       XNextEvent(display, &event);
+	       }
+	    */
+	}
+    } else { /* PIXMAP */
+	xd->windowWidth = iw = w;
+	xd->windowHeight = ih = h;
+	if ((xd->window = XCreatePixmap(
+	    display, rootwin,
+	    iw, ih, DefaultDepth(display, screen))) == 0) {
+	    warning("unable to create pixmap");
+	    return FALSE;
+	}
+	/* Save the NewDevDesc* with the window for event dispatching */
+	/* Is this needed? */
+	XSaveContext(display, xd->window, devPtrContext, (caddr_t) dd);
+	xd->npages = 0;
+    }
+
+    /* Set the graphics context */
+
+    gcv.arc_mode = ArcChord;
+    xd->wgc = XCreateGC(display, xd->window, GCArcMode, &gcv);
+    XSetState(display, xd->wgc, blackpixel, whitepixel, GXcopy, AllPlanes);
+    if ( xd->fontface == SYMBOL_FONTFACE )
+      XSetFont(display, xd->wgc, ((XFontStruct*)(xd->font))->fid);
+    else
+      XSetFontSet(display, xd->wgc, (XFontSet)(xd->font));
+
+    /* ensure that line drawing is set up at the first */
+    /* graphics call */
+    xd->lty = -1;
+    xd->lwd = -1;
+
+
+    numX11Devices++;
+    return TRUE;
+}
+
+static double newX11_StrWidth(char *str,
+			      R_GE_gcontext *gc,
+			      NewDevDesc *dd)
+{
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    int size = gc->cex * gc->ps + 0.5;
+    SetFont(gc->fontface, size, dd);
+    if (xd->fontface == SYMBOL_FONTFACE)
+      return (double)XTextWidth((XFontStruct*)(xd->font), str, strlen(str));
+    else
+      return (double)XRfTextEscapement((XFontSet)(xd->font), str, strlen(str));
+}
+
+
+	/* Character Metric Information */
+	/* Passing c == 0 gets font information */
+
+static void newX11_MetricInfo(int c,
+			      R_GE_gcontext *gc,
+			      double* ascent, double* descent,
+			      double* width, NewDevDesc *dd)
+{
+    int first, last;
+    int size = gc->cex * gc->ps + 0.5;
+    XFontSetExtents *extent;
+    char buf[2];
+    char **ml;
+    XFontStruct *fontstruct;
+    int i;
+
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+    buf[0]= c;
+    buf[1]= 0;
+
+    SetFont(gc->fontface, size, dd);
+    if (xd->fontface != SYMBOL_FONTFACE){
+      extent = XExtentsOfFontSet((XFontSet)(xd->font));
+    }
+    if (xd->font) {
+      if (xd->fontface != SYMBOL_FONTFACE){
+        XFontStruct **fs_list;
+        XFontsOfFontSet((XFontSet)(xd->font), &fs_list, &ml);
+        fontstruct = fs_list[0];
+        first = fontstruct->min_char_or_byte2;
+        last = fontstruct->max_char_or_byte2;
+      }else{
+        fontstruct = (XFontStruct*)(xd->font);
+        first = fontstruct->min_char_or_byte2;
+        last = fontstruct->max_char_or_byte2;
+      }
+    } else {
+      fontstruct = NULL;
+    }
+
+    if (fontstruct != NULL && c == 0) {
+        *ascent = fontstruct->ascent;
+        *descent = fontstruct->descent;
+        *width = fontstruct->max_bounds.width;
+    }
+    else if (fontstruct != NULL && first <= c && c <= last) {
+      if (xd->fontface != SYMBOL_FONTFACE){
+        *ascent = extent->max_logical_extent.height * 4 / 5;
+        *descent = extent->max_logical_extent.height / 5;
+        *width = XRfTextEscapement((XFontSet)(xd->font), buf, strlen(buf));
+      }else{
+        *ascent = fontstruct->per_char[c-first].ascent;
+        *descent = fontstruct->per_char[c-first].descent;
+        *width = fontstruct->per_char[c-first].width;
+      }
+    }
+    else {
+      *ascent = 0;
+      *descent = 0;
+      *width = 0;
+    }
+}
+
+static void newX11_Clip(double x0, double x1, double y0, double y1,
+			NewDevDesc *dd)
+{
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    if (x0 < x1) {
+	xd->clip.x = (int) x0 ;
+	xd->clip.width = (int) x1 - (int) x0 + 1;
+    }
+    else {
+	xd->clip.x = (int) x1;
+	xd->clip.width = (int) x0 - (int) x1 + 1;
+    }
+
+    if (y0 < y1) {
+	xd->clip.y = (int) y0;
+	xd->clip.height = (int) y1 -  (int) y0 + 1;
+    }
+    else {
+	xd->clip.y = (int) y1;
+	xd->clip.height = (int) y0 - (int) y1 + 1;
+    }
+
+    XSetClipRectangles(display, xd->wgc, 0, 0, &(xd->clip), 1, Unsorted);
+#ifdef XSYNC
+    if (xd->type == WINDOW) XSync(display, 0);
+#endif
+}
+
+static void newX11_Size(double *left, double *right,
+		     double *bottom, double *top,
+		     NewDevDesc *dd)
+{
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    *left = 0.0;
+    *right = xd->windowWidth;
+    *bottom = xd->windowHeight;
+    *top = 0.0;
+}
+
+static void newX11_NewPage(R_GE_gcontext *gc, NewDevDesc *dd)
+{
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    if (xd->type > WINDOW) {
+	if (xd->npages++) {
+	    /* try to preserve the page we do have */
+	    if (xd->type != XIMAGE) X11_Close_bitmap(xd);
+	    if (xd->type != XIMAGE && xd->fp != NULL) fclose(xd->fp);
+	    if (xd->type == PNG) {
+		char buf[PATH_MAX];
+		snprintf(buf, PATH_MAX, xd->filename, xd->npages);
+		xd->fp = R_fopen(R_ExpandFileName(buf), "w");
+		if (!xd->fp)
+		    error("could not open PNG file `%s'", buf);
+	    }
+	    if (xd->type == JPEG) {
+		char buf[PATH_MAX];
+		snprintf(buf, PATH_MAX, xd->filename, xd->npages);
+		xd->fp = R_fopen(R_ExpandFileName(buf), "w");
+		if (!xd->fp)
+		    error("could not open JPEG file `%s'", buf);
+	    }
+	    /* error("attempt to draw second page on pixmap device");*/
+	}
+/* we want to override the default bg="transparent" */
+/*	xd->fill = R_OPAQUE(dd->bg) ? dd->bg : xd->canvas; */
+	xd->fill = R_OPAQUE(gc->fill) ? gc->fill: PNG_TRANS;
+	SetColor(xd->fill, dd);
+	XFillRectangle(display, xd->window, xd->wgc, 0, 0,
+		       xd->windowWidth, xd->windowHeight);
+	return;
+    }
+
+    FreeX11Colors();
+    if ( (model == PSEUDOCOLOR2) || (xd->fill != gc->fill)) {
+	xd->fill = R_OPAQUE(gc->fill) ? gc->fill : xd->canvas;
+	whitepixel = GetX11Pixel(R_RED(xd->fill),R_GREEN(xd->fill),R_BLUE(xd->fill));
+	XSetWindowBackground(display, xd->window, whitepixel);
+    }
+    XClearWindow(display, xd->window);
+#ifdef XSYNC
+    XSync(display, 0);
+#endif
+}
+
+extern int R_SaveAsPng(void  *d, int width, int height,
+		       unsigned long (*gp)(XImage *, int, int),
+		       int bgr, FILE *fp, unsigned int transparent);
+
+extern int R_SaveAsJpeg(void  *d, int width, int height,
+			unsigned long (*gp)(XImage *, int, int),
+			int bgr, int quality, FILE *outfile);
+
+
+static long knowncols[512];
+
+
+static unsigned long bitgp(XImage *xi, int x, int y)
+{
+    int i, r, g, b;
+    XColor xcol;
+    /*	returns the colour of the (x,y) pixel stored as RGB */
+    i = XGetPixel(xi, y, x);
+    switch(model) {
+    case MONOCHROME:
+	return (i==0)?0xFFFFFF:0;
+    case GRAYSCALE:
+    case PSEUDOCOLOR1:
+    case PSEUDOCOLOR2:
+	if (i < 512) {
+	    if (knowncols[i] < 0) {
+		xcol.pixel = i;
+		XQueryColor(display, colormap, &xcol);
+		knowncols[i] = ((xcol.red>>8)<<16) | ((xcol.green>>8)<<8)
+		    | (xcol.blue>>8);
+	    }
+	    return knowncols[i];
+	}
+	else {
+	    xcol.pixel = i;
+	    XQueryColor(display, colormap, &xcol);
+	    return ((xcol.red>>8)<<16) | ((xcol.green>>8)<<8) | (xcol.blue>>8);
+	}
+    case TRUECOLOR:
+	r = ((i>>RShift)&RMask) * 255 /(RMask);
+	g = ((i>>GShift)&GMask) * 255 /(GMask);
+	b = ((i>>BShift)&BMask) * 255 /(BMask);
+	return (r<<16) | (g<<8) | b;
+    default:
+	return 0;
+    }
+    return 0; /* not reached, needed for some compilers */
+}
+
+static void X11_Close_bitmap(newX11Desc *xd)
+{
+    int i;
+    XImage *xi;
+    for (i = 0; i < 512; i++) knowncols[i] = -1;
+    xi = XGetImage(display, xd->window, 0, 0,
+		   xd->windowWidth, xd->windowHeight,
+		   AllPlanes, ZPixmap);
+    if (xd->type == PNG) {
+	unsigned int pngtrans = PNG_TRANS;
+	if(model == TRUECOLOR) {
+	    int i, r, g, b;
+	    /* some `truecolor' displays distort colours */
+	    i = GetX11Pixel(R_RED(PNG_TRANS),
+			    R_GREEN(PNG_TRANS),
+			    R_BLUE(PNG_TRANS));
+	    r = ((i>>RShift)&RMask) * 255 /(RMask);
+	    g = ((i>>GShift)&GMask) * 255 /(GMask);
+	    b = ((i>>BShift)&BMask) * 255 /(BMask);
+	    pngtrans = (r<<16) | (g<<8) | b;
+	}
+	R_SaveAsPng(xi, xd->windowWidth, xd->windowHeight,
+		    bitgp, 0, xd->fp,
+		    (xd->fill != PNG_TRANS) ? 0 : pngtrans);
+    } else if (xd->type == JPEG)
+	R_SaveAsJpeg(xi, xd->windowWidth, xd->windowHeight,
+		     bitgp, 0, xd->quality, xd->fp);
+    XDestroyImage(xi);
+}
+
+static void newX11_Close(NewDevDesc *dd)
+{
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    if (xd->type == WINDOW) {
+	/* process pending events */
+	/* set block on destroy events */
+	inclose = TRUE;
+	R_ProcessEvents((void*) NULL);
+
+	XFreeCursor(display, xd->gcursor);
+	XDestroyWindow(display, xd->window);
+	XSync(display, 0);
+    } else {
+	if (xd->npages && xd->type != XIMAGE) X11_Close_bitmap(xd);
+	XFreeGC(display, xd->wgc);
+	XFreePixmap(display, xd->window);
+	if (xd->type != XIMAGE && xd->fp != NULL) fclose(xd->fp);
+    }
+
+    numX11Devices--;
+    if (numX11Devices == 0)  {
+      int fd = ConnectionNumber(display);
+	/* Free Resources Here */
+        while (nfonts--){
+          if ( fontcache[nfonts].face == SYMBOL_FONTFACE -1 )
+            XFreeFont(display, (XFontStruct *)(fontcache[nfonts].font));
+          else
+            XFreeFontSet(display, (XFontSet)(fontcache[nfonts].font));
+        }
+	nfonts = 0;
+        if(xd->handleOwnEvents == FALSE)
+	    removeInputHandler(&R_InputHandlers,
+			       getInputHandler(R_InputHandlers,fd));
+	XCloseDisplay(display);
+        XrmDestroyDatabase(xrmdb);
+	displayOpen = FALSE;
+    }
+
+    free(xd);
+    inclose = FALSE;
+}
+
+static char title[11] = "R Graphics";
+
+static void newX11_Activate(NewDevDesc *dd)
+{
+    char t[50];
+    char num[3];
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    if (xd->type > WINDOW) return;
+    strcpy(t, title);
+    strcat(t, ": Device ");
+    sprintf(num, "%i", devNumber((DevDesc*)(dd))+1);
+    strcat(t, num);
+    strcat(t, " (ACTIVE)");
+    XChangeProperty(display, xd->window, XA_WM_NAME, XA_STRING,
+		    8, PropModeReplace, (unsigned char*)t, strlen(t));
+    XSync(display, 0);
+}
+
+static void newX11_Deactivate(NewDevDesc *dd)
+{
+    char t[50];
+    char num[3];
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    if (xd->type > WINDOW) return;
+    strcpy(t, title);
+    strcat(t, ": Device ");
+    sprintf(num, "%i", devNumber((DevDesc*)(dd))+1);
+    strcat(t, num);
+    strcat(t, " (inactive)");
+    XChangeProperty(display, xd->window, XA_WM_NAME, XA_STRING,
+		    8, PropModeReplace, (unsigned char*)t, strlen(t));
+    XSync(display, 0);
+}
+
+static void newX11_Rect(double x0, double y0, double x1, double y1,
+			R_GE_gcontext *gc,
+ 			NewDevDesc *dd)
+{
+    int tmp;
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    if (x0 > x1) {
+	tmp = x0;
+	x0 = x1;
+	x1 = tmp;
+    }
+    if (y0 > y1) {
+	tmp = y0;
+	y0 = y1;
+	y1 = tmp;
+    }
+    if (R_OPAQUE(gc->fill)) {
+       SetColor(gc->fill, dd);
+	XFillRectangle(display, xd->window, xd->wgc, (int)x0, (int)y0,
+		       (int)x1 - (int)x0, (int)y1 - (int)y0);
+    }
+    if (R_OPAQUE(gc->col)) {
+        SetColor(gc->col, dd);
+        SetLinetype(gc->lty, gc->lwd, dd);
+	XDrawRectangle(display, xd->window, xd->wgc, (int)x0, (int)y0,
+		       (int)x1 - (int)x0, (int)y1 - (int)y0);
+    }
+#ifdef XSYNC
+    if (xd->type == WINDOW) XSync(display, 0);
+#endif
+}
+
+static void newX11_Circle(double x, double y, double r,
+			  R_GE_gcontext *gc,
+			  NewDevDesc *dd)
+{
+    int ir, ix, iy;
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    ir = floor(r + 0.5);
+
+    ix = (int)x;
+    iy = (int)y;
+    if (R_OPAQUE(gc->fill)) {
+        SetColor(gc->fill, dd);
+	XFillArc(display, xd->window, xd->wgc,
+		 ix-ir, iy-ir, 2*ir, 2*ir, 0, 23040);
+    }
+    if (R_OPAQUE(gc->col)) {
+        SetLinetype(gc->lty, gc->lwd, dd);
+        SetColor(gc->col, dd);
+	XDrawArc(display, xd->window, xd->wgc,
+		 ix-ir, iy-ir, 2*ir, 2*ir, 0, 23040);
+    }
+}
+
+static void newX11_Line(double x1, double y1, double x2, double y2,
+			R_GE_gcontext *gc,
+			NewDevDesc *dd)
+{
+    int xx1, yy1, xx2, yy2;
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    /* In-place conversion ok */
+
+    xx1 = (int) x1;
+    yy1 = (int) y1;
+    xx2 = (int) x2;
+    yy2 = (int) y2;
+
+    if (R_OPAQUE(gc->col)) {
+        SetColor(gc->col, dd);
+        SetLinetype(gc->lty, gc->lwd, dd);
+	XDrawLine(display, xd->window, xd->wgc, xx1, yy1, xx2, yy2);
+#ifdef XSYNC
+	if (xd->type == WINDOW) XSync(display, 0);
+#endif
+    }
+}
+
+static void newX11_Polyline(int n, double *x, double *y,
+			    R_GE_gcontext *gc,
+			    NewDevDesc *dd)
+{
+    char *vmax = vmaxget();
+    XPoint *points;
+    int i, j;
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    points = (XPoint *) R_alloc(n, sizeof(XPoint));
+
+    for(i=0 ; i<n ; i++) {
+	points[i].x = (int)(x[i]);
+	points[i].y = (int)(y[i]);
+    }
+
+    if (R_OPAQUE(gc->col)) {
+        SetColor(gc->col, dd);
+        SetLinetype(gc->lty, gc->lwd, dd);
+/* Some X servers need npoints < 64K */
+	for(i = 0; i < n; i+= 10000-1) {
+	    j = n - i;
+	    j = (j <= 10000) ? j: 10000; /* allow for overlap */
+	    XDrawLines(display, xd->window, xd->wgc, points+i, j,
+		       CoordModeOrigin);
+	}
+#ifdef XSYNC
+	if (xd->type == WINDOW) XSync(display, 0);
+#endif
+    }
+
+    vmaxset(vmax);
+}
+
+static void newX11_Polygon(int n, double *x, double *y,
+			   R_GE_gcontext *gc,
+			   NewDevDesc *dd)
+{
+    char *vmax = vmaxget();
+    XPoint *points;
+    int i;
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    points = (XPoint *) R_alloc(n+1, sizeof(XPoint));
+
+    for (i=0 ; i<n ; i++) {
+	points[i].x = (int)(x[i]);
+	points[i].y = (int)(y[i]);
+    }
+    points[n].x = (int)(x[0]);
+    points[n].y = (int)(y[0]);
+    if (R_OPAQUE(gc->fill)) {
+        SetColor(gc->fill, dd);
+	XFillPolygon(display, xd->window, xd->wgc, points, n, Complex, CoordModeOrigin);
+#ifdef XSYNC
+	if (xd->type == WINDOW) XSync(display, 0);
+#endif
+    }
+    if (R_OPAQUE(gc->col)) {
+        SetColor(gc->col, dd);
+        SetLinetype(gc->lty, gc->lwd, dd);
+	XDrawLines(display, xd->window, xd->wgc, points, n+1, CoordModeOrigin);
+#ifdef XSYNC
+	if (xd->type == WINDOW) XSync(display, 0);
+#endif
+    }
+
+    vmaxset(vmax);
+}
+
+
+static void newX11_Text(double x, double y,
+			char *str, double rot, double hadj,
+			R_GE_gcontext *gc,
+			NewDevDesc *dd)
+{
+    int len, size;
+/*    double xl, yl, rot1;*/
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+
+    size = gc->cex * gc->ps + 0.5;
+    SetFont(gc->fontface, size, dd);
+    if (R_OPAQUE(gc->col)) {
+        SetColor(gc->col, dd);
+	len = strlen(str);
+	if (xd->fontface == SYMBOL_FONTFACE){
+	  XRotDrawString(display, (XFontStruct *)(xd->font),
+			 rot, xd->window, xd->wgc,
+			 (int)x, (int)y, str);
+	}else{
+	  XmbRotDrawString(display, (XFontSet)(xd->font),
+			   rot, xd->window, xd->wgc,
+			   (int)x, (int)y, str);
+	}
+#ifdef XSYNC
+	if (xd->type == WINDOW) XSync(display, 0);
+#endif
+    }
+}
+
+static Rboolean newX11_Locator(double *x, double *y, NewDevDesc *dd)
+{
+    XEvent event;
+    NewDevDesc *ddEvent;
+    newX11Desc *xd = (newX11Desc *) dd->deviceSpecific;
+    caddr_t temp;
+    int done = 0;
+
+    if (xd->type > WINDOW) return 0;
+    R_ProcessEvents((void*)NULL);	/* discard pending events */
+    XSync(display, 1);
+    /* handle X events as normal until get a button */
+    /* click in the desired device */
+    while (!done && displayOpen) {
+	XNextEvent(display, &event);
+	/* possibly later R_CheckUserInterrupt(); */
+	if (event.type == ButtonPress) {
+	    XFindContext(display, event.xbutton.window,
+			 devPtrContext, &temp);
+	    ddEvent = (NewDevDesc *) temp;
+	    if (ddEvent == dd) {
+		if (event.xbutton.button == Button1) {
+		    int useBeep = asLogical(GetOption(install("locatorBell"), 
+						      R_NilValue));
+		    *x = event.xbutton.x;
+		    *y = event.xbutton.y;
+  		       /* Make a beep! Was print "\07", but that
+                          messes up some terminals. */
+                    if(useBeep) XBell(display, X_BELL_VOLUME);
+		    XSync(display, 0);
+		    done = 1;
+		}
+		else
+		    done = 2;
+	    }
+	}
+	else
+	    handleEvent(event);
+    }
+    /* if it was a Button1 succeed, otherwise fail */
+    return (done == 1);
+}
+
+/* Set Graphics mode - not needed for X11 */
+static void newX11_Mode(int mode, NewDevDesc *dd)
+{
+
+#ifdef XSYNC
+    if (mode == 0) XSync(display, 0);
+#else
+    XSync(display, 0);
+#endif
+}
+
+/* Hold the Picture Onscreen - not needed for X11 */
+static void newX11_Hold(NewDevDesc *dd)
+{
+}
+
+
+	/*  X11 Device Driver Arguments	:	*/
+	/*	1) display name			*/
+	/*	2) width (inches)		*/
+	/*	3) height (inches)		*/
+	/*	4) base pointsize		*/
+	/*	5) gamma correction factor	*/
+	/*	6) colormodel,			*/
+	/*	 see X_COLORTYPE at top of file */
+	/*	7) maxcube			*/
+
+Rboolean newX11DeviceDriver(DevDesc *dd,
+			    char *disp_name,
+			    double width,
+			    double height,
+			    double pointsize,
+			    double gamma_fac,
+			    X_COLORTYPE colormodel,
+			    int maxcube, 
+			    int canvascolor, 
+			    SEXP sfonts)
+{
+    newX11Desc *xd;
+    char *fn;
+
+    xd = Rf_allocNewX11DeviceDesc(pointsize);
+    /* Used to set dd->dp.font=1 and dd->dp.ps=pointsize,
+     * but Paul removed that.
+     * This sort of initialisation occurs in R base graphics now.
+     */
+
+    if(strlen(fn = CHAR(STRING_ELT(sfonts, 0))) > 499)
+       strcpy(xd->fontfamily, fontname);
+    else strcpy(xd->fontfamily,fn);
+    if(strlen(fn = CHAR(STRING_ELT(sfonts, 1))) > 499)
+       strcpy(xd->symbolfamily, symbolname);
+    else strcpy(xd->symbolfamily,fn);
+
+    /*	Start the Device Driver and Hardcopy.  */
+
+    if (!newX11_Open((NewDevDesc*)(dd), xd, disp_name, width, height,
+		     gamma_fac, colormodel, maxcube, canvascolor)) {
+	free(xd);
+	return FALSE;
+    }
+
+    Rf_setNewX11DeviceData((NewDevDesc*)(dd), gamma_fac, xd);
+
+#if BUG
+    R_ProcessEvents((void*) NULL);
+#endif
+
+    return TRUE;
+}
+
+/**
+  This fills the general device structure (dd) with the X-specific
+  methods/functions. It also specifies the current values of the
+  dimensions of the device, and establishes the fonts, line styles, etc.
+ */
+int
+Rf_setNewX11DeviceData(NewDevDesc *dd, double gamma_fac, newX11Desc *xd)
+{
+    char **ml;
+    XFontStruct *fontstruct;
+    XFontStruct **fs_list;
+
+    dd->newDevStruct = 1;
+
+    /*	Set up Data Structures. */
+
+    dd->open = newX11_Open;
+    dd->close = newX11_Close;
+    dd->activate = newX11_Activate;
+    dd->deactivate = newX11_Deactivate;
+    dd->size = newX11_Size;
+    dd->newPage = newX11_NewPage;
+    dd->clip = newX11_Clip;
+    dd->strWidth = newX11_StrWidth;
+    dd->text = newX11_Text;
+    dd->rect = newX11_Rect;
+    dd->circle = newX11_Circle;
+    dd->line = newX11_Line;
+    dd->polyline = newX11_Polyline;
+    dd->polygon = newX11_Polygon;
+    dd->locator = newX11_Locator;
+    dd->mode = newX11_Mode;
+    dd->hold = newX11_Hold;
+    dd->metricInfo = newX11_MetricInfo;
+
+    /* Set required graphics parameters. */
+
+    /* Window Dimensions in Pixels */
+    /* Initialise the clipping rect too */
+
+    dd->left = dd->clipLeft = 0;			/* left */
+    dd->right = dd->clipRight = xd->windowWidth;	/* right */
+    dd->bottom = dd->clipBottom = xd->windowHeight;	/* bottom */
+    dd->top = dd->clipTop = 0;			/* top */
+
+    /* Nominal Character Sizes in Pixels */
+
+    SetBaseFont(xd);
+    XFontsOfFontSet(xd->font, &fs_list, &ml);
+    fontstruct = fs_list[0];
+
+    dd->cra[0] = fontstruct->max_bounds.rbearing -
+      fontstruct->min_bounds.lbearing;
+    dd->cra[1] = fontstruct->max_bounds.ascent +
+      fontstruct->max_bounds.descent;
+
+    /* Character Addressing Offsets */
+    /* These are used to plot a single plotting character */
+    /* so that it is exactly over the plotting point */
+
+    dd->xCharOffset = 0.4900;
+    dd->yCharOffset = 0.3333;
+    dd->yLineBias = 0.1;
+
+    /* Inches per raster unit */
+
+    dd->ipr[0] = pixelWidth();
+    dd->ipr[1] = pixelHeight();
+
+    /* Device capabilities */
+
+    dd->canResizePlot = TRUE;
+    dd->canChangeFont = FALSE;
+    dd->canRotateText = TRUE;
+    dd->canResizeText = TRUE;
+    dd->canClip = TRUE;
+    dd->canHAdj = 0;
+    dd->canChangeGamma = FALSE;
+
+    dd->startps = xd->basefontsize;
+    dd->startcol = xd->col;
+    dd->startfill = xd->fill;
+    dd->startlty = LTY_SOLID;
+    dd->startfont = 1;
+    dd->startgamma = gamma_fac;
+
+    /* initialise x11 device description */
+    /* (most of the work has been done in X11_Open) */
+
+    xd->cex = 1.0;
+    xd->lty = 0;
+    xd->resize = 0;
+
+    dd->deviceSpecific = (void *) xd;
+
+    dd->displayListOn = TRUE;
+
+  return(TRUE);
+}
+
+
+/**
+ This allocates an newX11Desc instance  and sets its default values.
+ */
+newX11Desc * Rf_allocNewX11DeviceDesc(double ps)
+{
+    newX11Desc *xd;
+    /* allocate new device description */
+    if (!(xd = (newX11Desc*)calloc(1, sizeof(newX11Desc))))
+	return FALSE;
+
+    /* From here on, if we need to bail out with "error", */
+    /* then we must also free(xd). */
+
+    /*	Font will load at first use.  */
+
+    if (ps < 6 || ps > 24) ps = 12;
+    xd->fontface = -1;
+    xd->fontsize = -1;
+    xd->basefontface = 1;
+    xd->basefontsize = ps;
+    xd->handleOwnEvents = FALSE;
+    xd->window = (Window) NULL;
+
+    return(xd);
+}
+
+
+static
+Rboolean in_R_GetX11Image(int d, void *pximage, int *pwidth, int *pheight)
+{
+    SEXP dev = elt(findVar(install(".Devices"), R_NilValue), d);
+
+    if (TYPEOF(dev) != STRSXP ||
+	!(strcmp(CHAR(STRING_ELT(dev, 0)), "XImage") == 0 ||
+	  strncmp(CHAR(STRING_ELT(dev, 0)), "PNG", 3) == 0 ||
+	  strncmp(CHAR(STRING_ELT(dev, 0)), "X11", 3) == 0))
+	return FALSE;
+    else {
+	NewDevDesc *dd = ((GEDevDesc *)GetDevice(d))->dev;
+	newX11Desc *xd = dd->deviceSpecific;
+
+	*((XImage**) pximage) =
+            XGetImage(display, xd->window, 0, 0,
+				     xd->windowWidth, xd->windowHeight,
+				     AllPlanes, ZPixmap);
+	*pwidth = xd->windowWidth;
+	*pheight = xd->windowHeight;
+	return TRUE;
+    }
+}
+
+/**
+   Allows callers to retrieve the current Display setting for the process.
+ */
+Display*
+Rf_getX11Display()
+{
+  return(display);
+}
+
+
+/**
+ Allows the caller to register the X11 Display object for the process.
+ Typically this will be done when the first X device is created, but this allows
+ other code to generate the Display object and then register it with the R graphics
+ engine.
+ In addition to providing the Display, the caller should also give the default value for the
+ gamma factor and also the colormodel and color cube size. See the documentation for the x11()
+ function.
+ Finally, setHandlers controls whether the code establishes handlers for the X errors.
+ */
+int
+Rf_setX11Display(Display *dpy, double gamma_fac, X_COLORTYPE colormodel,
+		 int maxcube, Rboolean setHandlers)
+{
+/*    static int alreadyDone = 0;
+    if(alreadyDone) return(TRUE);
+    alreadyDone = 1; */
+    display = dpy;
+
+#define SETGAMMA
+#ifdef SETGAMMA
+    RedGamma   = gamma_fac;
+    GreenGamma = gamma_fac;
+    BlueGamma  = gamma_fac;
+#endif
+    screen = DefaultScreen(display);
+    rootwin = DefaultRootWindow(display);
+    depth = DefaultDepth(display, screen);
+    visual = DefaultVisual(display, screen);
+    colormap = DefaultColormap(display, screen);
+    Vclass = visual->class;
+    model = colormodel;
+    maxcubesize = maxcube;
+    SetupX11Color();
+    devPtrContext = XUniqueContext();
+    displayOpen = TRUE;
+    /* set error handlers */
+    if(setHandlers == TRUE) {
+	XSetErrorHandler(R_X11Err);
+	XSetIOErrorHandler(R_X11IOErr);
+    }
+
+    return(TRUE);
+}
+
+typedef Rboolean (*X11DeviceDriverRoutine)(DevDesc*, char*, 
+					   double, double, double, double,
+					   X_COLORTYPE, int, int);
+
+/* Return a non-relocatable copy of a string */
+
+static SEXP gcall;
+
+static char *SaveString(SEXP sxp, int offset)
+{
+    char *s;
+    if(!isString(sxp) || length(sxp) <= offset)
+	errorcall(gcall, "invalid string argument");
+    s = R_alloc(strlen(CHAR(STRING_ELT(sxp, offset)))+1, sizeof(char));
+    strcpy(s, CHAR(STRING_ELT(sxp, offset)));
+    return s;
+}
+
+static DevDesc* 
+Rf_addX11Device(char *display, double width, double height, double ps, 
+		double gamma, int colormodel, int maxcubesize,
+		int canvascolor, char *devname, SEXP sfonts)
+{
+    NewDevDesc *dev = NULL;
+    GEDevDesc *dd;
+    R_CheckDeviceAvailable();
+    BEGIN_SUSPEND_INTERRUPTS {
+	/* Allocate and initialize the device driver data */
+	if (!(dev = (NewDevDesc*)calloc(1, sizeof(NewDevDesc))))
+	    return 0;
+	/* Do this for early redraw attempts */
+	dev->newDevStruct = 1;
+	dev->displayList = R_NilValue;
+	/* Make sure that this is initialised before a GC can occur.
+	 * This (and displayList) get protected during GC
+	 */
+	dev->savedSnapshot = R_NilValue;
+	/* Took out the GInit because MOST of it is setting up
+	 * R base graphics parameters.  
+	 * This is supposed to happen via addDevice now.
+	 */
+	if (!newX11DeviceDriver((DevDesc*)(dev), display, width, height, 
+				ps, gamma, colormodel, maxcubesize, 
+				canvascolor, sfonts)) {
+	    free(dev);
+	    errorcall(gcall, "unable to start device %s", devname);
+       	}
+	gsetVar(install(".Device"), mkString(devname), R_NilValue);
+	dd = GEcreateDevDesc(dev);
+	addDevice((DevDesc*) dd);
+	GEinitDisplayList(dd);
+    } END_SUSPEND_INTERRUPTS;
+    
+    return((DevDesc*) dd);
+}
+
+SEXP in_do_X11(SEXP call, SEXP op, SEXP args, SEXP env)
+{
+    char *display, *vmax, *cname, *devname;
+    double height, width, ps, gamma;
+    int colormodel, maxcubesize, canvascolor;
+    SEXP sc, sfonts;
+
+    gcall = call;
+    vmax = vmaxget();
+
+    /* Decode the arguments */
+    display = SaveString(CAR(args), 0); args = CDR(args);
+    width = asReal(CAR(args));	args = CDR(args);
+    height = asReal(CAR(args)); args = CDR(args);
+    if (width <= 0 || height <= 0)
+	errorcall(call, "invalid width or height");
+    ps = asReal(CAR(args)); args = CDR(args);
+    gamma = asReal(CAR(args)); args = CDR(args);
+    if (gamma < 0 || gamma > 100)
+	errorcall(call, "invalid gamma value");
+
+    if (!isValidString(CAR(args)))
+	error("invalid colortype passed to X11 driver");
+    cname = CHAR(STRING_ELT(CAR(args), 0));
+    if (strcmp(cname, "mono") == 0)
+	colormodel = 0;
+    else if (strcmp(cname, "gray") == 0 || strcmp(cname, "grey") == 0)
+	colormodel = 1;
+    else if (strcmp(cname, "pseudo.cube") == 0)
+	colormodel = 2;
+    else if (strcmp(cname, "pseudo") == 0)
+	colormodel = 3;
+    else if (strcmp(cname, "true") == 0)
+	colormodel = 4;
+    else {
+	warningcall(call, 
+		    "unknown X11 color/colour model -- using monochrome");
+	colormodel = 0;
+    }
+    args = CDR(args);
+    maxcubesize = asInteger(CAR(args));
+    if (maxcubesize < 1 || maxcubesize > 256)
+        maxcubesize = 256;
+    args = CDR(args);
+    sc = CAR(args);
+    if (!isString(sc) && !isInteger(sc) && !isLogical(sc) && !isReal(sc))
+	errorcall(call, "invalid value of `canvas'");
+    canvascolor = RGBpar(sc, 0);
+    args = CDR(args);
+    sfonts = CAR(args);
+    if (!isString(sfonts) || LENGTH(sfonts) != 2)
+       errorcall(call, "invalid value of `fonts'");
+
+    devname = "X11";
+    if (!strncmp(display, "png::", 5)) devname = "PNG";
+    else if (!strncmp(display, "jpeg::", 6)) devname = "JPEG";
+    else if (!strcmp(display, "XImage")) devname = "XImage";
+
+    Rf_addX11Device(display, width, height, ps, gamma, colormodel, 
+		    maxcubesize, canvascolor, devname, sfonts);
+    vmaxset(vmax);
+    return R_NilValue;
+}
+
+extern SEXP RX11_dataentry(SEXP call, SEXP op, SEXP args, SEXP rho);
+
+void R_init_R_X11(DllInfo *info)
+{
+    R_X11Routines *tmp;
+    tmp = (R_X11Routines*) malloc(sizeof(R_X11Routines));
+    if(!tmp) {
+	error("Cannot allocate memory for X11Routines structure");
+	return;
+    }
+    tmp->X11 = in_do_X11;
+    tmp->de = RX11_dataentry;
+    tmp->image = in_R_GetX11Image;
+    R_setX11Routines(tmp);
+}
+#endif /* I18N_MB */
diff -ruN R-1.9.0.orig/src/modules/X11/devX11_mb.h R-1.9.0.i18n.x11_mb/src/modules/X11/devX11_mb.h
--- R-1.9.0.orig/src/modules/X11/devX11_mb.h	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/devX11_mb.h	2004-04-22 22:01:47.000000000 +0900
@@ -0,0 +1,129 @@
+#ifdef I18N_MB
+#ifndef _DEV_X11_H
+#define _DEV_X11_H
+
+#define SYMBOL_FONTFACE 5
+
+/* These are the currently supported device "models" */
+typedef enum {
+    MONOCHROME = 0,
+    GRAYSCALE,
+    PSEUDOCOLOR1,
+    PSEUDOCOLOR2,
+    TRUECOLOR
+} X_COLORTYPE;
+
+typedef enum {
+    WINDOW, /* NB: have "type > WINDOW" below ... */
+    PNG,
+    JPEG,
+    XIMAGE
+} X_GTYPE;
+
+
+/*
+  For the moment, we just conditionally activate the remainder of this
+  section iff we are in devX11.c which defines R_X11_DEVICE.
+  This allows devUI.h to include this file to get X_COLORTYPE.
+  However, that should probably not be happening if HAVE_X11 is not defined
+  due to the configuration being done --without-x. Why is unix/devices.c 
+  not(?) getting compiled if no X11 support is available? DTL.
+ */
+#if R_X11_DEVICE
+
+#include <stdio.h>
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
+#include <X11/Intrinsic.h>  /*->	Xlib.h	Xutil.h Xresource.h .. */
+
+
+
+Rboolean newX11DeviceDriver(DevDesc*, char*, double, double, double, double, 
+			    X_COLORTYPE, int, int, SEXP);
+
+
+	/********************************************************/
+	/* Each driver can have its own device-specic graphical */
+	/* parameters and resources.  these should be wrapped	*/
+	/* in a structure (like the x11Desc structure below)	*/
+	/* and attached to the overall device description via	*/
+	/* the dd->deviceSpecific pointer			*/
+	/* NOTE that there are generic graphical parameters	*/
+	/* which must be set by the device driver, but are	*/
+	/* common to all device types (see Graphics.h)		*/
+	/* so go in the GPar structure rather than this device- */
+	/* specific structure					*/
+	/********************************************************/
+
+typedef struct {
+    /* Graphics Parameters */
+    /* Local device copy so that we can detect */
+    /* when parameter changes. */
+
+    /* cex retained -- its a GRZ way of specifying text size, but
+     * its too much work to change at this time (?)
+     */
+    double cex;				/* Character expansion */
+    /* srt removed -- its a GRZ parameter and is not used in devX11.c
+     */
+    int lty;				/* Line type */
+    double lwd;
+    int col;				/* Color */
+    /* fg and bg removed -- only use col and new param fill
+     */
+    int fill;
+    int canvas;				/* Canvas */
+    int fontface;			/* Typeface */
+    int fontsize;			/* Size in points */
+    int basefontface;			/* Typeface */
+    int basefontsize;			/* Size in points */
+
+    /* X11 Driver Specific */
+    /* Parameters with copy per X11 device. */
+
+    int windowWidth;			/* Window width (pixels) */
+    int windowHeight;			/* Window height (pixels) */
+    int resize;				/* Window resized */
+    Window window;			/* Graphics Window */
+    GC wgc;				/* GC for window */
+    Cursor gcursor;			/* Graphics Cursor */
+    XSetWindowAttributes attributes;	/* Window attributes */
+#if 0
+    XColor fgcolor;			/* Foreground color */
+    XColor bgcolor;			/* Background color */
+#endif
+    XRectangle clip;			/* The clipping rectangle */
+
+    int usefixed;
+    void *fixedfont;
+    void *font;
+    char fontfamily[500];
+    char symbolfamily[500];
+    X_GTYPE type;			/* Window or pixmap? */
+    int npages;				/* counter for a pixmap */
+    FILE *fp;				/* file for a bitmap device */
+    char filename[PATH_MAX];		/* filename for a bitmap device */
+    int quality;			/* JPEG quality */
+
+    Rboolean handleOwnEvents;           /* Flag indicating whether events will be handled externally from R (TRUE),
+                                           or whether R is to handle the events (FALSE) */
+} newX11Desc;
+
+
+
+newX11Desc *Rf_allocNewX11DeviceDesc(double ps);
+int      Rf_setX11Display(Display *dpy, double gamma_fac, X_COLORTYPE colormodel, int maxcube, Rboolean setHandlers);
+int      Rf_setNewX11DeviceData(NewDevDesc *dd, double gamma_fac, newX11Desc *xd);
+Rboolean newX11_Open(NewDevDesc *dd, newX11Desc *xd, 
+		     char *dsp, double w, double h, 
+		     double gamma_fac, X_COLORTYPE colormodel, 
+		     int maxcube, int canvascolor);
+
+#endif /* R_X11_DEVICE */
+
+#endif
+
+#endif /* I18N_MB */
diff -ruN R-1.9.0.orig/src/modules/X11/rotated_mb.c R-1.9.0.i18n.x11_mb/src/modules/X11/rotated_mb.c
--- R-1.9.0.orig/src/modules/X11/rotated_mb.c	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/rotated_mb.c	2004-04-24 22:47:47.000000000 +0900
@@ -0,0 +1,1490 @@
+#ifdef I18N_MB
+/* ********************************************************************** */
+
+/* xvertext 5.0, Copyright (c) 1993 Alan Richardson (mppa3@uk.ac.sussex.syma)
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies and that both the
+ * copyright notice and this permission notice appear in supporting
+ * documentation.  All work developed as a consequence of the use of
+ * this program should duly acknowledge such use. No representations are
+ * made about the suitability of this software for any purpose.	 It is
+ * provided "as is" without express or implied warranty.
+ */
+
+/* ********************************************************************** */
+
+
+/* BETTER: xvertext now does rotation at any angle!!
+ *
+ * BEWARE: function arguments have CHANGED since version 2.0!!
+ *
+ * Protoized (ANSI C, no longer old K&R C):  Martin Maechler, R core team.
+ */
+
+/* ********************************************************************** */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xatom.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <string.h>
+#if defined(HAVE_DECL_STRDUP) && !HAVE_DECL_STRDUP
+extern char *strdup(const char *s1);
+#endif
+#include "rotated.h"
+#include "rotated_mb.h"
+#include "xmb_xutf8.h"
+
+/* ---------------------------------------------------------------------- */
+
+
+/* Make sure cache size is set */
+
+#ifndef CACHE_SIZE_LIMIT
+#define CACHE_SIZE_LIMIT 0
+#endif /*CACHE_SIZE_LIMIT */
+
+/* Make sure a cache method is specified */
+
+#ifndef CACHE_XIMAGES
+#ifndef CACHE_BITMAPS
+#define CACHE_BITMAPS
+#endif /*CACHE_BITMAPS*/
+#endif /*CACHE_XIMAGES*/
+
+#ifndef DEG2RAD
+#define DEG2RAD 0.01745329251994329576
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+
+/* Debugging macros */
+
+#ifdef DEBUG
+static int debug=1;
+#else
+static int debug=0;
+#endif /*DEBUG*/
+
+#define DEBUG_PRINT1(a) if (debug) printf (a)
+#define DEBUG_PRINT2(a, b) if (debug) printf (a, b)
+#define DEBUG_PRINT3(a, b, c) if (debug) printf (a, b, c)
+#define DEBUG_PRINT4(a, b, c, d) if (debug) printf (a, b, c, d)
+#define DEBUG_PRINT5(a, b, c, d, e) if (debug) printf (a, b, c, d, e)
+
+
+/* ---------------------------------------------------------------------- */
+
+static double myround(double x)
+{
+    return floor(x+0.5);
+}
+
+
+/* A structure holding everything needed for a rotated string */
+
+typedef struct rotated_text_item_template {
+    Pixmap bitmap;
+    XImage *ximage;
+
+    char *text;
+    char *font_name;
+    Font fid;
+    double angle;
+    int align;
+    double magnify;
+
+    int cols_in;
+    int rows_in;
+    int cols_out;
+    int rows_out;
+
+    int nl;
+    int max_width;
+    double *corners_x;
+    double *corners_y;
+
+    long int size;
+    int cached;
+
+    struct rotated_text_item_template *next;
+} RotatedTextItem;
+
+static RotatedTextItem *first_text_item=NULL;
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/* A structure holding current magnification and bounding box padding */
+
+static struct style_template {
+    double magnify;
+    int bbx_pad;
+} style={
+    1.,
+    0
+    };
+
+
+/* ---------------------------------------------------------------------- */
+
+
+double			 XmbRotVersion(char *str, int n);
+void			XmbRotSetMagnification(double m);
+void			XmbRotSetBoundingBoxPad(int p);
+int			XmbRotDrawString(Display *dpy, XFontSet font, double angle, Drawable drawable, GC gc, int x, int y, char *str);
+int			XmbRotDrawImageString(Display *dpy, XFontSet font, double angle, Drawable drawable, GC gc, int x, int y, char *str);
+int			XmbRotDrawAlignedString(Display *dpy, XFontSet font, double angle, Drawable drawable, GC gc, int x, int y, char *text, int align);
+int			XmbRotDrawAlignedImageString(Display *dpy, XFontSet font, double angle, Drawable drawable, GC gc, int x, int y, char *text, int align);
+XPoint		       *XmbRotTextExtents(Display *dpy, XFontSet font, double angle, int x, int y, char *text, int align);
+
+static XImage	       *MakeXImage(Display *dpy, int w, int h);
+static int		XmbRotPaintAlignedString(Display *dpy, XFontSet font, double angle, Drawable drawable, GC gc, int x, int y, char *text, int align, int bg);
+static int		XmbRotDrawHorizontalString(Display *dpy, XFontSet font, Drawable drawable, GC gc, int x, int y, char *text, int align, int bg);
+static RotatedTextItem *XmbRotRetrieveFromCache(Display *dpy, XFontSet font, double angle, char *text, int align);
+static RotatedTextItem *XmbRotCreateTextItem(Display *dpy, XFontSet font, double angle, char *text, int align);
+static void		XmbRotAddToLinkedList(Display *dpy, RotatedTextItem *item);
+static void		XmbRotFreeTextItem(Display *dpy, RotatedTextItem *item);
+static XImage	       *XmbRotMagnifyImage(Display *dpy, XImage *ximage);
+
+void                    XSetFontSet(Display *display,GC gc,XFontSet font);
+XFontStruct            *XFontStructOfFontSet(XFontSet font);
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/* Return version/copyright information					  */
+/**************************************************************************/
+
+double XmbRotVersion(char *str, int n)
+{
+    if(str!=NULL)
+	strncpy(str, XV_COPYRIGHT, n);
+    return XV_VERSION;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/* Set the font magnification factor for all subsequent operations	  */
+/**************************************************************************/
+
+void XmbRotSetMagnification(double m)
+{
+    if(m>0.)
+	style.magnify=m;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/* Set the padding used when calculating bounding boxes			  */
+/**************************************************************************/
+
+void XmbRotSetBoundingBoxPad(int p)
+{
+    if(p>=0)
+	style.bbx_pad=p;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  Create an XImage structure and allocate memory for it		  */
+/**************************************************************************/
+
+static XImage *MakeXImage(Display *dpy, int w, int h)
+{
+    XImage *I;
+    char *data;
+
+    /* reserve memory for image */
+    data=(char *)calloc((unsigned)(((w-1)/8+1)*h), 1);
+    if(data==NULL)
+	return NULL;
+
+    /* create the XImage */
+    I=XCreateImage(dpy, DefaultVisual(dpy, DefaultScreen(dpy)), 1, XYBitmap,
+		   0, data, w, h, 8, 0);
+    if(I==NULL)
+	return NULL;
+
+    I->byte_order=I->bitmap_bit_order=MSBFirst;
+    return I;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  A front end to XmbRotPaintAlignedString:				  */
+/*	-no alignment, no background					  */
+/**************************************************************************/
+
+int XmbRotDrawString(Display *dpy, XFontSet font, double angle,
+		   Drawable drawable, GC gc, int x, int y, char *str)
+{
+    return (XmbRotPaintAlignedString(dpy, font, angle, drawable, gc,
+				   x, y, str, NONE, 0));
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  A front end to XmbRotPaintAlignedString:				  */
+/*	-no alignment, paints background				  */
+/**************************************************************************/
+
+int XmbRotDrawImageString(Display *dpy, XFontSet font, double angle,
+			Drawable drawable, GC gc, int x, int y, char *str)
+{
+    return(XmbRotPaintAlignedString(dpy, font, angle, drawable, gc,
+				  x, y, str, NONE, 1));
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  A front end to XmbRotPaintAlignedString:				  */
+/*	-does alignment, no background					  */
+/**************************************************************************/
+
+int XmbRotDrawAlignedString(Display *dpy, XFontSet font, double angle,
+			  Drawable drawable, GC gc, int x, int y,
+			  char *text, int align)
+{
+    return(XmbRotPaintAlignedString(dpy, font, angle, drawable, gc,
+				  x, y, text, align, 0));
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  A front end to XmbRotPaintAlignedString:				  */
+/*	-does alignment, paints background				  */
+/**************************************************************************/
+
+int XmbRotDrawAlignedImageString(Display *dpy, XFontSet font, double angle,
+			       Drawable drawable, GC gc, int x, int y,
+			       char *text, int align)
+{
+    return(XmbRotPaintAlignedString(dpy, font, angle, drawable, gc,
+				  x, y, text, align, 1));
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  Aligns and paints a rotated string					  */
+/**************************************************************************/
+
+static int XmbRotPaintAlignedString(Display *dpy, XFontSet font, double angle,
+				  Drawable drawable, GC gc, int x, int y,
+				  char *text, int align, int bg)
+{
+    int i;
+    GC my_gc;
+    int xp, yp;
+    double hot_x, hot_y;
+    double hot_xp, hot_yp;
+    double sin_angle, cos_angle;
+    RotatedTextItem *item;
+    Pixmap bitmap_to_paint;
+    XFontStruct *fs;
+
+    /* return early for NULL/empty strings */
+    if(text==NULL || *text=='\0')
+	return 0;
+
+    if(strlen(text)==0)
+	return 0;
+
+    /* manipulate angle to 0<=angle<360 degrees */
+    while(angle<0)
+	angle+=360;
+
+    while(angle>=360)
+	angle-=360;
+
+    angle *= DEG2RAD;
+
+    /* horizontal text made easy */
+    if(angle==0. && style.magnify==1.)
+	return(XmbRotDrawHorizontalString(dpy, font, drawable, gc, x, y,
+					text, align, bg));
+
+    /* get a rotated bitmap */
+    item=XmbRotRetrieveFromCache(dpy, font, angle, text, align);
+    if(item==NULL)
+	return 0;
+
+    /* this gc has similar properties to the user's gc */
+    my_gc=XCreateGC(dpy, drawable, (unsigned long)0, 0);
+    XCopyGC(dpy, gc, GCForeground|GCBackground|GCFunction|GCPlaneMask
+	    |GCClipMask,
+	    my_gc);
+
+    /* alignment : which point (hot_x, hot_y) relative to bitmap centre
+       coincides with user's specified point? */
+
+    /* y position */
+    fs = XFontStructOfFontSet(font);
+
+    if(align==TLEFT || align==TCENTRE || align==TRIGHT)
+	hot_y=(double)item->rows_in/2*style.magnify;
+    else if(align==MLEFT || align==MCENTRE || align==MRIGHT)
+	hot_y=0;
+    else if(align==BLEFT || align==BCENTRE || align==BRIGHT)
+	hot_y= -(double)item->rows_in/2*style.magnify;
+    else
+	hot_y= -((double)item->rows_in/2-(double)fs->descent)*style.magnify;
+
+    /* x position */
+    if(align==TLEFT || align==MLEFT || align==BLEFT || align==NONE)
+	hot_x= -(double)item->max_width/2*style.magnify;
+    else if(align==TCENTRE || align==MCENTRE || align==BCENTRE)
+	hot_x=0;
+    else
+	hot_x=(double)item->max_width/2*style.magnify;
+
+    /* pre-calculate sin and cos */
+    sin_angle = myround(sin(angle)*1000.0) / 1000.0;
+    cos_angle = myround(cos(angle)*1000.0) / 1000.0;
+
+    /* rotate hot_x and hot_y around bitmap centre */
+    hot_xp = hot_x*cos_angle - hot_y*sin_angle;
+    hot_yp = hot_x*sin_angle + hot_y*cos_angle;
+
+    /* text background will be drawn using XFillPolygon */
+    if(bg) {
+	GC depth_one_gc;
+	XPoint *xpoints;
+	Pixmap empty_stipple;
+
+	/* reserve space for XPoints */
+	xpoints=(XPoint *)malloc((unsigned)(4*item->nl*sizeof(XPoint)));
+	if(!xpoints)
+	    return 1;
+
+	/* rotate corner positions */
+	for(i=0; i<4*item->nl; i++) {
+	    xpoints[i].x=(double)x + ( (item->corners_x[i]-hot_x)*cos_angle +
+				      (item->corners_y[i]+hot_y)*sin_angle);
+	    xpoints[i].y=(double)y + (-(item->corners_x[i]-hot_x)*sin_angle +
+				      (item->corners_y[i]+hot_y)*cos_angle);
+	}
+
+	/* we want to swap foreground and background colors here;
+	   XGetGCValues() is only available in R4+ */
+
+	empty_stipple=XCreatePixmap(dpy, drawable, 1, 1, 1);
+
+	depth_one_gc=XCreateGC(dpy, empty_stipple, (unsigned long)0, 0);
+	XSetForeground(dpy, depth_one_gc, 0);
+	XFillRectangle(dpy, empty_stipple, depth_one_gc, 0, 0, 2, 2);
+
+	XSetStipple(dpy, my_gc, empty_stipple);
+	XSetFillStyle(dpy, my_gc, FillOpaqueStippled);
+
+	XFillPolygon(dpy, drawable, my_gc, xpoints, 4*item->nl, Nonconvex,
+		     CoordModeOrigin);
+
+	/* free our resources */
+	free((char *)xpoints);
+	XFreeGC(dpy, depth_one_gc);
+	XFreePixmap(dpy, empty_stipple);
+    }
+
+    /* where should top left corner of bitmap go ? */
+    xp=(double)x-((double)item->cols_out/2 +hot_xp);
+    yp=(double)y-((double)item->rows_out/2 -hot_yp);
+
+    /* by default we draw the rotated bitmap, solid */
+    bitmap_to_paint=item->bitmap;
+
+    /* handle user stippling */
+#ifndef X11R3
+    {
+	GC depth_one_gc;
+	XGCValues values;
+	Pixmap new_bitmap, inverse;
+
+	/* try and get some GC properties */
+	if(XGetGCValues(dpy, gc,
+			GCStipple|GCFillStyle|GCForeground|GCBackground|
+			GCTileStipXOrigin|GCTileStipYOrigin,
+			&values)) {
+
+	    /* only do this if stippling requested */
+	    if((values.fill_style==FillStippled ||
+		values.fill_style==FillOpaqueStippled) && !bg) {
+
+		/* opaque stipple: draw rotated text in background colour */
+		if(values.fill_style==FillOpaqueStippled) {
+		    XSetForeground(dpy, my_gc, values.background);
+		    XSetFillStyle(dpy, my_gc, FillStippled);
+		    XSetStipple(dpy, my_gc, item->bitmap);
+		    XSetTSOrigin(dpy, my_gc, xp, yp);
+		    XFillRectangle(dpy, drawable, my_gc, xp, yp,
+				   item->cols_out, item->rows_out);
+		    XSetForeground(dpy, my_gc, values.foreground);
+		}
+
+		/* this will merge the rotated text and the user's stipple */
+		new_bitmap=XCreatePixmap(dpy, drawable,
+					 item->cols_out, item->rows_out, 1);
+
+		/* create a GC */
+		depth_one_gc=XCreateGC(dpy, new_bitmap, (unsigned long)0, 0);
+		XSetForeground(dpy, depth_one_gc, 1);
+		XSetBackground(dpy, depth_one_gc, 0);
+
+		/* set the relative stipple origin */
+		XSetTSOrigin(dpy, depth_one_gc,
+			     values.ts_x_origin-xp, values.ts_y_origin-yp);
+
+		/* fill the whole bitmap with the user's stipple */
+		XSetStipple(dpy, depth_one_gc, values.stipple);
+		XSetFillStyle(dpy, depth_one_gc, FillOpaqueStippled);
+		XFillRectangle(dpy, new_bitmap, depth_one_gc,
+			       0, 0, item->cols_out, item->rows_out);
+
+		/* set stipple origin back to normal */
+		XSetTSOrigin(dpy, depth_one_gc, 0, 0);
+
+		/* this will contain an inverse copy of the rotated text */
+		inverse=XCreatePixmap(dpy, drawable,
+				      item->cols_out, item->rows_out, 1);
+
+		/* invert text */
+		XSetFillStyle(dpy, depth_one_gc, FillSolid);
+		XSetFunction(dpy, depth_one_gc, GXcopyInverted);
+		XCopyArea(dpy, item->bitmap, inverse, depth_one_gc,
+			  0, 0, item->cols_out, item->rows_out, 0, 0);
+
+		/* now delete user's stipple everywhere EXCEPT on text */
+		XSetForeground(dpy, depth_one_gc, 0);
+		XSetBackground(dpy, depth_one_gc, 1);
+		XSetStipple(dpy, depth_one_gc, inverse);
+		XSetFillStyle(dpy, depth_one_gc, FillStippled);
+		XSetFunction(dpy, depth_one_gc, GXcopy);
+		XFillRectangle(dpy, new_bitmap, depth_one_gc,
+			       0, 0, item->cols_out, item->rows_out);
+
+		/* free resources */
+		XFreePixmap(dpy, inverse);
+		XFreeGC(dpy, depth_one_gc);
+
+		/* this is the new bitmap */
+		bitmap_to_paint=new_bitmap;
+	    }
+	}
+    }
+#endif /*X11R3*/
+
+    /* paint text using stipple technique */
+    XSetFillStyle(dpy, my_gc, FillStippled);
+    XSetStipple(dpy, my_gc, bitmap_to_paint);
+    XSetTSOrigin(dpy, my_gc, xp, yp);
+    XFillRectangle(dpy, drawable, my_gc, xp, yp,
+		   item->cols_out, item->rows_out);
+
+    /* free our resources */
+    XFreeGC(dpy, my_gc);
+
+    /* stippled bitmap no longer needed */
+    if(bitmap_to_paint!=item->bitmap)
+	XFreePixmap(dpy, bitmap_to_paint);
+
+#ifdef CACHE_XIMAGES
+    XFreePixmap(dpy, item->bitmap);
+#endif /*CACHE_XIMAGES*/
+
+    /* if item isn't cached, destroy it completely */
+    if(!item->cached)
+	XmbRotFreeTextItem(dpy,item);
+
+    /* we got to the end OK! */
+    return 0;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  Draw a horizontal string in a quick fashion				  */
+/**************************************************************************/
+
+static int XmbRotDrawHorizontalString(Display *dpy, XFontSet font,
+				    Drawable drawable, GC gc, int x, int y,
+				    char *text, int align, int bg)
+{
+    GC my_gc;
+    int nl=1, i;
+    int height;
+    int xp, yp;
+    char *str1, *str2, *str3;
+    char *str2_a="\0", *str2_b="\n\0";
+    int dir, asc, desc;
+    XCharStruct overall;
+
+    if (text == NULL || *text=='\0') {
+      DEBUG_PRINT1("Empty string, ignoring\n");
+      return 0;
+    }
+
+    /* this gc has similar properties to the user's gc (including stipple) */
+    my_gc=XCreateGC(dpy, drawable, (unsigned long)0, 0);
+    XCopyGC(dpy, gc,
+	    GCForeground|GCBackground|GCFunction|GCStipple|GCFillStyle|
+	    GCTileStipXOrigin|GCTileStipYOrigin|GCPlaneMask|GCClipMask, my_gc);
+    XSetFontSet(dpy, my_gc, font);
+
+    /* count number of sections in string */
+    if(align!=NONE)
+	for(i=0; i<strlen(text)-1; i++)
+	    if(text[i]=='\n')
+		nl++;
+
+    /* ignore newline characters if not doing alignment */
+    if(align==NONE)
+	str2=str2_a;
+    else
+	str2=str2_b;
+
+    /* overall font height */
+    height
+      =XFontStructOfFontSet(font)->ascent
+      +XFontStructOfFontSet(font)->descent;
+
+    /* y position */
+    if(align==TLEFT || align==TCENTRE || align==TRIGHT)
+	yp=y+XFontStructOfFontSet(font)->ascent;
+    else if(align==MLEFT || align==MCENTRE || align==MRIGHT)
+	yp=y-nl*height/2+XFontStructOfFontSet(font)->ascent;
+    else if(align==BLEFT || align==BCENTRE || align==BRIGHT)
+	yp=y-nl*height+XFontStructOfFontSet(font)->ascent;
+    else
+	yp=y;
+
+    str1=strdup(text);
+    if(str1==NULL)
+	return 1;
+
+    str3=strtok(str1, str2);
+
+    /* loop through each section in the string */
+    do {
+
+        XRectangle    r_ink, r_log;
+	XRfTextExtents(font, str3, strlen(str3), &r_ink, &r_log);
+
+	/* where to draw section in x ? */
+	if(align==TLEFT || align==MLEFT || align==BLEFT || align==NONE)
+	    xp=x;
+	else if(align==TCENTRE || align==MCENTRE || align==BCENTRE)
+	    xp=x-r_log.width/2;
+	else
+	    xp=x-r_log.width;
+
+	/* draw string onto bitmap */
+	if(!bg)
+	    XRfDrawString(dpy, drawable, font, my_gc, xp, yp, str3, strlen(str3));
+	else
+	    XRfDrawImageString(dpy, drawable, font, my_gc, xp, yp, str3, strlen(str3));
+
+	/* move to next line */
+	yp+=height;
+
+	str3=strtok((char *)NULL, str2);
+    }
+    while(str3!=NULL);
+
+    free(str1);
+    XFreeGC(dpy, my_gc);
+
+    return 0;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*   Query cache for a match with this font/text/angle/alignment	  */
+/*	 request, otherwise arrange for its creation			  */
+/**************************************************************************/
+
+static RotatedTextItem *XmbRotRetrieveFromCache(Display *dpy, XFontSet font,
+					      double angle, char *text,
+					      int align)
+{
+    Font fid;
+    char *font_name=NULL;
+    unsigned long name_value;
+    RotatedTextItem *item=NULL;
+    RotatedTextItem *i1=first_text_item;
+
+    /* get font name, if it exists */
+    if(XGetFontProperty(XFontStructOfFontSet(font), XA_FONT, &name_value)) {
+	DEBUG_PRINT1("got font name OK\n");
+	font_name=XGetAtomName(dpy, name_value);
+	fid=0;
+    }
+#ifdef CACHE_FID
+    /* otherwise rely (unreliably?) on font ID */
+    else {
+	DEBUG_PRINT1("can't get fontname, caching FID\n");
+	font_name=NULL;
+	fid=font->fid;
+    }
+#else
+    /* not allowed to cache font ID's */
+    else {
+	DEBUG_PRINT1("can't get fontname, can't cache\n");
+	font_name=NULL;
+	fid=0;
+    }
+#endif /*CACHE_FID*/
+
+    /* look for a match in cache */
+
+    /* matching formula:
+       identical text;
+       identical fontname (if defined, font ID's if not);
+       angles close enough (<0.0001 here, could be smaller);
+       HORIZONTAL alignment matches, OR it's a one line string;
+       magnifications the same */
+
+    while(i1 && !item) {
+	/* match everything EXCEPT fontname/ID */
+	if(strcmp(text, i1->text)==0 &&
+	   fabs(angle-i1->angle)<0.0001 &&
+	   style.magnify==i1->magnify &&
+	   (i1->nl==1 ||
+	    ((align==0)?9:(align-1))%3==
+	      ((i1->align==0)?9:(i1->align-1))%3)) {
+
+	    /* now match fontname/ID */
+	    if(font_name!=NULL && i1->font_name!=NULL) {
+		if(strcmp(font_name, i1->font_name)==0) {
+		    item=i1;
+		    DEBUG_PRINT1("Matched against font names\n");
+		}
+		else
+		    i1=i1->next;
+	    }
+#ifdef CACHE_FID
+	    else if(font_name==NULL && i1->font_name==NULL) {
+		if(fid==i1->fid) {
+		    item=i1;
+		    DEBUG_PRINT1("Matched against FID's\n");
+		}
+		else
+		    i1=i1->next;
+	    }
+#endif /*CACHE_FID*/
+	    else
+		i1=i1->next;
+	}
+	else
+	    i1=i1->next;
+    }
+
+    if(item)
+	DEBUG_PRINT1("**Found target in cache.\n");
+    if(!item)
+	DEBUG_PRINT1("**No match in cache.\n");
+
+    /* no match */
+    if(!item) {
+	/* create new item */
+	item=XmbRotCreateTextItem(dpy, font, angle, text, align);
+	if(!item)
+	    return NULL;
+
+	/* record what it shows */
+	item->text=strdup(text);
+
+	/* fontname or ID */
+	if(font_name!=NULL) {
+	    item->font_name=strdup(font_name);
+	    item->fid=0;
+	}
+	else {
+	    item->font_name=NULL;
+	    item->fid=fid;
+	}
+
+	item->angle=angle;
+	item->align=align;
+	item->magnify=style.magnify;
+
+	/* cache it */
+	XmbRotAddToLinkedList(dpy, item);
+    }
+
+    if(font_name)
+	XFree(font_name);
+
+    /* if XImage is cached, need to recreate the bitmap */
+
+#ifdef CACHE_XIMAGES
+    {
+	GC depth_one_gc;
+
+	/* create bitmap to hold rotated text */
+	item->bitmap=XCreatePixmap(dpy, DefaultRootWindow(dpy),
+				   item->cols_out, item->rows_out, 1);
+
+	/* depth one gc */
+	depth_one_gc=XCreateGC(dpy, item->bitmap, (unsigned long)0, 0);
+	XSetBackground(dpy, depth_one_gc, 0);
+	XSetForeground(dpy, depth_one_gc, 1);
+
+	/* make the text bitmap from XImage */
+	XPutImage(dpy, item->bitmap, depth_one_gc, item->ximage, 0, 0, 0, 0,
+		  item->cols_out, item->rows_out);
+
+	XFreeGC(dpy, depth_one_gc);
+    }
+#endif /*CACHE_XIMAGES*/
+
+    return item;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  Create a rotated text item						  */
+/**************************************************************************/
+
+static RotatedTextItem *XmbRotCreateTextItem(Display *dpy, XFontSet font,
+					   double angle, char *text, int align)
+{
+    RotatedTextItem *item=NULL;
+    Pixmap canvas;
+    GC font_gc;
+    XImage *I_in;
+    register int i, j;
+    char *str1, *str2, *str3;
+    char *str2_a="\0", *str2_b="\n\0";
+    int height;
+    int byte_w_in, byte_w_out;
+    int xp, yp;
+    double sin_angle, cos_angle;
+    int it, jt;
+    double itd, jtd;
+    double di, dj;
+    int ic=0;
+    double xl, xr, xinc;
+    int byte_out;
+    XRectangle    r_ink, r_log;
+    int old_cols_in=0, old_rows_in=0;
+
+    /* allocate memory */
+    item=(RotatedTextItem *)malloc((unsigned)sizeof(RotatedTextItem));
+    if(!item)
+	return NULL;
+
+    /* count number of sections in string */
+    item->nl=1;
+    if(align!=NONE)
+	for(i=0; i<strlen(text)-1; i++)
+	    if(text[i]=='\n')
+		item->nl++;
+
+    /* ignore newline characters if not doing alignment */
+    if(align==NONE)
+	str2=str2_a;
+    else
+	str2=str2_b;
+
+    /* find width of longest section */
+    str1=strdup(text);
+    if(str1==NULL)
+	return NULL;
+
+    str3=strtok(str1, str2);
+
+    XRfTextExtents(font, str3, strlen(str3), &r_ink, &r_log);
+
+    item->max_width=r_log.width;
+
+    /* loop through each section */
+    do {
+	str3=strtok((char *)NULL, str2);
+
+	if(str3!=NULL) {
+	  XRfTextExtents(font, str3, strlen(str3), &r_ink, &r_log);
+
+	    if(r_log.width>item->max_width)
+		item->max_width=r_log.width;
+	}
+    }
+    while(str3!=NULL);
+
+    free(str1);
+
+    /* overall font height */
+    height=XFontStructOfFontSet(font)->ascent
+      +XFontStructOfFontSet(font)->descent;
+
+    /* dimensions horizontal text will have */
+    item->cols_in=item->max_width;
+    item->rows_in=item->nl*height;
+
+    /* fudge in case one of the above is zero: */
+    if (!item->cols_in) item->cols_in=1;
+    if (!item->rows_in) item->rows_in=1;
+
+    /* bitmap for drawing on */
+    canvas=XCreatePixmap(dpy, DefaultRootWindow(dpy),
+			 item->cols_in, item->rows_in, 1);
+
+    /* create a GC for the bitmap */
+    font_gc=XCreateGC(dpy, canvas, (unsigned long)0, 0);
+    XSetBackground(dpy, font_gc, 0);
+    XSetFontSet(dpy, font_gc, font);
+
+    /* make sure the bitmap is blank */
+    XSetForeground(dpy, font_gc, 0);
+    XFillRectangle(dpy, canvas, font_gc, 0, 0,
+		   item->cols_in+1, item->rows_in+1);
+    XSetForeground(dpy, font_gc, 1);
+
+    /* pre-calculate sin and cos */
+    sin_angle = myround(sin(angle)*1000.0) / 1000.0;
+    cos_angle = myround(cos(angle)*1000.0) / 1000.0;
+
+    /* text background will be drawn using XFillPolygon */
+    item->corners_x=
+	(double *)malloc((unsigned)(4*item->nl*sizeof(double)));
+    if(!item->corners_x)
+	return NULL;
+
+    item->corners_y=
+	(double *)malloc((unsigned)(4*item->nl*sizeof(double)));
+    if(!item->corners_y)
+	return NULL;
+
+    /* draw text horizontally */
+
+    /* start at top of bitmap */
+    yp=XFontStructOfFontSet(font)->ascent;
+
+    str1=strdup(text);
+    if(str1==NULL)
+	return NULL;
+
+    str3=strtok(str1, str2);
+
+    /* loop through each section in the string */
+    do {
+        XRectangle    r_ink, r_log;
+	XRfTextExtents(font, str3, strlen(str3), &r_ink, &r_log);
+
+	/* where to draw section in x ? */
+	if(align==TLEFT || align==MLEFT || align==BLEFT || align==NONE)
+	    xp=0;
+	else if(align==TCENTRE || align==MCENTRE || align==BCENTRE)
+	    xp=(item->max_width-r_log.width)/2;
+	else
+	    xp=item->max_width-r_log.width;
+
+	/* draw string onto bitmap */
+	XRfDrawString(dpy, canvas, font, font_gc, xp, yp, str3, strlen(str3));
+
+	/* keep a note of corner positions of this string */
+	item->corners_x[ic]=((double)xp-(double)item->cols_in/2)*style.magnify;
+	item->corners_y[ic]=((double)(yp-XFontStructOfFontSet(font)->ascent)-(double)item->rows_in/2)
+	    *style.magnify;
+	item->corners_x[ic+1]=item->corners_x[ic];
+	item->corners_y[ic+1]=item->corners_y[ic]+(double)height*style.magnify;
+	item->corners_x[item->nl*4-1-ic]=item->corners_x[ic]+
+	    (double)r_log.width*style.magnify;
+	item->corners_y[item->nl*4-1-ic]=item->corners_y[ic];
+	item->corners_x[item->nl*4-2-ic]=
+	    item->corners_x[item->nl*4-1-ic];
+	item->corners_y[item->nl*4-2-ic]=item->corners_y[ic+1];
+
+	ic+=2;
+
+	/* move to next line */
+	yp+=height;
+
+	str3=strtok((char *)NULL, str2);
+    }
+    while(str3!=NULL);
+
+    free(str1);
+
+    /* create image to hold horizontal text */
+    I_in=MakeXImage(dpy, item->cols_in, item->rows_in);
+    if(I_in==NULL)
+	return NULL;
+
+    /* extract horizontal text */
+    XGetSubImage(dpy, canvas, 0, 0, item->cols_in, item->rows_in,
+		 1, XYPixmap, I_in, 0, 0);
+    I_in->format=XYBitmap;
+
+    /* magnify horizontal text */
+    if(style.magnify!=1.) {
+	I_in=XmbRotMagnifyImage(dpy, I_in);
+
+	old_cols_in=item->cols_in;
+	old_rows_in=item->rows_in;
+	item->cols_in=(double)item->cols_in*style.magnify;
+	item->rows_in=(double)item->rows_in*style.magnify;
+    }
+
+    /* how big will rotated text be ? */
+    item->cols_out=fabs((double)item->rows_in*sin_angle) +
+	fabs((double)item->cols_in*cos_angle) +0.99999 +2;
+
+    item->rows_out=fabs((double)item->rows_in*cos_angle) +
+	fabs((double)item->cols_in*sin_angle) +0.99999 +2;
+
+    if(item->cols_out%2==0)
+	item->cols_out++;
+
+    if(item->rows_out%2==0)
+	item->rows_out++;
+
+    /* create image to hold rotated text */
+    item->ximage=MakeXImage(dpy, item->cols_out, item->rows_out);
+    if(item->ximage==NULL)
+	return NULL;
+
+    byte_w_in=(item->cols_in-1)/8+1;
+    byte_w_out=(item->cols_out-1)/8+1;
+
+    /* we try to make this bit as fast as possible - which is why it looks
+       a bit over-the-top */
+
+    /* vertical distance from centre */
+    dj=0.5-(double)item->rows_out/2;
+
+    /* where abouts does text actually lie in rotated image? */
+    /* check angle within 0.5 degrees (0.008 radians) */
+    if(fabs((double)angle)<0.008 || fabs((double)angle-M_PI/2)<0.008 ||
+       fabs((double)angle-M_PI)<0.008 || fabs((double)angle-3*M_PI/2)<0.008) {
+	xl=0;
+	xr=(double)item->cols_out;
+	xinc=0;
+    }
+    else if(angle<M_PI) {
+	xl=(double)item->cols_out/2+
+	    (dj-(double)item->rows_in/(2*cos_angle))/
+	    tan(angle)-2;
+	xr=(double)item->cols_out/2+
+	    (dj+(double)item->rows_in/(2*cos_angle))/
+	    tan(angle)+2;
+	xinc=1./tan(angle);
+    }
+    else {
+	xl=(double)item->cols_out/2+
+	    (dj+(double)item->rows_in/(2*cos_angle))/
+	    tan(angle)-2;
+	xr=(double)item->cols_out/2+
+	    (dj-(double)item->rows_in/(2*cos_angle))/
+	    tan(angle)+2;
+
+	xinc=1./tan(angle);
+    }
+
+    /* loop through all relevent bits in rotated image */
+    for(j=0; j<item->rows_out; j++) {
+
+	/* no point re-calculating these every pass */
+	di=(double)((xl<0)?0:(int)xl)+0.5-(double)item->cols_out/2;
+	byte_out=(item->rows_out-j-1)*byte_w_out;
+
+	/* loop through meaningful columns */
+	for(i=((xl<0)?0:(int)xl);
+	    i<((xr>=item->cols_out)?item->cols_out:(int)xr); i++) {
+
+	    /* rotate coordinates */
+	    itd=(double)item->cols_in/2 + ( di*cos_angle + dj*sin_angle);
+	    jtd=(double)item->rows_in/2 - (-di*sin_angle + dj*cos_angle);
+	    it = itd - (itd < 0); /* (int) -0.5 == 0 */
+	    jt = jtd - (jtd < 0);
+
+	    /* set pixel if required */
+	    if(it>=0 && it<item->cols_in && jt>=0 && jt<item->rows_in)
+		if((I_in->data[jt*byte_w_in+it/8] & 128>>(it%8))>0)
+		    item->ximage->data[byte_out+i/8]|=128>>i%8;
+
+	    di+=1;
+	}
+	dj+=1;
+	xl+=xinc;
+	xr+=xinc;
+    }
+    XDestroyImage(I_in);
+
+    if(style.magnify!=1.) {
+	item->cols_in=old_cols_in;
+	item->rows_in=old_rows_in;
+    }
+
+
+#ifdef CACHE_BITMAPS
+
+    /* create a bitmap to hold rotated text */
+    item->bitmap=XCreatePixmap(dpy, DefaultRootWindow(dpy),
+			       item->cols_out, item->rows_out, 1);
+
+    /* make the text bitmap from XImage */
+    XPutImage(dpy, item->bitmap, font_gc, item->ximage, 0, 0, 0, 0,
+	      item->cols_out, item->rows_out);
+
+    XDestroyImage(item->ximage);
+
+#endif /*CACHE_BITMAPS*/
+
+    XFreeGC(dpy, font_gc);
+    XFreePixmap(dpy, canvas);
+
+    return item;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  Adds a text item to the end of the cache, removing as many items	  */
+/*	from the front as required to keep cache size below limit	  */
+/**************************************************************************/
+
+static void XmbRotAddToLinkedList(Display *dpy, RotatedTextItem *item)
+{
+
+    static long int current_size=0;
+    static RotatedTextItem *last=NULL;
+    RotatedTextItem *i1=first_text_item, *i2=NULL;
+
+#ifdef CACHE_BITMAPS
+
+    /* I don't know how much memory a pixmap takes in the server -
+       probably this + a bit more we can't account for */
+
+    item->size=((item->cols_out-1)/8+1)*item->rows_out;
+
+#else
+
+    /* this is pretty much the size of a RotatedTextItem */
+
+    item->size=((item->cols_out-1)/8+1)*item->rows_out +
+	sizeof(XImage) + strlen(item->text) +
+	item->nl*8*sizeof(double) + sizeof(RotatedTextItem);
+
+    if(item->font_name!=NULL)
+	item->size+=strlen(item->font_name);
+    else
+	item->size+=sizeof(Font);
+
+#endif /*CACHE_BITMAPS */
+
+#ifdef DEBUG
+    /* count number of items in cache, for debugging */
+    {
+	int i=0;
+
+	while(i1) {
+	    i++;
+	    i1=i1->next;
+	}
+	DEBUG_PRINT2("Cache has %d items.\n", i);
+	i1=first_text_item;
+    }
+#endif
+
+    DEBUG_PRINT4("current cache size=%ld, new item=%ld, limit=%d\n",
+		 current_size, item->size, CACHE_SIZE_LIMIT*1024);
+
+    /* if this item is bigger than whole cache, forget it */
+    if(item->size>CACHE_SIZE_LIMIT*1024) {
+	DEBUG_PRINT1("Too big to cache\n\n");
+	item->cached=0;
+	return;
+    }
+
+    /* remove elements from cache as needed */
+    while(i1 && current_size+item->size>CACHE_SIZE_LIMIT*1024) {
+
+	DEBUG_PRINT2("Removed %ld bytes\n", i1->size);
+
+	if(i1->font_name!=NULL)
+	    DEBUG_PRINT5("  (`%s'\n   %s\n   angle=%f align=%d)\n",
+			 i1->text, i1->font_name, i1->angle, i1->align);
+
+#ifdef CACHE_FID
+	if(i1->font_name==NULL)
+            DEBUG_PRINT5("  (`%s'\n  FID=%ld\n   angle=%f align=%d)\n",
+			 i1->text, i1->fid, i1->angle, i1->align);
+#endif /*CACHE_FID*/
+
+	current_size-=i1->size;
+
+	i2=i1->next;
+
+	/* free resources used by the unlucky item */
+	XmbRotFreeTextItem(dpy, i1);
+
+	/* remove it from linked list */
+	first_text_item=i2;
+	i1=i2;
+    }
+
+    /* add new item to end of linked list */
+    if(first_text_item==NULL) {
+	item->next=NULL;
+	first_text_item=item;
+	last=item;
+    }
+    else {
+	item->next=NULL;
+	last->next=item;
+	last=item;
+    }
+
+    /* new cache size */
+    current_size+=item->size;
+
+    item->cached=1;
+
+    DEBUG_PRINT1("Added item to cache.\n");
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/*  Free the resources used by a text item				  */
+/**************************************************************************/
+
+static void XmbRotFreeTextItem(Display *dpy, RotatedTextItem *item)
+{
+    free(item->text);
+
+    if(item->font_name!=NULL)
+	free(item->font_name);
+
+    free((char *)item->corners_x);
+    free((char *)item->corners_y);
+
+#ifdef CACHE_BITMAPS
+    XFreePixmap(dpy, item->bitmap);
+#else
+    XDestroyImage(item->ximage);
+#endif /* CACHE_BITMAPS */
+
+    free((char *)item);
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/* Magnify an XImage using bilinear interpolation			  */
+/**************************************************************************/
+
+static XImage *XmbRotMagnifyImage(Display *dpy, XImage *ximage)
+{
+    int i, j;
+    double x, y;
+    double u,t;
+    XImage *I_out;
+    int cols_in, rows_in;
+    int cols_out, rows_out;
+    register int i2, j2;
+    double z1, z2, z3, z4;
+    int byte_width_in, byte_width_out;
+    double mag_inv;
+
+    /* size of input image */
+    cols_in=ximage->width;
+    rows_in=ximage->height;
+
+    /* size of final image */
+    cols_out=(double)cols_in*style.magnify;
+    rows_out=(double)rows_in*style.magnify;
+
+    /* this will hold final image */
+    I_out=MakeXImage(dpy, cols_out, rows_out);
+    if(I_out==NULL)
+	return NULL;
+
+    /* width in bytes of input, output images */
+    byte_width_in=(cols_in-1)/8+1;
+    byte_width_out=(cols_out-1)/8+1;
+
+    /* for speed */
+    mag_inv=1./style.magnify;
+
+    y=0.;
+
+    /* loop over magnified image */
+    for(j2=0; j2<rows_out; j2++) {
+	x=0;
+	j=y;
+
+	for(i2=0; i2<cols_out; i2++) {
+	    i=x;
+
+	    /* bilinear interpolation - where are we on bitmap ? */
+	    /* right edge */
+	    if(i==cols_in-1 && j!=rows_in-1) {
+		t=0;
+		u=y-(double)j;
+
+		z1=(ximage->data[j*byte_width_in+i/8] & 128>>(i%8))>0;
+		z2=z1;
+		z3=(ximage->data[(j+1)*byte_width_in+i/8] & 128>>(i%8))>0;
+		z4=z3;
+	    }
+	    /* top edge */
+	    else if(i!=cols_in-1 && j==rows_in-1) {
+		t=x-(double)i;
+		u=0;
+
+		z1=(ximage->data[j*byte_width_in+i/8] & 128>>(i%8))>0;
+		z2=(ximage->data[j*byte_width_in+(i+1)/8] & 128>>((i+1)%8))>0;
+		z3=z2;
+		z4=z1;
+	    }
+	    /* top right corner */
+	    else if(i==cols_in-1 && j==rows_in-1) {
+		u=0;
+		t=0;
+
+		z1=(ximage->data[j*byte_width_in+i/8] & 128>>(i%8))>0;
+		z2=z1;
+		z3=z1;
+		z4=z1;
+	    }
+	    /* somewhere `safe' */
+	    else {
+		t=x-(double)i;
+		u=y-(double)j;
+
+		z1=(ximage->data[j*byte_width_in+i/8] & 128>>(i%8))>0;
+		z2=(ximage->data[j*byte_width_in+(i+1)/8] & 128>>((i+1)%8))>0;
+		z3=(ximage->data[(j+1)*byte_width_in+(i+1)/8] &
+		    128>>((i+1)%8))>0;
+		z4=(ximage->data[(j+1)*byte_width_in+i/8] & 128>>(i%8))>0;
+	    }
+
+	    /* if interpolated value is greater than 0.5, set bit */
+	    if(((1-t)*(1-u)*z1 + t*(1-u)*z2 + t*u*z3 + (1-t)*u*z4)>0.5)
+		I_out->data[j2*byte_width_out+i2/8]|=128>>i2%8;
+
+	    x+=mag_inv;
+	}
+	y+=mag_inv;
+    }
+
+    /* destroy original */
+    XDestroyImage(ximage);
+
+    /* return big image */
+    return I_out;
+}
+
+
+
+/* ---------------------------------------------------------------------- */
+
+
+/**************************************************************************/
+/* Calculate the bounding box some text will have when painted		  */
+/**************************************************************************/
+
+XPoint *XmbRotTextExtents(Display *dpy, XFontSet font, double angle,
+			int x, int y, char *text, int align)
+{
+    register int i;
+    char *str1, *str2, *str3;
+    char *str2_a="\0", *str2_b="\n\0";
+    int height;
+    double sin_angle, cos_angle;
+    int nl, max_width;
+    int cols_in, rows_in;
+    double hot_x, hot_y;
+    XPoint *xp_in, *xp_out;
+    XRectangle    r_ink, r_log;
+
+    /* manipulate angle to 0<=angle<360 degrees */
+    while(angle<0)
+	angle+=360;
+
+    while(angle>360)
+	angle-=360;
+
+    angle *= DEG2RAD;
+
+    /* count number of sections in string */
+    nl=1;
+    if(align!=NONE)
+	for(i=0; i<strlen(text)-1; i++)
+	    if(text[i]=='\n')
+		nl++;
+
+    /* ignore newline characters if not doing alignment */
+    if(align==NONE)
+	str2=str2_a;
+    else
+	str2=str2_b;
+
+    /* find width of longest section */
+    str1=strdup(text);
+    if(str1==NULL)
+	return NULL;
+
+    str3=strtok(str1, str2);
+
+    XRfTextExtents(font, str3, strlen(str3), &r_ink, &r_log);
+
+    max_width=r_log.width;
+
+    /* loop through each section */
+    do {
+	str3=strtok((char *)NULL, str2);
+
+	if(str3!=NULL) {
+	  XRfTextExtents(font, str3, strlen(str3), &r_ink, &r_log);
+
+	    if(r_log.width>max_width)
+		max_width=r_log.width;
+	}
+    }
+    while(str3!=NULL);
+
+    free(str1);
+
+    /* overall font height */
+    height=XFontStructOfFontSet(font)->ascent
+      +XFontStructOfFontSet(font)->descent;
+
+    /* dimensions horizontal text will have */
+    cols_in=max_width;
+    rows_in=nl*height;
+
+    /* pre-calculate sin and cos */
+    sin_angle = myround(sin(angle)*1000.0) / 1000.0;
+    cos_angle = myround(cos(angle)*1000.0) / 1000.0;
+
+    /* y position */
+    if(align==TLEFT || align==TCENTRE || align==TRIGHT)
+	hot_y=(double)rows_in/2*style.magnify;
+    else if(align==MLEFT || align==MCENTRE || align==MRIGHT)
+	hot_y=0;
+    else if(align==BLEFT || align==BCENTRE || align==BRIGHT)
+	hot_y= -(double)rows_in/2*style.magnify;
+    else
+	hot_y= -((double)rows_in/2-(double)XFontStructOfFontSet(font)->descent)*style.magnify;
+
+    /* x position */
+    if(align==TLEFT || align==MLEFT || align==BLEFT || align==NONE)
+	hot_x= -(double)max_width/2*style.magnify;
+    else if(align==TCENTRE || align==MCENTRE || align==BCENTRE)
+	hot_x=0;
+    else
+	hot_x=(double)max_width/2*style.magnify;
+
+    /* reserve space for XPoints */
+    xp_in=(XPoint *)malloc((unsigned)(5*sizeof(XPoint)));
+    if(!xp_in)
+	return NULL;
+
+    xp_out=(XPoint *)malloc((unsigned)(5*sizeof(XPoint)));
+    if(!xp_out)
+	return NULL;
+
+    /* bounding box when horizontal, relative to bitmap centre */
+    xp_in[0].x= -(double)cols_in*style.magnify/2-style.bbx_pad;
+    xp_in[0].y= (double)rows_in*style.magnify/2+style.bbx_pad;
+    xp_in[1].x= (double)cols_in*style.magnify/2+style.bbx_pad;
+    xp_in[1].y= (double)rows_in*style.magnify/2+style.bbx_pad;
+    xp_in[2].x= (double)cols_in*style.magnify/2+style.bbx_pad;
+    xp_in[2].y= -(double)rows_in*style.magnify/2-style.bbx_pad;
+    xp_in[3].x= -(double)cols_in*style.magnify/2-style.bbx_pad;
+    xp_in[3].y=-(double)rows_in*style.magnify/2-style.bbx_pad;
+    xp_in[4].x=xp_in[0].x;
+    xp_in[4].y=xp_in[0].y;
+
+    /* rotate and translate bounding box */
+    for(i=0; i<5; i++) {
+	xp_out[i].x=(double)x + ( ((double)xp_in[i].x-hot_x)*cos_angle +
+				  ((double)xp_in[i].y+hot_y)*sin_angle);
+	xp_out[i].y=(double)y + (-((double)xp_in[i].x-hot_x)*sin_angle +
+				 ((double)xp_in[i].y+hot_y)*cos_angle);
+    }
+
+    free((char *)xp_in);
+
+    return xp_out;
+}
+
+void XSetFontSet(
+ 	         Display *display,
+	         GC gc,
+	         XFontSet font
+	         )
+{
+    char **ml;
+    XFontStruct **fs_list;
+    int i;
+    int cnt;
+
+    cnt = XFontsOfFontSet(font, &fs_list, &ml);
+    for(i=0;i<cnt;i++){
+      XSetFont(display,gc,fs_list[i]->fid);
+    }
+}
+
+XFontStruct * XFontStructOfFontSet(
+				   XFontSet font
+				   )
+{
+    char **ml;
+    XFontStruct **fs_list;
+    XFontsOfFontSet(font, &fs_list, &ml);
+    return(fs_list[0]);
+}
+#endif /* I18N_MB */
diff -ruN R-1.9.0.orig/src/modules/X11/rotated_mb.h R-1.9.0.i18n.x11_mb/src/modules/X11/rotated_mb.h
--- R-1.9.0.orig/src/modules/X11/rotated_mb.h	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/rotated_mb.h	2003-09-09 15:38:22.000000000 +0900
@@ -0,0 +1,39 @@
+#ifdef I18N_MB
+/* ************************************************************************ */
+
+
+/* Header file for the `xvertext 5.0' routines.
+
+   Copyright (c) 1993 Alan Richardson (mppa3@uk.ac.sussex.syma) */
+
+
+/* ************************************************************************ */
+
+#ifndef _ROTATED_MB_H_
+#define _ROTATED_MB_H_
+
+
+double	XmbRotVersion(char*, int);
+void	XmbRotSetMagnification(double);
+void	XmbRotSetBoundingBoxPad(int);
+int	XmbRotDrawString(Display*, XFontSet, double,
+		       Drawable, GC, int, int, char*);
+int	XmbRotDrawImageString(Display*, XFontSet, double,
+			    Drawable, GC, int, int, char*);
+int	XmbRotDrawAlignedString(Display*, XFontSet, double,
+			      Drawable, GC, int, int, char*, int);
+int	XmbRotDrawAlignedImageString(Display*, XFontSet, double,
+				   Drawable, GC, int, int, char*, int);
+XPoint *XmbRotTextExtents(Display*, XFontSet, double,
+			int, int, char*, int);
+void                    XSetFontSet(Display *display,GC gc,XFontSet font);
+XFontStruct            *XFontStructOfFontSet(XFontSet font);
+
+
+/* ---------------------------------------------------------------------- */
+
+#endif /* _ROTATED_MB_H_ */
+
+
+
+#endif /* I18N_MB */
diff -ruN R-1.9.0.orig/src/modules/X11/xmb_xutf8.h R-1.9.0.i18n.x11_mb/src/modules/X11/xmb_xutf8.h
--- R-1.9.0.orig/src/modules/X11/xmb_xutf8.h	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/xmb_xutf8.h	2004-04-24 22:40:43.000000000 +0900
@@ -0,0 +1,126 @@
+#ifndef XMB_XUTF8_H
+#define XMB_XUTF8_H
+#include <string.h>
+#include <langinfo.h>
+
+static int XRfTextEscapement(
+			     XFontSet font_set,
+			     char *string,
+			     int num_bytes
+			     );
+
+static int XRfTextExtents(
+			  XFontSet font_set,
+			  char *string,
+			  int num_bytes,
+			  XRectangle *overall_ink_return,
+			  XRectangle *overall_logical_return
+			  );
+
+static void XRfDrawString(
+			  Display *display,
+			  Drawable d,
+			  XFontSet font_set,
+			  GC gc,
+			  int x,
+			  int y,
+			  char *string,
+			  int num_bytes
+			  );
+
+static void XRfDrawImageString(
+			       Display *display,
+			       Drawable d,
+			       XFontSet font_set,
+			       GC gc,
+			       int x,
+			       int y,
+			       char *string,
+			       int num_bytes
+			       );
+
+static int XRfTextEscapement(
+			     XFontSet font_set,
+			     char *string,
+			     int num_bytes
+			     ){
+  if (strcmp(nl_langinfo(CODESET), "UTF-8") == 0){
+    return Xutf8TextEscapement(font_set,string,num_bytes);
+  }
+  return XmbTextEscapement(font_set,string,num_bytes);
+}  
+
+static int XRfTextExtents(
+			  XFontSet font_set,
+			  char *string,
+			  int num_bytes,
+			  XRectangle *overall_ink_return,
+			  XRectangle *overall_logical_return
+			  ){
+  if (strcmp(nl_langinfo(CODESET), "UTF-8") == 0){
+    return Xutf8TextExtents(font_set,string,num_bytes,
+			    overall_ink_return,
+			    overall_logical_return);
+  }
+  return XmbTextExtents(font_set,string,num_bytes,
+			overall_ink_return,
+			overall_logical_return);
+}
+
+static void XRfDrawString(
+			  Display *display,
+			  Drawable d,
+			  XFontSet font_set,
+			  GC gc,
+			  int x,
+			  int y,
+			  char *string,
+			  int num_bytes
+			  ){
+  if (strcmp(nl_langinfo(CODESET), "UTF-8") == 0){
+    Xutf8DrawString(display, d,
+		    font_set, gc,
+		    x,
+		    y,
+		    string,
+		    num_bytes);
+    return;
+  }
+  XmbDrawString(display, d,
+		font_set, gc,
+		x,
+		y,
+		string,
+		num_bytes);
+  return;
+}
+
+static void XRfDrawImageString(
+			       Display *display,
+			       Drawable d,
+			       XFontSet font_set,
+			       GC gc,
+			       int x,
+			       int y,
+			       char *string,
+			       int num_bytes
+			       ){
+  if (strcmp(nl_langinfo(CODESET), "UTF-8") == 0){
+    Xutf8DrawImageString(display, d,
+			 font_set, gc,
+			 x,
+			 y,
+			 string,
+			 num_bytes);
+    return;
+  }
+  XmbDrawImageString(display, d,
+		     font_set, gc,
+		     x,
+		     y,
+		     string,
+		     num_bytes);
+  return;
+}
+
+#endif /* XMB_XUTF8_H */
diff -ruN R-1.9.0.orig/src/modules/X11/xrm.c R-1.9.0.i18n.x11_mb/src/modules/X11/xrm.c
--- R-1.9.0.orig/src/modules/X11/xrm.c	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/xrm.c	2003-09-09 15:38:22.000000000 +0900
@@ -0,0 +1,166 @@
+#ifdef I18N_MB
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <locale.h>
+#include <X11/Xlib.h>
+#include <X11/Xresource.h>
+
+#include "xrm.h"
+#include <R.h>
+
+/*
+ * RX11 I18N_MB Resource Control
+ *
+ * Copyright(c) Japanese Imperial Heisei 15 Ei-ji Nakama <nakama@ki.rim.or.jp> 
+ *
+ */
+
+/*
+ * ------------------------------------------- CreateDB
+ */
+XrmDatabase CreateDB(Display *display)
+{
+  char pathname[BUFSIZ];
+  char *property;
+  char *home;
+  char *r_home;
+  XrmDatabase db;
+
+  home=getenv("HOME");
+  r_home=getenv("R_HOME");
+
+  if(NULL==(property = XResourceManagerString(display))){
+    /*
+     * $HOME/.Xdefaults
+     */
+    strncpy(pathname,home,BUFSIZ);
+    strncat(pathname,"/.Xdefaults",BUFSIZ);
+    pathname[BUFSIZ-1]='\0';
+    db = XrmGetFileDatabase (pathname);
+  }else{
+    db = XrmGetStringDatabase(property);
+  }
+
+  /*
+   * $R_USER/etc/R_X11.<locale>
+   */
+  strncpy(pathname,home,BUFSIZ);
+  strncat(pathname,"/etc/",BUFSIZ);
+  strncat(pathname,RX11_CLASS,BUFSIZ);
+  strncat(pathname,".",BUFSIZ);
+  strncat(pathname,setlocale(LC_CTYPE, NULL),BUFSIZ);
+  pathname[BUFSIZ-1]='\0';
+  XrmCombineFileDatabase (pathname, &db, False);
+  /*
+   * $R_HOME/etc/RX11.<locale>
+   */
+  strncpy(pathname,r_home,BUFSIZ);
+  strncat(pathname,"/etc/",BUFSIZ);
+  strncat(pathname,RX11_CLASS,BUFSIZ);
+  strncat(pathname,".",BUFSIZ);
+  strncat(pathname,setlocale(LC_CTYPE, NULL),BUFSIZ);
+  pathname[BUFSIZ-1]='\0';
+  XrmCombineFileDatabase (pathname, &db, False);
+  /*
+   * $R_USER/etc/R_X11
+   */
+  strncpy(pathname,home,BUFSIZ);
+  strncat(pathname,"/etc/",BUFSIZ);
+  strncat(pathname,RX11_CLASS,BUFSIZ);
+  pathname[BUFSIZ-1]='\0';
+  XrmCombineFileDatabase (pathname, &db, False);
+  /*
+   * $R_HOME/etc/RX11
+   */
+  strncpy(pathname,r_home,BUFSIZ);
+  strncat(pathname,"/etc/",BUFSIZ);
+  strncat(pathname,RX11_CLASS,BUFSIZ);
+  pathname[BUFSIZ-1]='\0';
+  XrmCombineFileDatabase (pathname, &db, False);
+  
+  return(db);
+}
+
+/*
+ * ------------------------------------------- GetResource
+ */
+char *GetResource(
+		  XrmDatabase db,
+		  char *res_name,
+		  char *res_class,
+		  char *def){
+  char name[BUFSIZ];
+  char class[BUFSIZ];
+  char *type;
+  XrmValue val;
+  char *string;
+
+  strncpy( name, RX11_NAME, BUFSIZ);
+  strncat( name, ".", BUFSIZ);
+  strncat( name, res_name, BUFSIZ);
+  name[BUFSIZ-1]='\0';
+
+  strncpy( class, RX11_CLASS, BUFSIZ);
+  strncat( class, ".", BUFSIZ);
+  strncat( class, res_class, BUFSIZ);
+  class[BUFSIZ-1]='\0';
+
+  if (!XrmGetResource ( db, name, class, &type, &val)){
+    val.size = strlen(def);
+    val.addr = def;
+  }
+
+  if (NULL==(string = (char *) malloc ( val.size + 1))){
+    Rprintf("%s:%n:malloc error.", __FILE__, __LINE__);
+    exit(-1);
+  }
+  strncpy (string, val.addr,val.size);
+  string[val.size] = '\0';
+  return(string);
+}
+
+void  GetFontResource(
+		      XrmDatabase db,
+		      char *buf,
+		      int size,
+		      int face,
+		      int pixelsize)
+{
+  char res_name[128];
+  char res_class[128];
+  char *res;
+  char *pi;
+  char *po;
+  int i;
+  char fsize[128];
+
+  sprintf (fsize,"%d",pixelsize);
+
+  sprintf(res_name,RX11_FONT_RM_NAME "%d", face);
+  sprintf(res_class,RX11_FONT_RM_CLASS "%d", face);
+
+  res=GetResource (db, res_name, res_class,
+		    RX11_FONT_DEFAULT );
+
+  for (pi=res,po=buf ; po - buf < size - 1 && *pi != '\0'; pi++,po++){
+    if (*pi == '%' && *(pi+1) == 'd'){
+      if ( size - 1 - strlen(fsize) > po - buf ){
+	for (i=0; i<strlen(fsize); i++){
+	  *po = fsize[i] ;
+	  po++;
+	}
+	po--;
+      }
+      pi++;
+    }else{
+      *po = *pi;
+    }
+  }
+  *po = '\0';
+  buf[size - 1]='\0';
+  free(res); 
+}
+
+#endif /* I18N_MB */
diff -ruN R-1.9.0.orig/src/modules/X11/xrm.h R-1.9.0.i18n.x11_mb/src/modules/X11/xrm.h
--- R-1.9.0.orig/src/modules/X11/xrm.h	1970-01-01 09:00:00.000000000 +0900
+++ R-1.9.0.i18n.x11_mb/src/modules/X11/xrm.h	2003-09-09 15:38:22.000000000 +0900
@@ -0,0 +1,32 @@
+#ifdef I18N_MB
+#ifndef _XRM_H_
+#define _XRM_H_
+#include <X11/Xlib.h>
+#include <X11/Xresource.h>
+
+/*
+ * RX11 I18N_MB Resource Control
+ *
+ * Copyright(c) Japanese Imperial Heisei 15 Ei-ji Nakama <nakama@ki.rim.or.jp> 
+ *
+ */
+#define RX11_CLASS "R_X11"
+#define RX11_NAME "R"
+#define RX11_FONT_RM_NAME "fontset"
+#define RX11_FONT_RM_CLASS "fontSet"
+#define RX11_FONT_DEFAULT "-*-fixed-medium-r-normal--%d-*-*-*-*-*-*-*"
+
+XrmDatabase CreateDB(Display *display);
+char *GetResource(XrmDatabase xrmdb,
+		  char *res_name,
+		  char *res_class,
+		  char *def);
+void  GetFontResource(
+                      XrmDatabase db,
+                      char *buf,
+                      int size,
+                      int face,
+                      int pixelsize);
+
+#endif /* _XRM_H_ */
+#endif /* I18N_MB */
