diff -uNr groff-1.19.1.orig/ChangeLog.jp groff-1.19.1/ChangeLog.jp
--- groff-1.19.1.orig/ChangeLog.jp	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/ChangeLog.jp	2005-02-23 16:32:33.188770032 +0900
@@ -0,0 +1,273 @@
+2002-06-16  Fumitoshi UKAI  <ukai@debian.or.jp>
+
+	* based on groff 1.18pre? (2002/06/15 CVS current)
+
+2001-07-15  Fumitoshi UKAI  <ukai@debian.or.jp>
+
+	* based on groff 1.17.2-1
+	* use src/include/encoding.h instead of eucmac.h
+	* introduce src/libs/libgroff/encoding.cc
+	* introduce tmac/euc-jp.tmac for EUC-JP documents
+
+2001-05-24  Fumitoshi UKAI  <ukai@debian.or.jp>
+
+	* Apply for groff-1.17
+
+2000-01-06  Yoshiaki Yanagihara  <yochi@debian.or.jp>
+
+	* Apply japanese patch "jgroff-0.101"
+	  (thanks hanataka@abyss.rim.or.jp).
+	* Added japanese extention option at configure.in, aclocal.m4.
+
+Sat Jan  1 17:10:32 JST 2000  HANATAKA Shinya  <hanataka@abyss.rim.or.jp>
+
+	* jgroff-0.100 をそのまま groff-1.14 に適用して jgroff-101
+	  とした。
+	* grohtml を日本語に対応させる。
+	* 日本語マニュアル用に tmac.docj と tmac.andocj マクロを追加。
+
+Sun Mar 15 18:23:12 1998  Yoshiaki Yanagihara  <yochi@debian.or.jp>
+
+	* jgroff のベースを groff-1.11a に変更し、jgroff-0.99パッチを
+	  適用したものを jgroff-0.100 とした。
+	  基本的に jgroff-0.99 と機能は同じ *はず*。
+
+Fri Dec 22 11:47:46 1995  Kitagawa Toshiyuki  <tm-kita@kh.rim.or.jp>
+
+	* バージョン0.99。
+
+Mon Dec 18 18:28:37 1995  Kitagawa Toshiyuki  <tm-kita@kh.rim.or.jp>
+
+	* tmac/Makefile.sub: ターゲット stamp-wrap、uninstall_sub が一部
+	OSのshで構文エラーとなるオリジナルバグを修正。
+
+Wed Dec 13 15:09:26 1995  Kitagawa Toshiyuki  <tm-kita@kh.rim.or.jp>
+
+	* jgroff.sh: オリジナルでインストールパスが変更されたのに合わせ、
+	GROFF_TMAC_PATH、GROFF_FONT_PATHをshare/groff配下に変更。
+
+Sat Dec  9 15:28:36 1995  Kitagawa Toshiyuki  <tm-kita@kh.rim.or.jp>
+
+	* wchar.hからeucmac.hにファイル名を変更。
+
+Fri Dec  8 12:15:47 1995  Yoshio Takaeda  <shio@yinyan.bekkoame.or.jp>
+
+	* troff/env.cc(add_char): 『ASCII文字 + 改行コード + EUC文字』という
+	パターンの時、改行コードがスペースに変換されないバグを修正。
+
+Thu Dec  7 21:35:06 1995  Yanagihara Yoshiaki  <yosiaki@bsd2.kbnes.nec.co.jp>
+
+	* troff/input.cc (process_input_stack): gcc-2.7.0で変数定義がスコープ
+	違反となってしまう箇所を修正。
+
+Thu Dec  7 21:35:06 1995  Yanagihara Yoshiaki  <yosiaki@bsd2.kbnes.nec.co.jp>
+
+	* jgroffのベースソースをgroff-1.10に変更。
+
+Thu Apr  6 16:56:32 1995  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* devdvi/M.proto-NTT: DNPのpkフォントのチェックサム値が0なので、こ
+	れに合わせてchecksumの値を0に変更。
+
+Mon Apr  3 20:36:37 1995  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* troff/env.cc (possibly_break_line):
+	lineリスト中のkword_space_nodeを調整する処理で、line中にこのノード
+	が含まれていない場合は処理をスキップするようにした(EUCコードを含ま
+	ないroffを処理する場合にはkword_space_nodeは現れないので処理が高速
+	化される)。
+
+Mon Apr  3 20:36:37 1995  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* troff/env.cc (add_char): hwkern、vlowerの初期化はdevice初期化後
+	に一度だけ行えば良いのでenvironmentクラスのコンストラクタでこれを
+	行うように変更。
+
+Sat Apr  1 17:57:23 1995  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* troff/input.cc (mount_on_demand): on demandでマウントされるフォ
+	ント名をデバイスごとのDESCファイルで指定できるように変更。
+	ディレクティブondemandで指定したフォントがon demandでマウントされる。
+
+Fri Mar 31 20:23:43 1995  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* libgroff/font.cc (load): 漢字フォントファイル用にディレクティブ
+	fixedkanjiを追加。これは各文字のメトリックが全て同じである事を指定
+	するもので、fixedkanjiが指定されている場合はcharsetは評価されない
+	ため漢字フォントのロードが速い。
+
+Thu Mar 30 18:20:24 1995  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* troff: node識別を文字列比較で行っていたが高速化のため数値比較に
+	変更した。
+
+Wed Mar 29 20:20:49 1995  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* troff/input.cc: 漢字フォント(MとG)をon demandでマウントするよう
+	に変更。これによって漢字を含まないroffファイルの処理時間が高速化さ
+	れた。
+
+Fri Mar 10 15:34:26 1995  Shigeki Yoshida <shige@theta.iis.u-tokyo.ac.jp>
+
+	* troff/input.cc (process): geqnで、
+
+		.EQ
+		要素 sub 記号
+		.EN
+
+	を処理すると、"illegal token in argument to \Z"となってしまうバグ
+	(\Zシーケンスの引数にEUC文字が来た場合の対応漏れ)を修正。
+
+Mon Feb  6 11:22:33 1995  Yoshio Takaeda <e50110@sakura.kudpc.kyoto-u.ac.jp>
+
+	* troff/input.cc: 行頭禁則文字のEUCコードの一部が不正。
+
+Mon Jan 30 14:02:54 1995  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* バージョン0.97。
+
+Fri Dec 10 14:26:14 1994  Kazutaka YOKOTA <yokota@zodiac.mech.utsunomiya-u.ac.jp>
+
+	* devdvi/M.proto: NTT JTeXとASCII日本語TeX両方のdviファイルを扱えるよう
+	M.protoファイルを変更。
+
+Fri Dec  9 14:26:14 1994  Kazutaka YOKOTA <yokota@zodiac.mech.utsunomiya-u.ac.jp>
+
+	* troff/node.cc: boldfont_list[]にフォント名 B を登録していなかっ
+	たため、dviファイルにゴシック体が出力されていなかった。
+
+Fri Dec  9 14:23:22 1994  Kazutaka YOKOTA <yokota@zodiac.mech.utsunomiya-u.ac.jp>
+
+	* grotty/tty.cc (add_char): EUC文字に対してWCHAR_MODEを設定してい
+	なかったため、tty出力でゴシック体が二重打ちされていなかった。
+
+Fri Dec  9 14:19:33 1994  Kazutaka YOKOTA <yokota@zodiac.mech.utsunomiya-u.ac.jp>
+
+	* devdvi/Makefile.sub: フォントファイル G で、nameディレクティブが
+	`name M'になっている。
+
+Wed Nov 30 13:24:54 1994  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* バージョン0.96。
+
+	* grodvi/dvi.cc: FreeBSD 1.1.5Rのstrcmp(3)では引数にヌルポインタを
+	渡すとコアダンプしてしまうので、これを回避するコードを追加した。
+
+Tue Nov 29 13:52:54 1994  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* troff/input.cc: EUCのスペース文字(0xa1a1)はASCIIのスペース文字と
+	して処理するよう修正。
+
+	* devnippon/createM: JISX0208において文字が未定義の部分については
+	フォントファイルに出力しないよう修正。
+
+Mon Nov 28 18:15:31 1994  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* grodvi/dvi.cc: grodviを日本語化した。
+
+Fri Nov 25 15:39:05 1994  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* troff/env.cc: EUC文字で始まる行に対して均等割り付けが行われた場
+	合、行頭に余分な空白が入る事があったのでこれを修正した。
+
+Fri Nov 18 20:19:55 1994  Masubuchi Toshimichi <tmasu@st.rim.or.jp>
+
+	* devnippon/createM.c: createMの終了ステータスが不定になるため、
+	makeが終了してしまう。createMの終了ステータスが0になるよう修正。
+
+	* devnippon/Makefile.sub: PATH環境変数にカレントディレクトリが含ま
+	れていない場合、devnippon/Mをmakeする時点でcreateMが見つからずmake
+	エラーになるバグを修正。
+
+Thu Nov 17 17:11:26 1994  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* devnippon/createM.c: gets()をfgets()に変更。
+
+Sat Nov 12 13:38:19 1994  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* バージョン0.95。
+
+	* troff/env.cc: .stt リクエストを追加(ローカルなマニュアル書式に合
+	わせるため -> このリクエストは非公開)。
+
+	* troff/input.cc (init_charset_table): ASCIIの行頭禁則文字として
+	,:;>}を追加した。
+
+	* EUCフォントファイルは、make時にツールによって生成するよう変更。
+	これによりpatchサイズがかなり小さくなった。
+
+Fri Nov 11 20:53:00 1994  Kitagawa Toshiyuki  <kitagawa@bsd2.kbnes.nec.co.jp>
+
+	* troff/env.cc (add_char): <EUC文字> + <ASCII文字>の場合、間に入れ
+	る空白は禁則に違反しないかぎりブレーク可能な空白が入るよう修正した。
+
+
+Tue Oct 25 04:46:09 1994  Kitagawa Toshiyuki  (kitagawa@bsd2.kbnes.nec.co.jp)
+
+	* バージョン0.94。
+
+	* libdriver/input.cc (do_file): -Tlatin1でEUCではない文字コードを
+	EUCと判断してしまうバグを修正。
+
+Mon Oct 24 07:16:19 1994  Kitagawa Toshiyuki  (kitagawa@bsd2.kbnes.nec.co.jp)
+
+	* troff/node.cc (is_boldfont): FreeBSD 1.1.5で、ゼロ番地参照のためコ
+	アダンプするバグを修正。
+
+	* indxbib/dirnamemax.c: FreeBSD 1.1.5はpathconf()を持っていないので
+	_POSIX_VERSIONをundefした。
+
+	* バージョン0.93。
+
+	* geqnを日本語化した。
+
+	* devps/DESCのwcharkernを設定すると行頭に空白が入ってしまうバグの
+	修正方法を変更。
+
+Sat Oct 22 08:19:15 1994  Kitagawa Toshiyuki  (kitagawa@bsd2.kbnes.nec.co.jp)
+
+	* バージョン0.90。
+
+	* xtotroffを日本語化。
+
+Fri Oct 21 05:33:02 1994  Kitagawa Toshiyuki  (kitagawa@bsd2.kbnes.nec.co.jp)
+
+	* devps/DESCのwcharkernを設定すると行頭に空白が入ってしまう事があ
+	ったので、これを修正。
+
+	* pre-releaseバージョン。
+
+	* gxditviewを日本語化した(フォントメトリックの取り出しがいい加減)。
+
+Thu Oct 20 05:23:09 1994  Kitagawa Toshiyuki  (kitagawa@bsd2.kbnes.nec.co.jp)
+
+	* フォント番号3にボールド体以外のフォントをマウントした場合、漢字フォ
+	ントがゴシック体になってしまうバグを修正。
+
+Wed Oct 19 06:48:55 1994  Kitagawa Toshiyuki  (kitagawa@bsd2.kbnes.nec.co.jp)
+
+	* betaバージョン。
+
+Tue Oct 18 05:02:59 1994  Kitagawa Toshiyuki  (kitagawa@bsd2.kbnes.nec.co.jp)
+
+	* pic: 
+	gpicを日本語対応した。
+
+	* tbl: 
+	gtblを日本語対応した。
+
+	* troff/troff: 
+	Times-Bold以外のボールド体がカレントフォントの時、漢字フォントがゴ
+	シックに切り替わらないバグを修正。
+
+	* troff/troff: 
+	DESCにディレクティブwcharkernを追加し、ASCII文字とEUC文字の間に、
+	指定したunit数だけbreak不可能な空白を入れるようにした。
+
+	* troff/troff: 
+	DESCにディレクティブlowerwcharを追加し、ASCII文字に対してEUC文字を、
+	指定したunit数だけ下げるようにした(ASCII文字が落ち込んで見えるため)。
+	
+Fri Oct 14 08:29:06 1994  Kitagawa Toshiyuki  (kitagawa@bsd2.kbnes.nec.co.jp)
+
+	* aplahバージョン。
diff -uNr groff-1.19.1.orig/Makefile.in groff-1.19.1/Makefile.in
--- groff-1.19.1.orig/Makefile.in	2004-04-08 00:33:39.000000000 +0900
+++ groff-1.19.1/Makefile.in	2005-02-23 16:33:26.214708864 +0900
@@ -148,7 +148,11 @@
 # directory will be always added.
 # `troffrc' and `troffrc-end' (and `eqnrc') are searched neither in the
 # current nor in the home directory.
+ifeq (,$(extratmacdirs))
 tmacpath=$(systemtmacdir)$(RT_SEP)$(localtmacdir)$(RT_SEP)$(tmacdir)
+else
+tmacpath=$(systemtmacdir)$(SEP)$(localtmacdir)$(SEP)$(tmacdir)$(SEP)$(extratmacdirs)
+endif
 
 # `sys_tmac_prefix' is prefix (if any) for system macro packages.
 sys_tmac_prefix=@sys_tmac_prefix@
@@ -290,6 +294,8 @@
 # -DRETSIGTYPE=int		if signal handlers return int not void	
 # -DIS_EBCDIC_HOST		if the host's encoding is EBCDIC
 # -DPAGEA4			if the the printer's page size is A4
+# -DNIPPON			enable Japanese extension
+# -DHAVE_LANGINFO_CODESET	if you have nl_langinfo(CODESET)
 DEFINES=@DEFS@
 
 # Include
@@ -478,8 +484,10 @@
   font/devhtml
 ALLTTYDEVDIRS=\
   font/devascii \
+  font/devascii8 \
   font/devlatin1 \
   font/devutf8 \
+  font/devnippon \
   font/devcp1047
 OTHERDIRS=\
   man \
@@ -525,7 +533,7 @@
 	fi
 
 do=all
-dodirs=$(ALLDIRS) dot
+dodirs=$(DISTDIRS)
 # Default target for subdir_Makefile
 subdir=src/roff/troff
 
diff -uNr groff-1.19.1.orig/README.jp groff-1.19.1/README.jp
--- groff-1.19.1.orig/README.jp	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/README.jp	2005-02-23 16:32:33.190769728 +0900
@@ -0,0 +1,142 @@
+
+                日本語対応版 groff-1.12 (jgroff-0.101)
+
+
+                                           北川 信亨 (Kitagawa Toshiyuki)
+                                                     tm-kita@kh.rim.or.jp
+
+                                           柳原 良亮 (Yanagihara Yoshiaki)
+                                                      yochi@debian.or.jp
+
+ GNUのroffフォーマッタgroff(version 1.12)の日本語対応を行ないました。
+ 上位互換となっていますので、日本語を含まないroffデータはオリジナルど
+おりの動作になります。日本語化に関する修正部分についての著作権はGNU
+General Public License Version 2 に従います(詳細はCOPYINGを御覧ください)。
+
+ 日本語groff(jgroff)の現バージョンは0.101(最終β版)です。このバージョン
+では以下のモジュールが日本語化されています。
+
+	groff	  ...	groffドライバ
+ 	gtroff	  ...	groff本体
+	grotty	  ...	端末用ポストプロセッサ
+	grops	  ...	PostScript用ポストプロセッサ
+        grohtml   ...   HTML用ポストプロセッサ(Thanks HANATAKA Shinya
+                                               <hanataka@abyss.rim.or.jp>)
+	grodvi	  ...	DVI用ポストプロセッサ (NTT JTeX or ASCII日本語TeX)
+	gxditview ...	Xウィンドウ用ポストプロセッサ
+	gtbl	  ...	tblマクロ用プリプロセッサ
+	gpic	  ...	picマクロ用プリプロセッサ
+	geqn	  ...	eqnマクロ用プリプロセッサ
+	xtotroff  ...	Xのフォントからgroff用フォントファイルを作成す
+	            	るツール
+
+＃ lj4ポストプロセッサ、bib関連のコマンドは日本語未対応です。
+
+
+◎ インストール
+
+ 以下の環境でmake出来ることを確認しています。
+
+	☆  FreeBSD 2.1.0-RELEASE
+	    XFree86-3.1.2, gcc 2.6.3
+
+	☆  Debian GNU/Linux 2.2
+
+	☆  NEC EWS/4800/310
+	    SVR4.2 Release9.1 Rev.B, X11R5, gcc 2.6.0
+
+ (1) オリジナルと同様configureを実行した後、make & installして下さい。
+    詳しくはINSTALLを参照してください。
+
+    *) grodviはNTT JTeX形式またはASCII日本語TeX形式のDVIファイルをサポー
+       トしています。groffが出力するDVIファイルをASCII日本語TeX形式に
+       したい場合はconfigure --JTeX=ASCIIとしてください。
+       --JTeXオプションを指定しなかった場合はNTT JTeX形式になります。
+
+ (2) groffのmakeの後、gxditview(groffのXウィンドウ用ポストプロセッサ)
+    をmakeします。トップディレクトリ直下のxditviewへcdして、
+
+	% xmkmf
+	% make depend
+	% make all
+	% make install install.man
+
+    で、インストール完了です。
+
+
+◎ 使い方
+
+ groffの-Tオプションに-Tnippon(端末表示)を追加した以外はオリジナルのま
+まです。
+以下は使用例。
+
+ (１)  groff -Tnippon -man groff.jman
+
+ 日本語を含むroffファイル(groff.jman)をmanマクロを使ってフォーマットし、
+端末に表示します。
+ 
+ (２)  groff -Tps -man groff.jman
+
+ 日本語を含むroffファイルをフォーマットし、PostScriptに変換します。
+
+ (３)  groff -TX100 -man groff.jman
+
+ 日本語を含むroffファイルをフォーマットし、Xウィンドウに表示します。
+
+ (４)  groff -Tdvi -man groff.jman
+
+ 日本語を含むroffファイルをフォーマットし、DVIファイルを出力します。
+
+
+◎ 日本語化について
+
+・ 日本語文字コードは日本語EUC(のコードセット1)のみサポートしています。
+
+・ 日本語フォントについては、カレントフォントがボールド体の時はゴシッ
+   ク体に、それ以外のフォント(ローマン、イタリック、イタリックボールド
+   等)がカレントフォントの時は明朝体に、自動的に切り替わります。日本語
+   フォントを直接指定することは出来ません。
+
+   (注) フォントファイル名が'B'で終っているフォント(B、TB、HNBなど)を
+        ボールドフォントとしています。
+
+・ 行頭、および行末禁則に対応しています。それぞれの禁則文字は、
+
+   行頭禁則文字:	 、 。，．・：；？！）〕］｝」』】
+			ぁぃぅぇぉっゃゅょァィゥェォッャュョ
+			. ? ! " ' ) ] * , : ; > }
+   行末禁則文字:	（ 〔［｛「『【
+
+   を定義しています。
+
+・ -Tpsを指定した場合、EUC文字とASCII文字の間には、幅の狭い空白が自動
+   的に挿入されます。この空白の幅はdevps/DESCのwcharkernで指定します。
+   unit単位です。0を指定すると空白は挿入されなくなります。
+
+・ -Tpsを指定した場合、EUC文字はASCII文字に対して少し下げて出力されま
+   す(そのままだとASCII文字が落ち込んで見えるため)。この下げ幅は
+   devps/DESCのlowerwcharで指定します。unit単位です。0を指定すると字下
+   げは行なわれません。
+
+・ オリジナルでは改行コードは無条件にスペース文字に変換されますが、EUC
+   文字で囲まれた改行コードはスペースに変換せず無視するようにしました。
+
+・ EUCのスペース文字(0xa1a1)はASCIIのスペース文字として処理されます。
+
+
+◎ 謝辞
+
+grodviのASCII日本語TeX対応は、宇都宮大学の横田さんが行なってくださいま
+した。grohtmlの日本語(EUC)対応は、花嵩信哉さんが行ってくれました。
+また、多くの方からバグに関する報告、修正イメージを送って頂きました。
+御協力くださった皆様にはとても感謝しております。有難うございました。
+
+
+◎ お願い
+
+現バージョンではlj4ポストプロセッサ、bib関連のコマンド群が日本語化され
+ておりません。これらの日本語化を行ってくださる方を募集致しております。
+ぜひ御協力ください。また、日本語対応groffに関して御意見、御希望等を
+是非お聞かせください。今後の参考にさせて頂きます(もちろんバグ報告も
+歓迎です！)。
+以上はE-Mailにて、tm-kita@kh.rim.or.jp宛にお送りください。
diff -uNr groff-1.19.1.orig/aclocal.m4 groff-1.19.1/aclocal.m4
--- groff-1.19.1.orig/aclocal.m4	2003-12-10 02:39:30.000000000 +0900
+++ groff-1.19.1/aclocal.m4	2005-02-23 16:36:58.326462976 +0900
@@ -615,6 +615,40 @@
    AC_MSG_RESULT([$tmac_wrap])
    AC_SUBST([tmac_wrap])])
 
+dnl codeset.m4 from gettext, by Bruno Haible.
+dnl
+AC_DEFUN(GROFF_LANGINFO_CODESET,
+[AC_CACHE_CHECK([for nl_langinfo and CODESET], groff_cv_langinfo_codeset,
+   [AC_TRY_LINK([#include <langinfo.h>],
+     [char* cs = nl_langinfo(CODESET);],
+     groff_cv_langinfo_codeset=yes,
+     groff_cv_langinfo_codeset=no)])
+ if test $groff_cv_langinfo_codeset = yes; then
+   AC_DEFINE(HAVE_LANGINFO_CODESET, 1,
+     [Define if you have <langinfo.h> and nl_langinfo(CODESET).])
+ fi
+])dnl
+dnl
+dnl Support Japanese Code (EUC)
+dnl
+AC_DEFUN(GROFF_NIPPON,
+[AC_MSG_CHECKING([enable japanese extension])
+ AC_ARG_ENABLE(japanese,
+   AC_HELP_STRING([--enable-japanese],
+                  [Enable Japanese extension]),
+   [japanese=$enableval],
+   [japanese=no])
+ if test "$japanese" = yes; then
+   AC_MSG_RESULT([yes])
+   AC_DEFINE([NIPPON], 1,
+     [Define if you want to use Japanese extension.])
+   GROFF_LANGINFO_CODESET
+ else
+   AC_MSG_RESULT([no])
+ fi
+])dnl
+dnl
+
 AC_DEFUN([GROFF_G],
   [AC_MSG_CHECKING([for existing troff installation])
    if test "x`(echo .tm '|n(.g' | tr '|' '\\\\' | troff -z -i 2>&1) 2>/dev/null`" = x0; then
@@ -674,7 +708,7 @@
       AC_DEFINE(IS_EBCDIC_HOST, 1,
 	[Define if the host's encoding is EBCDIC.])],
      [groff_cv_ebcdic="no"
-     TTYDEVDIRS="font/devascii font/devlatin1"
+     TTYDEVDIRS="font/devascii font/devlatin1 font/devascii8 font/devnippon"
      OTHERDEVDIRS="font/devlj4 font/devlbp"
      AC_MSG_RESULT([no])])
    AC_SUBST([TTYDEVDIRS])
diff -uNr groff-1.19.1.orig/configure.ac groff-1.19.1/configure.ac
--- groff-1.19.1.orig/configure.ac	2003-12-30 13:03:01.000000000 +0900
+++ groff-1.19.1/configure.ac	2005-02-23 16:32:33.191769576 +0900
@@ -89,6 +89,7 @@
 GROFF_TMAC
 GROFF_TARGET_PATH_SEPARATOR
 GROFF_HTML_PROGRAMS
+GROFF_NIPPON
 GROFF_PNMTOPS_NOSETPAGE
 
 AC_CONFIG_FILES([stamp-h], [echo timestamp > stamp-h])
diff -uNr groff-1.19.1.orig/font/devX100/DESC groff-1.19.1/font/devX100/DESC
--- groff-1.19.1.orig/font/devX100/DESC	2000-02-06 18:35:04.000000000 +0900
+++ groff-1.19.1/font/devX100/DESC	2005-02-23 16:32:33.191769576 +0900
@@ -1,5 +1,6 @@
 styles R I B BI
-fonts 6 0 0 0 0 0 S
+fonts 8 0 0 0 0 0 S M G
+ondemand M G
 sizes 8 10 12 14 18 24 0
 res 100
 X11
diff -uNr groff-1.19.1.orig/font/devX100/M.header groff-1.19.1/font/devX100/M.header
--- groff-1.19.1.orig/font/devX100/M.header	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devX100/M.header	2005-02-23 16:32:33.192769424 +0900
@@ -0,0 +1,3 @@
+name M
+spacewidth 16
+fixedkanji 16,14,2 0
diff -uNr groff-1.19.1.orig/font/devX100/Makefile.sub groff-1.19.1/font/devX100/Makefile.sub
--- groff-1.19.1.orig/font/devX100/Makefile.sub	2000-02-06 18:35:06.000000000 +0900
+++ groff-1.19.1/font/devX100/Makefile.sub	2005-02-23 16:32:33.191769576 +0900
@@ -1,2 +1,13 @@
 DEV=X100
-DEVFILES=DESC TR TI TB TBI CR CI CB CBI HR HI HB HBI NR NI NB NBI S
+DEVFILES=DESC TR TI TB TBI CR CI CB CBI HR HI HB HBI NR NI NB NBI S M G
+CLEANADD=M G
+
+M: M.header
+	@echo Making M
+	@-rm -f M
+	@(cat $(srcdir)/M.header; echo charset) > M
+
+G: M
+	@echo Making G
+	@-rm -f G
+	@sed -e 's/name M/name G/' M > G
diff -uNr groff-1.19.1.orig/font/devX100-12/DESC groff-1.19.1/font/devX100-12/DESC
--- groff-1.19.1.orig/font/devX100-12/DESC	2000-02-06 18:35:07.000000000 +0900
+++ groff-1.19.1/font/devX100-12/DESC	2005-02-23 16:32:33.192769424 +0900
@@ -1,5 +1,6 @@
 styles R I B BI
-fonts 6 0 0 0 0 0 S
+fonts 8 0 0 0 0 0 S M G
+ondemand M G
 sizes 8 10 12 14 18 24 0
 res 100
 X11
diff -uNr groff-1.19.1.orig/font/devX100-12/M.header groff-1.19.1/font/devX100-12/M.header
--- groff-1.19.1.orig/font/devX100-12/M.header	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devX100-12/M.header	2005-02-23 16:32:33.192769424 +0900
@@ -0,0 +1,3 @@
+name M
+spacewidth 16
+fixedkanji 16,14,2 0
diff -uNr groff-1.19.1.orig/font/devX100-12/Makefile.sub groff-1.19.1/font/devX100-12/Makefile.sub
--- groff-1.19.1.orig/font/devX100-12/Makefile.sub	2000-02-06 18:35:07.000000000 +0900
+++ groff-1.19.1/font/devX100-12/Makefile.sub	2005-02-23 16:32:33.192769424 +0900
@@ -1,2 +1,14 @@
 DEV=X100-12
-DEVFILES=DESC TR TI TB TBI CR CI CB CBI HR HI HB HBI NR NI NB NBI S
+DEVFILES=DESC TR TI TB TBI CR CI CB CBI HR HI HB HBI NR NI NB NBI S M G
+CLEANADD=M G
+
+M: M.header
+	@echo Making M
+	@-rm -f M
+	@(cat $(srcdir)/M.header; echo charset) > M
+
+G: M
+	@echo Making G
+	@-rm -f G
+	@sed -e 's/name M/name G/' M > G
+
diff -uNr groff-1.19.1.orig/font/devX75/DESC groff-1.19.1/font/devX75/DESC
--- groff-1.19.1.orig/font/devX75/DESC	2000-02-06 18:35:09.000000000 +0900
+++ groff-1.19.1/font/devX75/DESC	2005-02-23 16:32:33.192769424 +0900
@@ -1,5 +1,6 @@
 styles R I B BI
-fonts 6 0 0 0 0 0 S
+fonts 8 0 0 0 0 0 S M G
+ondemand M G
 sizes 8 10 12 14 18 24 0
 res 75
 X11
diff -uNr groff-1.19.1.orig/font/devX75/M.header groff-1.19.1/font/devX75/M.header
--- groff-1.19.1.orig/font/devX75/M.header	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devX75/M.header	2005-02-23 16:32:33.193769272 +0900
@@ -0,0 +1,3 @@
+name M
+spacewidth 11
+fixedkanji 11,9,2 0
diff -uNr groff-1.19.1.orig/font/devX75/Makefile.sub groff-1.19.1/font/devX75/Makefile.sub
--- groff-1.19.1.orig/font/devX75/Makefile.sub	2000-02-06 18:35:10.000000000 +0900
+++ groff-1.19.1/font/devX75/Makefile.sub	2005-02-23 16:32:33.193769272 +0900
@@ -1,2 +1,13 @@
 DEV=X75
-DEVFILES=DESC TR TI TB TBI CR CI CB CBI HR HI HB HBI NR NI NB NBI S
+DEVFILES=DESC TR TI TB TBI CR CI CB CBI HR HI HB HBI NR NI NB NBI S M G
+CLEANADD=M G
+
+M: M.header
+	@echo Making M
+	@-rm -f M
+	@(cat $(srcdir)/M.header; echo charset) > M
+
+G: M
+	@echo Making G
+	@-rm -f G
+	@sed -e 's/name M/name G/' M > G
diff -uNr groff-1.19.1.orig/font/devX75-12/DESC groff-1.19.1/font/devX75-12/DESC
--- groff-1.19.1.orig/font/devX75-12/DESC	2000-02-06 18:35:11.000000000 +0900
+++ groff-1.19.1/font/devX75-12/DESC	2005-02-23 16:32:33.193769272 +0900
@@ -1,5 +1,6 @@
 styles R I B BI
-fonts 6 0 0 0 0 0 S
+fonts 8 0 0 0 0 0 S M G
+ondemand M G
 sizes 8 10 12 14 18 24 0
 res 75
 X11
diff -uNr groff-1.19.1.orig/font/devX75-12/M.header groff-1.19.1/font/devX75-12/M.header
--- groff-1.19.1.orig/font/devX75-12/M.header	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devX75-12/M.header	2005-02-23 16:32:33.193769272 +0900
@@ -0,0 +1,3 @@
+name M
+spacewidth 11
+fixedkanji 11,9,2 0
diff -uNr groff-1.19.1.orig/font/devX75-12/Makefile.sub groff-1.19.1/font/devX75-12/Makefile.sub
--- groff-1.19.1.orig/font/devX75-12/Makefile.sub	2000-02-06 18:35:12.000000000 +0900
+++ groff-1.19.1/font/devX75-12/Makefile.sub	2005-02-23 16:32:33.193769272 +0900
@@ -1,2 +1,13 @@
 DEV=X75-12
-DEVFILES=DESC TR TI TB TBI CR CI CB CBI HR HI HB HBI NR NI NB NBI S
+DEVFILES=DESC TR TI TB TBI CR CI CB CBI HR HI HB HBI NR NI NB NBI S M G
+CLEANADD=M G
+
+M: M.header
+	@echo Making M
+	@-rm -f M
+	@(cat $(srcdir)/M.header; echo charset) > M
+
+G: M
+	@echo Making G
+	@-rm -f G
+	@sed -e 's/name M/name G/' M > G
diff -uNr groff-1.19.1.orig/font/devascii8/DESC.proto groff-1.19.1/font/devascii8/DESC.proto
--- groff-1.19.1.orig/font/devascii8/DESC.proto	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devascii8/DESC.proto	2005-02-23 16:32:33.193769272 +0900
@@ -0,0 +1,8 @@
+res 240
+hor 24
+vert 40
+unitwidth 10
+sizes 10 0
+fonts 4 R I B BI
+tcommand
+postpro grotty
diff -uNr groff-1.19.1.orig/font/devascii8/Makefile.sub groff-1.19.1/font/devascii8/Makefile.sub
--- groff-1.19.1.orig/font/devascii8/Makefile.sub	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devascii8/Makefile.sub	2005-02-23 16:32:33.194769120 +0900
@@ -0,0 +1,31 @@
+DEV=ascii8
+FONTS=R I B BI
+DEVFILES=$(FONTS) DESC
+CLEANADD=$(FONTS) DESC
+
+RES=240
+CPI=10
+LPI=6
+
+$(FONTS): R.proto
+	@echo Making $@
+	@-rm -f $@
+	@(charwidth=`expr $(RES) / $(CPI)` ; \
+ 	 sed -e "s/^name [A-Z]*$$/name $@/" \
+	     -e "s/^\\([^	]*\\)	[0-9]+	/\\1	$$charwidth	/" \
+	     -e "s/^spacewidth [0-9]+$$/spacewidth $$charwidth/" \
+	     -e "s/^internalname .*$$/internalname $@/" \
+	     -e "/^internalname/s/BI/3/" \
+	     -e "/^internalname/s/B/2/" \
+	     -e "/^internalname/s/I/1/" \
+	     -e "/^internalname .*[^ 0-9]/d" \
+	     $(srcdir)/R.proto >$@)
+
+DESC: DESC.proto
+	@echo Making $@
+	@-rm -f $@
+	@sed -e "s/^res .*$$/res $(RES)/" \
+	    -e "s/^hor .*$$/hor `expr $(RES) / $(CPI)`/" \
+	    -e "s/^vert .*$$/vert `expr $(RES) / $(LPI)`/" \
+	    -e "s/^fonts .*$$/fonts `set $(FONTS); echo $$#` $(FONTS)/" \
+	    $(srcdir)/DESC.proto >$@
diff -uNr groff-1.19.1.orig/font/devascii8/R.proto groff-1.19.1/font/devascii8/R.proto
--- groff-1.19.1.orig/font/devascii8/R.proto	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devascii8/R.proto	2005-02-23 16:32:33.194769120 +0900
@@ -0,0 +1,262 @@
+name R
+internalname 0
+spacewidth 24
+charset
+!	24	0	0041
+"	24	0	0042
+dq	"
+lq	"
+rq	"
+#	24	0	0043
+sh	"
+$	24	0	0044
+Do	"
+%	24	0	0045
+&	24	0	0046
+'	24	0	0047
+aa	"
+fm	"
+aq	"
+cq	"
+(	24	0	0050
+)	24	0	0051
+*	24	0	0052
+**	"
++	24	0	0053
+pl	"
+,	24	0	0054
+\-	24	0	0055
+hy	"
+-	"
+mi	"
+en	"
+.	24	0	0056
+/	24	0	0057
+sl	"
+f/	"
+0	24	0	0060
+1	24	0	0061
+2	24	0	0062
+3	24	0	0063
+4	24	0	0064
+5	24	0	0065
+6	24	0	0066
+7	24	0	0067
+8	24	0	0070
+9	24	0	0071
+:	24	0	0072
+;	24	0	0073
+<	24	0	0074
+la	"
+fo	"
+=	24	0	0075
+eq	"
+>	24	0	0076
+ra	"
+fc	"
+?	24	0	0077
+@	24	0	0100
+at	"
+A	24	0	0101
+*A	"
+B	24	0	0102
+*B	"
+C	24	0	0103
+D	24	0	0104
+E	24	0	0105
+*E	"
+F	24	0	0106
+G	24	0	0107
+H	24	0	0110
+*Y	"
+I	24	0	0111
+*I	"
+J	24	0	0112
+K	24	0	0113
+*K	"
+L	24	0	0114
+M	24	0	0115
+*M	"
+N	24	0	0116
+*N	"
+O	24	0	0117
+ci	"
+*O	"
+P	24	0	0120
+*R	"
+Q	24	0	0121
+R	24	0	0122
+S	24	0	0123
+T	24	0	0124
+*T	"
+U	24	0	0125
+V	24	0	0126
+W	24	0	0127
+X	24	0	0130
+*X	"
+Y	24	0	0131
+*U	"
+Z	24	0	0132
+*Z	"
+[	24	0	0133
+lB	"
+\	24	0	0134
+rs	"
+]	24	0	0135
+rB	"
+a^	24	0	0136
+^	"
+ha	"
+_	24	0	0137
+ru	"
+ul	"
+`	24	0	0140
+oq	"
+ga	"
+a	24	0	0141
+b	24	0	0142
+c	24	0	0143
+d	24	0	0144
+e	24	0	0145
+f	24	0	0146
+g	24	0	0147
+h	24	0	0150
+i	24	0	0151
+.i	"
+j	24	0	0152
+k	24	0	0153
+l	24	0	0154
+m	24	0	0155
+n	24	0	0156
+o	24	0	0157
+*o	"
+p	24	0	0160
+q	24	0	0161
+r	24	0	0162
+s	24	0	0163
+t	24	0	0164
+u	24	0	0165
+v	24	0	0166
+w	24	0	0167
+x	24	0	0170
+mu	"
+y	24	0	0171
+z	24	0	0172
+lC	24	0	0173
+{	"
+ba	24	0	0174
+or	"
+bv	"
+br	"
+|	"
+lb	"
+lc	"
+lf	"
+lk	"
+lt	"
+rb	"
+rc	"
+rf	"
+rk	"
+rt	"
+rC	24	0	0175
+}	"
+a~	24	0	0176
+~	"
+ap	"
+ti	"
+char161	24	0	0241
+char162	24	0	0242
+char163	24	0	0243
+char164	24	0	0244
+char165	24	0	0245
+char166	24	0	0246
+char167	24	0	0247
+char168	24	0	0250
+char169	24	0	0251
+char170	24	0	0252
+char171	24	0	0253
+char172	24	0	0254
+char173	24	0	0255 
+char174	24	0	0256
+char175	24	0	0257
+char176	24	0	0260
+char177	24	0	0261
+char178	24	0	0262
+char179	24	0	0263
+char180	24	0	0264
+char181	24	0	0265
+char182	24	0	0266
+char183	24	0	0267
+char184	24	0	0270
+char185	24	0	0271
+char186	24	0	0272
+char187	24	0	0273
+char188	24	0	0274
+char189	24	0	0275
+char190	24	0	0276
+char191	24	0	0277
+char192	24	0	0300
+char193	24	0	0301
+char194	24	0	0302
+char195	24	0	0303
+char196	24	0	0304
+char197	24	0	0305
+char198	24	0	0306
+char199	24	0	0307
+char200	24	0	0310
+char201	24	0	0311
+char202	24	0	0312
+char203	24	0	0313
+char204	24	0	0314
+char205	24	0	0315
+char206	24	0	0316
+char207	24	0	0317
+char208	24	0	0320
+char209	24	0	0321
+char210	24	0	0322
+char211	24	0	0323
+char212	24	0	0324
+char213	24	0	0325
+char214	24	0	0326
+char215	24	0	0327
+char216	24	0	0330
+char217	24	0	0331
+char218	24	0	0332
+char219	24	0	0333
+char220	24	0	0334
+char221	24	0	0335
+char222	24	0	0336
+char223	24	0	0337
+char224	24	0	0340
+char225	24	0	0341
+char226	24	0	0342
+char227	24	0	0343
+char228	24	0	0344
+char229	24	0	0345
+char230	24	0	0346
+char231	24	0	0347
+char232	24	0	0350
+char233	24	0	0351
+char234	24	0	0352
+char235	24	0	0353
+char236	24	0	0354
+char237	24	0	0355
+char238	24	0	0356
+char239	24	0	0357
+char240	24	0	0360
+char241	24	0	0361
+char242	24	0	0362
+char243	24	0	0363
+char244	24	0	0364
+char245	24	0	0365
+char246	24	0	0366
+char247	24	0	0367
+char248	24	0	0370
+char249	24	0	0371
+char250	24	0	0372
+char251	24	0	0373
+char252	24	0	0374
+char253	24	0	0375
+char254	24	0	0376
+char255	24	0	0377
diff -uNr groff-1.19.1.orig/font/devdvi/FixMetric.sed groff-1.19.1/font/devdvi/FixMetric.sed
--- groff-1.19.1.orig/font/devdvi/FixMetric.sed	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devdvi/FixMetric.sed	2005-02-23 16:32:33.194769120 +0900
@@ -0,0 +1,77 @@
+s/1006514,.*0x212b$/370845,815360,145600	1	0x212b/
+s/1006514,.*0x212c$/370845,815360,145600	1	0x212c/
+s/1006514,.*0x2126$/370845,815360,145600	1	0x2126/
+s/1006514,.*0x2127$/370845,815360,145600	1	0x2127/
+s/1006514,.*0x2128$/370845,815360,145600	1	0x2128/
+s/1006514,.*0x212a$/370845,815360,145600	1	0x212a/
+s/1006514,.*0x212d$/370845,815360,145600	1	0x212d/
+s/1006514,.*0x212e$/370845,815360,145600	1	0x212e/
+s/1006514,.*0x213e$/370845,815360,145600	1	0x213e/
+s/1006514,.*0x2142$/370845,815360,145600	1	0x2142/
+s/1006514,.*0x2143$/370845,815360,145600	1	0x2143/
+s/1006514,.*0x2146$/370845,815360,145600	1	0x2146/
+s/1006514,.*0x2147$/370845,815360,145600	1	0x2147/
+s/1006514,.*0x2124$/370845,815360,145600	1	0x2124/
+s/1006514,.*0x2125$/370845,815360,145600	1	0x2125/
+s/1006514,.*0x214b$/528496,815360,145600	1	0x214b/
+s/1006514,.*0x214d$/528496,815360,145600	1	0x214d/
+s/1006514,.*0x214f$/528496,815360,145600	1	0x214f/
+s/1006514,.*0x2151$/528496,815360,145600	1	0x2151/
+s/1006514,.*0x2153$/528496,815360,145600	1	0x2153/
+s/1006514,.*0x2155$/528496,815360,145600	1	0x2155/
+s/1006514,.*0x2157$/528496,815360,145600	1	0x2157/
+s/1006514,.*0x2159$/528496,815360,145600	1	0x2159/
+s/1006514,.*0x215b$/528496,815360,145600	1	0x215b/
+s/1006514,.*0x2129$/528496,815360,145600	1	0x2129/
+s/1006514,.*0x212f$/528496,815360,145600	1	0x212f/
+s/1006514,.*0x2130$/528496,815360,145600	1	0x2130/
+s/1006514,.*0x2133$/528496,815360,145600	1	0x2133/
+s/1006514,.*0x2135$/528496,815360,145600	1	0x2135/
+s/1006514,.*0x2148$/528496,815360,145600	1	0x2148/
+s/1006514,.*0x2149$/528496,815360,145600	1	0x2149/
+s/1006514,.*0x216b$/528496,815360,145600	1	0x216b/
+s/1006514,.*0x216c$/528496,815360,145600	1	0x216c/
+s/1006514,.*0x216d$/528496,815360,145600	1	0x216d/
+s/1006514,.*0x2178$/528496,815360,145600	1	0x2178/
+s/1006514,.*0x214a$/528496,815360,145600	1	0x214a/
+s/1006514,.*0x214c$/528496,815360,145600	1	0x214c/
+s/1006514,.*0x214e$/528496,815360,145600	1	0x214e/
+s/1006514,.*0x2150$/528496,815360,145600	1	0x2150/
+s/1006514,.*0x2152$/528496,815360,145600	1	0x2152/
+s/1006514,.*0x2154$/528496,815360,145600	1	0x2154/
+s/1006514,.*0x2156$/528496,815360,145600	1	0x2156/
+s/1006514,.*0x2158$/528496,815360,145600	1	0x2158/
+s/1006514,.*0x215a$/528496,815360,145600	1	0x215a/
+s/1006514,.*0x2122$/528496,815360,145600	1	0x2122/
+s/1006514,.*0x2123$/528496,815360,145600	1	0x2123/
+s/1006514,.*0x2136$/783741,815360,145600	1	0x2136/
+s/1006514,.*0x2137$/783741,815360,145600	1	0x2137/
+s/1006514,.*0x2139$/783741,815360,145600	1	0x2139/
+s/1006514,.*0x2168$/783741,815360,145600	1	0x2168/
+s/1006514,.*0x2169$/783741,815360,145600	1	0x2169/
+s/1006514,.*0x216a$/783741,815360,145600	1	0x216a/
+s/1006514,.*0x2170$/783741,815360,145600	1	0x2170/
+s/1006514,.*0x2171$/783741,815360,145600	1	0x2171/
+s/1006514,.*0x2172$/783741,815360,145600	1	0x2172/
+s/1006514,.*0x2421$/783741,815360,145600	1	0x2421/
+s/1006514,.*0x2423$/783741,815360,145600	1	0x2423/
+s/1006514,.*0x2425$/783741,815360,145600	1	0x2425/
+s/1006514,.*0x2427$/783741,815360,145600	1	0x2427/
+s/1006514,.*0x2429$/783741,815360,145600	1	0x2429/
+s/1006514,.*0x2443$/783741,815360,145600	1	0x2443/
+s/1006514,.*0x2463$/783741,815360,145600	1	0x2463/
+s/1006514,.*0x2465$/783741,815360,145600	1	0x2465/
+s/1006514,.*0x2467$/783741,815360,145600	1	0x2467/
+s/1006514,.*0x246e$/783741,815360,145600	1	0x246e/
+s/1006514,.*0x2521$/783741,815360,145600	1	0x2521/
+s/1006514,.*0x2523$/783741,815360,145600	1	0x2523/
+s/1006514,.*0x2525$/783741,815360,145600	1	0x2525/
+s/1006514,.*0x2527$/783741,815360,145600	1	0x2527/
+s/1006514,.*0x2529$/783741,815360,145600	1	0x2529/
+s/1006514,.*0x2543$/783741,815360,145600	1	0x2543/
+s/1006514,.*0x2563$/783741,815360,145600	1	0x2563/
+s/1006514,.*0x2565$/783741,815360,145600	1	0x2565/
+s/1006514,.*0x2567$/783741,815360,145600	1	0x2567/
+s/1006514,.*0x256e$/783741,815360,145600	1	0x256e/
+s/1006514,.*0x2575$/783741,815360,145600	1	0x2575/
+s/1006514,.*0x2576$/783741,815360,145600	1	0x2576/
diff -uNr groff-1.19.1.orig/font/devdvi/M.proto-ASCII groff-1.19.1/font/devdvi/M.proto-ASCII
--- groff-1.19.1.orig/font/devdvi/M.proto-ASCII	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devdvi/M.proto-ASCII	2005-02-23 16:32:33.195768968 +0900
@@ -0,0 +1,4 @@
+name M
+internalname min10
+checksum -375402250
+designsize 10485760
diff -uNr groff-1.19.1.orig/font/devhtml/M.header groff-1.19.1/font/devhtml/M.header
--- groff-1.19.1.orig/font/devhtml/M.header	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devhtml/M.header	2005-02-23 16:32:33.195768968 +0900
@@ -0,0 +1,3 @@
+name M
+spacewidth 16
+fixedkanji 16,14,2 0
diff -uNr groff-1.19.1.orig/font/devhtml/Makefile.sub groff-1.19.1/font/devhtml/Makefile.sub
--- groff-1.19.1.orig/font/devhtml/Makefile.sub	2002-08-07 21:52:23.000000000 +0900
+++ groff-1.19.1/font/devhtml/Makefile.sub	2005-02-23 16:32:33.195768968 +0900
@@ -1,8 +1,8 @@
 DEV=html
 PROTOFONTS=R I B BI CR CI CB CBI
 FONTS=$(PROTOFONTS) S
-DEVFILES=$(FONTS) DESC
-CLEANADD=$(FONTS) DESC
+DEVFILES=$(FONTS) DESC M G
+CLEANADD=$(FONTS) DESC M G
 
 RES=240
 CPI=10
@@ -32,3 +32,12 @@
 	    -e "s/^fonts .*$$/fonts `set $(FONTS); echo $$#` $(FONTS)/" \
 	    $(srcdir)/DESC.proto >$@
 
+M: M.header
+	@echo Making M
+	@-rm -f M
+	@(cat $(srcdir)/M.header; echo charset) > M
+
+G: M
+	@echo Making G
+	@-rm -f G
+	@sed -e 's/name M/name G/' M > G
diff -uNr groff-1.19.1.orig/font/devlbp/Makefile.sub groff-1.19.1/font/devlbp/Makefile.sub
--- groff-1.19.1.orig/font/devlbp/Makefile.sub	2002-03-08 16:33:49.000000000 +0900
+++ groff-1.19.1/font/devlbp/Makefile.sub	2005-02-23 16:32:33.195768968 +0900
@@ -13,9 +13,9 @@
 	-rm -f DESC
 	cat $(srcdir)/DESC.in >>DESC
 	if test "$(PAGE)" = A4; then \
-	  echo "papersize a4" >>DESC; \
+	  echo "papersize /etc/papersize a4" >>DESC; \
 	else \
-	  echo "papersize letter" >>DESC; \
+	  echo "papersize /etc/papersize letter" >>DESC; \
 	fi
 	test -z '$(LBPPRINT)' || echo print '$(LBPPRINT)' >>DESC
 
diff -uNr groff-1.19.1.orig/font/devlj4/Makefile.sub groff-1.19.1/font/devlj4/Makefile.sub
--- groff-1.19.1.orig/font/devlj4/Makefile.sub	2004-03-05 18:39:56.000000000 +0900
+++ groff-1.19.1/font/devlj4/Makefile.sub	2005-02-23 16:32:33.195768968 +0900
@@ -30,9 +30,9 @@
 	echo "unitwidth `expr 7620000 / $(LJ4RES)`" >>DESC
 	cat $(srcdir)/DESC.in >>DESC
 	if test "$(PAGE)" = A4; then \
-	  echo "papersize a4" >>DESC; \
+	  echo "papersize /etc/papersize a4" >>DESC; \
 	else \
-	  echo "papersize letter" >>DESC; \
+	  echo "papersize /etc/papersize letter" >>DESC; \
 	fi
 	test -z '$(LJ4PRINT)' || echo print '$(LJ4PRINT)' >>DESC
 
diff -uNr groff-1.19.1.orig/font/devnippon/DESC.proto groff-1.19.1/font/devnippon/DESC.proto
--- groff-1.19.1.orig/font/devnippon/DESC.proto	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devnippon/DESC.proto	2005-02-23 16:32:33.196768816 +0900
@@ -0,0 +1,9 @@
+res 240
+hor 24
+vert 40
+unitwidth 10
+sizes 10 0
+fonts 6 R I B BI M G
+ondemand M G
+tcommand
+postpro grotty
diff -uNr groff-1.19.1.orig/font/devnippon/M.header groff-1.19.1/font/devnippon/M.header
--- groff-1.19.1.orig/font/devnippon/M.header	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devnippon/M.header	2005-02-23 16:32:33.196768816 +0900
@@ -0,0 +1,4 @@
+name M
+internalname 4
+spacewidth 48
+fixedkanji 48 0
diff -uNr groff-1.19.1.orig/font/devnippon/Makefile.sub groff-1.19.1/font/devnippon/Makefile.sub
--- groff-1.19.1.orig/font/devnippon/Makefile.sub	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devnippon/Makefile.sub	2005-02-23 16:32:33.196768816 +0900
@@ -0,0 +1,44 @@
+DEV=nippon
+FONTS=R I B BI
+WFONTS=M G
+ALLFONTS=$(FONTS) $(WFONTS)
+DEVFILES=$(ALLFONTS) DESC
+CLEANADD=$(ALLFONTS) DESC M G
+
+RES=240
+CPI=10
+LPI=6
+
+$(FONTS): R.proto
+	@echo Making $@
+	@-rm -f $@
+	@(charwidth=`expr $(RES) / $(CPI)` ; \
+ 	 sed -e "s/^name [A-Z]*$$/name $@/" \
+	     -e "s/^\\([^	]*\\)	[0-9]+	/\\1	$$charwidth	/" \
+	     -e "s/^spacewidth [0-9]+$$/spacewidth $$charwidth/" \
+	     -e "s/^internalname .*$$/internalname $@/" \
+	     -e "/^internalname/s/BI/3/" \
+	     -e "/^internalname/s/B/2/" \
+	     -e "/^internalname/s/I/1/" \
+	     -e "/^internalname .*[^ 0-9]/d" \
+	     $(srcdir)/R.proto >$@)
+
+M: M.header
+	@echo Making M
+	@-rm -f M
+	@(cat $(srcdir)/M.header; echo charset) > M
+
+G: M
+	@echo Making G
+	@-rm -f G
+	@sed -e 's/name M/name G/' \
+	    -e 's/internalname 4/internalname 5/' M > G
+		
+DESC: DESC.proto
+	@echo Making $@
+	@-rm -f $@
+	@sed -e "s/^res .*$$/res $(RES)/" \
+	    -e "s/^hor .*$$/hor `expr $(RES) / $(CPI)`/" \
+	    -e "s/^vert .*$$/vert `expr $(RES) / $(LPI)`/" \
+	    -e "s/^fonts .*$$/fonts `set $(ALLFONTS); echo $$#` $(ALLFONTS)/" \
+	    $(srcdir)/DESC.proto >$@
diff -uNr groff-1.19.1.orig/font/devnippon/R.proto groff-1.19.1/font/devnippon/R.proto
--- groff-1.19.1.orig/font/devnippon/R.proto	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devnippon/R.proto	2005-02-23 16:32:33.196768816 +0900
@@ -0,0 +1,167 @@
+name R
+internalname 0
+spacewidth 24
+charset
+!	24	0	0041
+"	24	0	0042
+dq	"
+lq	"
+rq	"
+#	24	0	0043
+sh	"
+$	24	0	0044
+Do	"
+%	24	0	0045
+&	24	0	0046
+'	24	0	0047
+aa	"
+fm	"
+aq	"
+cq	"
+(	24	0	0050
+)	24	0	0051
+*	24	0	0052
+**	"
++	24	0	0053
+pl	"
+,	24	0	0054
+\-	24	0	0055
+hy	"
+-	"
+mi	"
+en	"
+.	24	0	0056
+/	24	0	0057
+sl	"
+f/	"
+0	24	0	0060
+1	24	0	0061
+2	24	0	0062
+3	24	0	0063
+4	24	0	0064
+5	24	0	0065
+6	24	0	0066
+7	24	0	0067
+8	24	0	0070
+9	24	0	0071
+:	24	0	0072
+;	24	0	0073
+<	24	0	0074
+la	"
+fo	"
+=	24	0	0075
+eq	"
+>	24	0	0076
+ra	"
+fc	"
+?	24	0	0077
+@	24	0	0100
+at	"
+A	24	0	0101
+*A	"
+B	24	0	0102
+*B	"
+C	24	0	0103
+D	24	0	0104
+E	24	0	0105
+*E	"
+F	24	0	0106
+G	24	0	0107
+H	24	0	0110
+*Y	"
+I	24	0	0111
+*I	"
+J	24	0	0112
+K	24	0	0113
+*K	"
+L	24	0	0114
+M	24	0	0115
+*M	"
+N	24	0	0116
+*N	"
+O	24	0	0117
+ci	"
+*O	"
+P	24	0	0120
+*R	"
+Q	24	0	0121
+R	24	0	0122
+S	24	0	0123
+T	24	0	0124
+*T	"
+U	24	0	0125
+V	24	0	0126
+W	24	0	0127
+X	24	0	0130
+*X	"
+Y	24	0	0131
+*U	"
+Z	24	0	0132
+*Z	"
+[	24	0	0133
+lB	"
+\	24	0	0134
+rs	"
+]	24	0	0135
+rB	"
+a^	24	0	0136
+^	"
+ha	"
+_	24	0	0137
+ru	"
+ul	"
+`	24	0	0140
+oq	"
+ga	"
+a	24	0	0141
+b	24	0	0142
+c	24	0	0143
+d	24	0	0144
+e	24	0	0145
+f	24	0	0146
+g	24	0	0147
+h	24	0	0150
+i	24	0	0151
+.i	"
+j	24	0	0152
+k	24	0	0153
+l	24	0	0154
+m	24	0	0155
+n	24	0	0156
+o	24	0	0157
+*o	"
+p	24	0	0160
+q	24	0	0161
+r	24	0	0162
+s	24	0	0163
+t	24	0	0164
+u	24	0	0165
+v	24	0	0166
+w	24	0	0167
+x	24	0	0170
+mu	"
+y	24	0	0171
+z	24	0	0172
+lC	24	0	0173
+{	"
+ba	24	0	0174
+or	"
+bv	"
+br	"
+|	"
+lb	"
+lc	"
+lf	"
+lk	"
+lt	"
+rb	"
+rc	"
+rf	"
+rk	"
+rt	"
+rC	24	0	0175
+}	"
+a~	24	0	0176
+~	"
+ap	"
+ti	"
diff -uNr groff-1.19.1.orig/font/devnippon/createM.pl groff-1.19.1/font/devnippon/createM.pl
--- groff-1.19.1.orig/font/devnippon/createM.pl	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devnippon/createM.pl	2005-02-23 16:32:33.197768664 +0900
@@ -0,0 +1,55 @@
+#!/usr/bin/perl
+# cat <header> | ./$0 -{jis|euc} <metric> <type>
+#
+
+$jis=0;
+if ($ARGV[0] =~ /-jis/) {
+  $jis = 1;
+} elsif ($ARGV[0] =~ /-euc/) {
+  $jis = 0;
+} else {
+  print STDERR "$0: -jis or -euc\n"; exit 1;
+}
+$metric=$ARGV[1];
+$type=$ARGV[2];
+
+while (<STDIN>) {
+    print;	
+}
+print "charset\n";
+$WCTABLE_SIZE = 94;
+$WCTABLE_OFFSET = 0xa1;
+
+LOOP: for ($ku = 0; $ku < $WCTABLE_SIZE; $ku++) {
+    for ($ten = 0; $ten < $WCTABLE_SIZE; $ten++) {
+	$wc = (($ku + $WCTABLE_OFFSET) << 8) & 0xff00;
+	$wc |= ($ten + $WCTABLE_OFFSET) & 0xff;
+	if ($wc >= 0xa2af && $wc <= 0xa2b9 ||
+	    $wc >= 0xa2c2 && $wc <= 0xa2c9 ||
+	    $wc >= 0xa2d1 && $wc <= 0xa2db ||
+	    $wc >= 0xa2eb && $wc <= 0xa2f1 ||
+	    $wc >= 0xa2fa && $wc <= 0xa2fd ||
+	    $wc >= 0xa3a1 && $wc <= 0xa3af ||
+	    $wc >= 0xa3ba && $wc <= 0xa3c0 ||
+	    $wc >= 0xa3db && $wc <= 0xa3e0 ||
+	    $wc >= 0xa3fb && $wc <= 0xa3fe ||
+	    $wc >= 0xa4f4 && $wc <= 0xa4fe ||
+	    $wc >= 0xa5f7 && $wc <= 0xa5fe ||
+	    $wc >= 0xa6b9 && $wc <= 0xa6c0 ||
+	    $wc >= 0xa6d9 && $wc <= 0xa6fe ||
+	    $wc >= 0xa7c2 && $wc <= 0xa7d0 ||
+	    $wc >= 0xa7f2 && $wc <= 0xa7fe ||
+	    $wc >= 0xa8c1 && $wc <= 0xaffe ||
+	    $wc >= 0xcfd4 && $wc <= 0xcffe) {
+	    next;
+	} elsif ($wc >= 0xf4a5) {
+	    last LOOP;
+	} else {
+	    printf("%c%c\t%s\t%s\t%#x\n",
+		   $ku + $WCTABLE_OFFSET, $ten + $WCTABLE_OFFSET,
+		   $metric, $type, 
+		   ($jis ? ($wc & 0x7f7f) : $wc));
+	}
+    }
+}
+exit 0;
diff -uNr groff-1.19.1.orig/font/devps/DESC.in groff-1.19.1/font/devps/DESC.in
--- groff-1.19.1.orig/font/devps/DESC.in	2000-02-06 18:35:57.000000000 +0900
+++ groff-1.19.1/font/devps/DESC.in	2005-02-23 16:32:33.197768664 +0900
@@ -1,11 +1,14 @@
 res 72000
 hor 1
 vert 1
+lowerwchar 300
+wcharkern 400
 sizescale 1000
 unitwidth 1000
 sizes 1000-10000000 0
 styles R I B BI
 family T
-fonts 9 0 0 0 0 0 SS S ZD ZDR
+fonts 11 0 0 0 0 0 SS S ZD ZDR M G
+ondemand M G
 tcommand
 postpro grops
diff -uNr groff-1.19.1.orig/font/devps/M.header groff-1.19.1/font/devps/M.header
--- groff-1.19.1.orig/font/devps/M.header	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/font/devps/M.header	2005-02-23 16:32:33.197768664 +0900
@@ -0,0 +1,4 @@
+name M
+internalname Ryumin-Light-EUC-H
+spacewidth 1000
+fixedkanji 1000,880,120 3
diff -uNr groff-1.19.1.orig/font/devps/Makefile.sub groff-1.19.1/font/devps/Makefile.sub
--- groff-1.19.1.orig/font/devps/Makefile.sub	2003-04-05 17:41:47.000000000 +0900
+++ groff-1.19.1/font/devps/Makefile.sub	2005-02-23 16:32:33.197768664 +0900
@@ -2,7 +2,7 @@
 DISTFILES=text.enc download \
   S ZD ZDR SS AB ABI AI AR BMB BMBI BMI BMR \
   CB CBI CI CR HB HBI HI HR HNB HNBI HNI HNR \
-  NB NBI NI NR PB PBI PI PR TB TBI TI TR ZCMI \
+  NB NBI NI NR PB PBI PI PR TB TBI TI TR ZCMI M G \
   EURO freeeuro.pfa
 PSFILES=prologue symbolsl.pfa zapfdr.pfa
 DEVGENFILES=generate/Makefile generate/dingbats.map \
@@ -12,16 +12,16 @@
 DEVFILES=DESC $(PSFILES) $(DISTFILES) $(DEVGENFILES)
 DEVSCRIPTS=$(DEVGENSCRIPTS)
 
-CLEANADD=DESC $(PSFILES)
+CLEANADD=DESC $(PSFILES) M G
 
 DESC: DESC.in
 	-rm -f DESC
 	cat $(srcdir)/DESC.in >DESC
 	echo broken $(BROKEN_SPOOLER_FLAGS) >>DESC
 	if test "$(PAGE)" = A4; then \
-	  echo "papersize a4" >>DESC; \
+	  echo "papersize /etc/papersize a4" >>DESC; \
 	else \
-	  echo "papersize letter" >>DESC; \
+	  echo "papersize /etc/papersize letter" >>DESC; \
 	fi
 	test -z '$(PSPRINT)' ||	echo print '$(PSPRINT)' >>DESC
 
@@ -36,3 +36,14 @@
 $(PSFILES):
 	-rm -f $@
 	sed -f $(srcdir)/psstrip.sed $? >$@
+
+M: M.header
+	@echo Making M
+	@-rm -f M
+	@(cat $(srcdir)/M.header; echo charset) > M
+
+G: M
+	@echo Making G
+	@-rm -f G
+	@sed -e 's/name M/name G/' \
+	    -e 's/internalname Ryumin-Light-EUC-H/internalname GothicBBB-Medium-EUC-H/' M > G
diff -uNr groff-1.19.1.orig/mdate.sh groff-1.19.1/mdate.sh
--- groff-1.19.1.orig/mdate.sh	2001-03-10 00:26:30.000000000 +0900
+++ groff-1.19.1/mdate.sh	2005-02-23 16:32:33.197768664 +0900
@@ -2,41 +2,4 @@
 
 # Print the modification date of $1 `nicely'.
 
-# Don't want foreign dates.
-
-LANGUAGE=
-LC_ALL=C; export LC_ALL
-
-
-(date;
-if ls -L /dev/null 1>/dev/null 2>&1; then ls -L -l $1; else ls -l $1; fi
-) | awk '
-BEGIN {
-	full["Jan"] = "January"; number["Jan"] = 1;
-	full["Feb"] = "February"; number["Feb"] = 2;
-	full["Mar"] = "March"; number["Mar"] = 3;
-	full["Apr"] = "April"; number["Apr"] = 4;
-	full["May"] = "May"; number["May"] = 5;
-	full["Jun"] = "June"; number["Jun"] = 6;
-	full["Jul"] = "July"; number["Jul"] = 7;
-	full["Aug"] = "August"; number["Aug"] = 8;
-	full["Sep"] = "September"; number["Sep"] = 9;
-	full["Oct"] = "October"; number["Oct"] = 10;
-	full["Nov"] = "November"; number["Nov"] = 11;
-	full["Dec"] = "December"; number["Dec"] = 12;
-}
-
-NR == 1 {
-	month = $2;
-	year = $NF;
-}
-
-NR == 2 {
-	if ($(NF-1) ~ /:/) {
-		if (number[$(NF-3)] > number[month])
-			year--;
-	}
-	else
-		year = $(NF-1);
-	print $(NF-2), full[$(NF-3)], year
-}'
+perl -MPOSIX -le 'print strftime("%d %B %Y", localtime((stat $ARGV[0])[9]))' $1
diff -uNr groff-1.19.1.orig/src/devices/grodvi/dvi.cpp groff-1.19.1/src/devices/grodvi/dvi.cpp
--- groff-1.19.1.orig/src/devices/grodvi/dvi.cpp	2004-04-08 01:05:03.000000000 +0900
+++ groff-1.19.1/src/devices/grodvi/dvi.cpp	2005-02-23 16:34:57.099892216 +0900
@@ -109,6 +109,9 @@
 struct output_font {
   dvi_font *f;
   int point_size;
+#ifdef	NIPPON
+  const char *sf;		// subfont name
+#endif
   output_font() : f(0) { }
 };
 
@@ -126,6 +129,9 @@
   output_font output_font_table[FONTS_MAX];
   font *cur_font;
   int cur_point_size;
+#ifdef NIPPON
+  const char *cur_subfont;
+#endif
   color cur_color;
   int pushed;
   int pushed_h;
@@ -346,9 +352,18 @@
   if (*env->col != cur_color)
     set_color(env->col);
   int code = f->get_code(idx);
+#ifdef NIPPON
+  const char *sf = f->get_subfont_name(idx);
+  if (env->size != cur_point_size || f != cur_font ||
+     (sf != cur_subfont && strcmp(sf, cur_subfont))) {
+#else
   if (env->size != cur_point_size || f != cur_font) {
+#endif
     cur_font = f;
     cur_point_size = env->size;
+#ifdef NIPPON
+    cur_subfont = sf;
+#endif
     int i;
     for (i = 0;; i++) {
       if (i >= FONTS_MAX) {
@@ -357,9 +372,16 @@
       if (output_font_table[i].f == 0) {
 	output_font_table[i].f = (dvi_font *)cur_font;
 	output_font_table[i].point_size = cur_point_size;
+#ifdef	NIPPON
+	output_font_table[i].sf = cur_subfont;
+#endif
 	define_font(i);
       }
       if (output_font_table[i].f == cur_font
+#ifdef	NIPPON
+	  && (output_font_table[i].sf == cur_subfont ||
+	      strcmp(output_font_table[i].sf, cur_subfont) == 0)
+#endif
 	  && output_font_table[i].point_size == cur_point_size)
 	break;
     }
@@ -403,7 +425,13 @@
   out4(f->checksum);
   out4(output_font_table[i].point_size*RES_7227);
   out4(int((double(f->design_size)/(1<<20))*RES_7227*100 + .5));
+#ifdef	NIPPON
+  const char *nm;
+  if (!(nm = output_font_table[i].sf))
+    nm = f->get_internal_name();
+#else
   const char *nm = f->get_internal_name();
+#endif
   out1(0);
   out_string(nm);
 }
@@ -911,6 +939,7 @@
   program_name = argv[0];
   static char stderr_buf[BUFSIZ];
   setbuf(stderr, stderr_buf);
+  init_encoding_handler();
   int c;
   static const struct option long_options[] = {
     { "help", no_argument, 0, CHAR_MAX + 1 },
diff -uNr groff-1.19.1.orig/src/devices/grohtml/html.h groff-1.19.1/src/devices/grohtml/html.h
--- groff-1.19.1.orig/src/devices/grohtml/html.h	2004-01-06 07:29:24.000000000 +0900
+++ groff-1.19.1/src/devices/grohtml/html.h	2005-02-23 16:32:33.199768360 +0900
@@ -49,6 +49,9 @@
 class simple_output {
 public:
   simple_output(FILE *, int max_line_length);
+#ifdef NIPPON
+  simple_output &put_string(const wchar *, int);
+#endif
   simple_output &put_string(const char *, int);
   simple_output &put_string(const char *s);
   simple_output &put_string(const string &s);
diff -uNr groff-1.19.1.orig/src/devices/grohtml/post-html.cpp groff-1.19.1/src/devices/grohtml/post-html.cpp
--- groff-1.19.1.orig/src/devices/grohtml/post-html.cpp	2004-04-19 00:43:28.000000000 +0900
+++ groff-1.19.1/src/devices/grohtml/post-html.cpp	2005-02-23 16:32:33.200768208 +0900
@@ -29,6 +29,7 @@
 #include "html.h"
 #include "html-text.h"
 #include "html-table.h"
+#include "encoding.h" // XXX: ukai
 
 #include <time.h>
 
@@ -411,6 +412,7 @@
   }
 
   old_used = tail->used;
+  /* XXX: encoding - ukai */
   do {
     tail->buffer[tail->used] = s[i];
     tail->used++;
@@ -3128,6 +3130,10 @@
     current_paragraph->done_italic();
   } else if (strcmp(fontname, "CR") == 0) {
     current_paragraph->done_tt();
+#ifdef NIPPON
+  } else if (strcmp(fontname, "G") == 0) {
+    current_paragraph->done_bold();
+#endif
   } else if (strcmp(fontname, "CI") == 0) {
     current_paragraph->done_italic();
     current_paragraph->done_tt();
@@ -3163,6 +3169,14 @@
       current_paragraph->do_pre();
     }
     current_paragraph->do_tt();
+#ifdef NIPPON
+  } else if (strcmp(fontname, "M") == 0) {
+    current_paragraph->done_bold();
+    current_paragraph->done_italic();
+    current_paragraph->done_tt();
+  } else if (strcmp(fontname, "G") == 0) {
+    current_paragraph->do_bold();
+#endif
   } else if (strcmp(fontname, "CI") == 0) {
     if ((! fill_on) && (is_courier_until_eol())) {
       current_paragraph->do_pre();
@@ -3985,6 +3999,7 @@
   program_name = argv[0];
   static char stderr_buf[BUFSIZ];
   setbuf(stderr, stderr_buf);
+  init_encoding_handler();
   int c;
   static const struct option long_options[] = {
     { "help", no_argument, 0, CHAR_MAX + 1 },
diff -uNr groff-1.19.1.orig/src/devices/grops/ps.cpp groff-1.19.1/src/devices/grops/ps.cpp
--- groff-1.19.1.orig/src/devices/grops/ps.cpp	2004-04-18 20:31:44.000000000 +0900
+++ groff-1.19.1/src/devices/grops/ps.cpp	2005-02-23 16:32:33.202767904 +0900
@@ -30,6 +30,7 @@
 #include "cset.h"
 #include "nonposix.h"
 #include "paper.h"
+#include "encoding.h"
 
 #include "ps.h"
 #include <time.h>
@@ -201,12 +202,20 @@
   return *this;
 }
 
+#ifdef NIPPON
+ps_output &ps_output::put_string(const wchar *s, int n)
+#else
 ps_output &ps_output::put_string(const char *s, int n)
+#endif
 {
   int len = 0;
   int i;
   for (i = 0; i < n; i++) {
+#ifdef NIPPON
+    wchar c = s[i];
+#else
     char c = s[i];
+#endif
     if (is_ascii(c) && csprint(c)) {
       if (c == '(' || c == ')' || c == '\\')
 	len += 2;
@@ -232,8 +241,13 @@
 	putc('\n', fp);
 	col = 0;
       }
+#ifdef	NIPPON
+      int nb = encoding->put_wchar(s[i], fp, "%02x");
+      col += nb * 2;
+#else
       fprintf(fp, "%02x", s[i] & 0377);
       col += 2;
+#endif
     }
     putc('>', fp);
     col++;
@@ -528,7 +542,11 @@
   int paper_length;
   int equalise_spaces;
   enum { SBUF_SIZE = 256 };
+#ifdef	NIPPON
+  wchar sbuf[SBUF_SIZE];
+#else
   char sbuf[SBUF_SIZE];
+#endif
   int sbuf_len;
   int sbuf_start_hpos;
   int sbuf_vpos;
@@ -562,7 +580,11 @@
   void set_style(const style &);
   void set_space_code(unsigned char c);
   int set_encoding_index(ps_font *);
+#ifdef NIPPON
+  subencoding *set_subencoding(font *, int, wchar *);
+#else
   subencoding *set_subencoding(font *, int, unsigned char *);
+#endif
   char *get_subfont(subencoding *, const char *);
   void do_exec(char *, const environment *);
   void do_import(char *, const environment *);
@@ -656,8 +678,16 @@
   return f->encoding_index = next_encoding_index++;
 }
 
+#ifdef NIPPON
+subencoding *ps_printer::set_subencoding(font *f, int i, wchar *codep)
+#else
 subencoding *ps_printer::set_subencoding(font *f, int i, unsigned char *codep)
+#endif
 {
+#ifdef NIPPON
+  *codep = f->get_code(i);
+  return 0;
+#else
   unsigned int idx = f->get_code(i);
   *codep = idx % 256;
   unsigned int num = idx >> 8;
@@ -672,6 +702,7 @@
 				       subencodings);
   p->glyphs[*codep] = f->get_special_device_encoding(i);
   return p;
+#endif
 }
 
 char *ps_printer::get_subfont(subencoding *sub, const char *stem)
@@ -690,7 +721,11 @@
 {
   if (i == space_char_index || invis_count > 0)
     return;
+#ifdef	NIPPON
+  wchar code;
+#else
   unsigned char code;
+#endif
   subencoding *sub = set_subencoding(f, i, &code);
   style sty(f, sub, env->size, env->height, env->slant);
   if (sty.slant != 0) {
@@ -1792,6 +1827,7 @@
   string env;
   static char stderr_buf[BUFSIZ];
   setbuf(stderr, stderr_buf);
+  init_encoding_handler();
   int c;
   static const struct option long_options[] = {
     { "help", no_argument, 0, CHAR_MAX + 1 },
diff -uNr groff-1.19.1.orig/src/devices/grops/ps.h groff-1.19.1/src/devices/grops/ps.h
--- groff-1.19.1.orig/src/devices/grops/ps.h	2003-10-13 21:26:52.000000000 +0900
+++ groff-1.19.1/src/devices/grops/ps.h	2005-02-23 16:32:33.202767904 +0900
@@ -19,10 +19,16 @@
 with groff; see the file COPYING.  If not, write to the Free Software
 Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
 
+#include "encoding.h" // XXX
+
 class ps_output {
 public:
   ps_output(FILE *, int max_line_length);
+#ifdef	NIPPON
+  ps_output &put_string(const wchar *, int);
+#else
   ps_output &put_string(const char *, int);
+#endif
   ps_output &put_number(int);
   ps_output &put_fix_number(int);
   ps_output &put_float(double);
diff -uNr groff-1.19.1.orig/src/devices/grotty/grotty.man groff-1.19.1/src/devices/grotty/grotty.man
--- groff-1.19.1.orig/src/devices/grotty/grotty.man	2003-07-18 16:34:09.000000000 +0900
+++ groff-1.19.1/src/devices/grotty/grotty.man	2005-02-23 16:32:33.202767904 +0900
@@ -52,7 +52,9 @@
 command
 with a
 .BR \-Tascii ,
-.B \-Tlatin1
+.BR \-Tascii8 ,
+.BR \-Tlatin1 ,
+.B \-Tnippon
 or
 .B \-Tutf8
 option on ASCII based systems, and with
@@ -237,8 +239,10 @@
 .I name
 is the name of the device, usually
 .BR ascii ,
+.BR ascii8 ,
 .BR latin1 ,
 .BR utf8 ,
+.B  nippon
 or
 .BR cp1047 .
 .TP
@@ -325,10 +329,20 @@
 device.
 .
 .TP
+.B @FONTDIR@/devascii8/DESC
+Device description file for
+.B ascii8
+device.
+.TP
 .B @FONTDIR@/devlatin1/DESC
 Device description file for
 .B latin1
 device.
+.TP
+.B @FONTDIR@/devnippon/DESC
+Device description file for
+.B nippon
+device.
 .
 .TP
 .BI @FONTDIR@/devlatin1/ F
diff -uNr groff-1.19.1.orig/src/devices/grotty/tty.cpp groff-1.19.1/src/devices/grotty/tty.cpp
--- groff-1.19.1.orig/src/devices/grotty/tty.cpp	2004-04-19 00:38:43.000000000 +0900
+++ groff-1.19.1/src/devices/grotty/tty.cpp	2005-02-23 16:39:13.111972464 +0900
@@ -22,6 +22,7 @@
 #include "driver.h"
 #include "device.h"
 #include "ptable.h"
+#include "encoding.h"
 
 typedef signed char schar;
 
@@ -71,8 +72,21 @@
   COLOR_CHANGE = 0x20,
   START_LINE = 0x40,
   END_LINE = 0x80
+#ifdef NIPPON
+  , WCHAR_MODE = 0x100
+#endif
 };
 
+#ifdef NIPPON
+# ifdef putchar
+#  undef putchar
+# endif
+inline void putchar(wchar wc)
+{
+  encoding->put_wchar(wc, stdout);
+}
+#endif
+
 // Mode to use for bold-underlining.
 static unsigned char bold_underline_mode_option = BOLD_MODE|UNDERLINE_MODE;
 static unsigned char bold_underline_mode;
@@ -120,8 +134,26 @@
   }
   const char *num = f->get_internal_name();
   long n;
+#ifdef        NIPPON
+  if (num != 0) {
+    n = strtol(num, 0, 0);
+    switch (n) {
+    case 1:
+      f->mode = (unsigned char)(UNDERLINE_MODE);
+      break;
+    case 2:
+    case 5:
+      f->mode = (unsigned char)(BOLD_MODE);
+      break;
+    case 3:
+      f->mode = (unsigned char)(BOLD_MODE|UNDERLINE_MODE);
+      break;
+    }
+  }
+#else
   if (num != 0 && (n = strtol(num, 0, 0)) != 0)
     f->mode = (unsigned char)(n & (BOLD_MODE|UNDERLINE_MODE));
+#endif
   if (!underline_flag)
     f->mode &= ~UNDERLINE_MODE;
   if (!bold_flag)
@@ -302,8 +334,18 @@
 void tty_printer::make_underline()
 {
   if (old_drawing_scheme) {
+#if 0 /* def NIPPON XXX: not necessary? */
+    if ((p->mode & WCHAR_MODE)) {
+	putchar('_'); putchar('_');
+	putchar('\b'); putchar('\b');
+    } else {
+	putchar('_');
+	putchar('\b');
+    }
+#else
     putchar('_');
     putchar('\b');
+#endif
   }
   else {
     if (!is_underline) {
@@ -349,8 +391,10 @@
 void tty_printer::set_char(int i, font *f, const environment *env,
 			   int w, const char *)
 {
+#ifndef NIPPON
   if (w != font::hor)
     fatal("width of character not equal to horizontal resolution");
+#endif
   add_char(f->get_code(i),
 	   env->hpos, env->vpos,
 	   env->col, env->fill,
@@ -402,6 +446,10 @@
   g->code = c;
   g->fore_color_idx = color_to_idx(fore);
   g->back_color_idx = color_to_idx(back);
+#ifdef NIPPON
+  if (encoding->is_wchar_code(c))
+    mode |= WCHAR_MODE;
+#endif
   g->mode = mode;
 
   // The list will be reversed later.  After reversal, it must be in
@@ -747,6 +795,11 @@
 	}
       }
       put_char(p->code);
+#ifdef	NIPPON
+      if (encoding->is_wchar_code(p->code))
+	hpos += 2;
+      else
+#endif
       hpos++;
     }
     if (!old_drawing_scheme
@@ -801,6 +854,7 @@
   if (getenv("GROFF_NO_SGR"))
     old_drawing_scheme = 1;
   setbuf(stderr, stderr_buf);
+  init_encoding_handler();
   int c;
   static const struct option long_options[] = {
     { "help", no_argument, 0, CHAR_MAX + 1 },
diff -uNr groff-1.19.1.orig/src/include/device.h groff-1.19.1/src/include/device.h
--- groff-1.19.1.orig/src/include/device.h	2000-02-06 18:36:30.000000000 +0900
+++ groff-1.19.1/src/include/device.h	2005-02-23 16:32:33.204767600 +0900
@@ -18,4 +18,9 @@
 with groff; see the file COPYING.  If not, write to the Free Software
 Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
 
+#ifndef _DEVICE_H
+#define _DEVICE_H 1
+
 extern const char *device;
+
+#endif /* _DEVICE_H */
diff -uNr groff-1.19.1.orig/src/include/driver.h groff-1.19.1/src/include/driver.h
--- groff-1.19.1.orig/src/include/driver.h	2004-01-06 07:31:01.000000000 +0900
+++ groff-1.19.1/src/include/driver.h	2005-02-23 16:32:33.204767600 +0900
@@ -27,6 +27,7 @@
 #include <errno.h>
 #include <assert.h>
 #include <math.h>
+#include "encoding.h"
 #include "errarg.h"
 #include "error.h"
 #include "font.h"
diff -uNr groff-1.19.1.orig/src/include/encoding.h groff-1.19.1/src/include/encoding.h
--- groff-1.19.1.orig/src/include/encoding.h	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/src/include/encoding.h	2005-02-23 16:32:33.205767448 +0900
@@ -0,0 +1,156 @@
+// -*- C++ -*-
+/* Copyright (c) 2001 Fumitoshi UKAI <ukai@debian.or.jp>
+
+This file is part of groff.
+
+groff is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+groff is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#ifndef ENCODING_H
+#define ENCODING_H 1
+
+#include <config.h>
+
+#ifdef NIPPON
+typedef unsigned int wchar;
+#else
+typedef char wchar;
+#endif
+
+#include <stdio.h>
+
+#ifdef __cplusplus
+class encoding_istream {
+public:
+  encoding_istream() {};
+  virtual ~encoding_istream() {};
+  virtual int getbyte() = 0;
+  virtual int peekbyte() = 0;
+  virtual void ungetbyte(int ch) = 0;
+};
+
+class encoding_istream_str: public encoding_istream {
+private:
+  const unsigned char *s;
+  int *i;
+  encoding_istream_str() {};
+public:
+  encoding_istream_str(const unsigned char *s0, int *i0) : s(s0), i(i0) {};
+  ~encoding_istream_str() {};
+  inline int getbyte() { return s[(*i)++]; };
+  inline int peekbyte() { return s[(*i)]; };
+  inline void ungetbyte(int ch) { --(*i); };
+};
+
+class encoding_istream_fp: public encoding_istream {
+private:
+  FILE *fp;
+public:
+  encoding_istream_fp(FILE *fp0) : fp(fp0) {};
+  ~encoding_istream_fp() {};
+  inline int getbyte() { return fgetc(fp); };
+  inline int peekbyte() { int ch = fgetc(fp); ungetc(ch, fp); return ch; };
+  inline void ungetbyte(int ch) { ungetc(ch, fp); };
+};
+
+class encoding_ostream {
+public:
+  encoding_ostream() {};
+  virtual ~encoding_ostream() {};
+  virtual void putbyte(unsigned char ch) = 0;
+};
+
+class encoding_ostream_str: public encoding_ostream {
+private:
+  unsigned char *s;
+  int *i;
+  int len;
+  encoding_ostream_str() {};
+public:
+  encoding_ostream_str(unsigned char *s0, int *i0, int max) : s(s0), i(i0), len(max) {};
+  ~encoding_ostream_str() {};
+  inline void putbyte(unsigned char ch) {
+    if (*i < len)
+      s[(*i)++] = ch;
+  }
+};
+
+class encoding_ostream_fp: public encoding_ostream {
+private:
+  FILE *fp;
+  const char *format;
+public:
+  encoding_ostream_fp(FILE *ofp, const char *fmt = "%c") : fp(ofp), format(fmt) {};
+  ~encoding_ostream_fp() {};
+  inline void putbyte(unsigned char ch) {
+    fprintf(fp, format, ch);
+  }
+};
+
+class encoding_handler {
+protected:
+  wchar wc;
+public:
+  encoding_handler() {};
+  virtual ~encoding_handler() {};
+
+  virtual int is_wchar_code(wchar wc) { return 0; };
+  virtual int is_wchar_byte(unsigned char c) { return 0; };
+  virtual wchar make_wchar(unsigned char c0, encoding_istream& in) {
+    return wchar(c0);
+  }
+  virtual wchar make_wchar(unsigned char c0, FILE *fp) { 
+    encoding_istream_fp in(fp);
+    return make_wchar(c0, in);
+  }
+  virtual wchar make_wchar(unsigned char c0, const unsigned char *s, int *i) {
+    encoding_istream_str in(s, i);
+    return make_wchar(c0, in); 
+  }
+
+  virtual int put_wchar(wchar wc, encoding_ostream& out) {
+    out.putbyte((unsigned char)wc);
+    return 1;
+  }
+
+  virtual int put_wchar(wchar wc, FILE *fp, const char *fmt = "%c") {
+    encoding_ostream_fp out(fp, fmt);
+    return put_wchar(wc, out);
+  }
+  virtual int put_wchar(wchar wc, unsigned char *s, int *i, int maxlen) {
+    encoding_ostream_str out(s, i, maxlen);
+    return put_wchar(wc, out);
+  }
+  virtual int max_wchar_len() { return 1; };
+
+  virtual void foreach_wchar(void (*iter)(wchar wc, void *arg), void *arg) {};
+  virtual int wchar_iter_first(wchar *wc) { return 0; };
+  virtual int wchar_iter_next(wchar *wc) { return 0; };
+
+  // for indexer
+  virtual int wchar_index(wchar wc) { return 0; };
+  virtual void set_wchar_index(wchar wc, int index) { return; };
+
+  // for troff/input.cc
+  virtual int wchar_table_index(wchar wc) { return 0; };
+  virtual void* init_table() { return NULL;};
+};
+
+encoding_handler* new_encoding_handler(const char* encoding_name);
+extern encoding_handler* encoding;
+encoding_handler *init_encoding_handler();
+
+#endif
+
+#endif /* ENCODING_H */
diff -uNr groff-1.19.1.orig/src/include/eucmac.h groff-1.19.1/src/include/eucmac.h
--- groff-1.19.1.orig/src/include/eucmac.h	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/src/include/eucmac.h	2005-02-23 16:32:33.205767448 +0900
@@ -0,0 +1,88 @@
+// -*- C++ -*-
+/* Copyright (C) 1994 Free Software Foundation, Inc.
+     Written by Toshiyuki Kitagawa (kitagawa@bsd2.kb.nec.co.jp)
+
+This file is part of groff.
+
+groff is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+groff is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License along
+with groff; see the file COPYING.  If not, write to the Free Software
+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+
+#ifndef _EUCMAC_H
+#define _EUCMAC_H
+
+#include <string.h>
+#include "device.h"
+
+#ifdef NIPPON
+typedef unsigned int	wchar;
+#else
+typedef char	wchar;
+#endif
+
+static const int WCTABLE_OFFSET = 0xa1;
+static const int WCTABLE_SIZE = 94;
+static const int EUCMASK = 0x8080;
+
+
+inline int is_euc_code(wchar wc)
+{
+  if ( device ) {
+       if ((strncmp(device, "latin1", 6) == 0) ||
+           (strncmp(device, "ascii8", 6) == 0)) {
+               return(0);
+       }
+  }
+  return((wc & EUCMASK) == (wchar)EUCMASK);
+}
+
+inline int is_euc_byte(unsigned char c)
+{
+  if ( device ) {
+       if ((strncmp(device, "latin1", 6) == 0) ||
+           (strncmp(device, "ascii8", 6) == 0)) {
+               return(0);
+       }
+  }
+  return(c >= 0xa1 && c <= 0xfe);
+}
+
+inline wchar make_euc_code(unsigned char ubyte, unsigned char lbyte)
+{
+  wchar wc;
+
+  wc = (ubyte & 0xff) << 8;
+  wc |= (lbyte & 0xff);
+  return(wc);
+}
+
+inline unsigned int euc_ubyte(wchar wc)
+{
+  return((unsigned int)((wc >> 8) & 0xff));
+}
+
+inline unsigned int euc_lbyte(wchar wc)
+{
+  return((unsigned int)(wc & 0xff));
+}
+
+inline wchar calc_euccode(int ku, int ten)
+{
+  wchar code = 0;
+
+  code = ((ku + WCTABLE_OFFSET) << 8) & 0xff00;
+  code |= (ten + WCTABLE_OFFSET) & 0xff;
+  return (code);
+}
+#endif	/* _EUCMAC_H */
diff -uNr groff-1.19.1.orig/src/include/font.h groff-1.19.1/src/include/font.h
--- groff-1.19.1.orig/src/include/font.h	2004-04-18 15:14:55.000000000 +0900
+++ groff-1.19.1/src/include/font.h	2005-02-23 16:32:33.205767448 +0900
@@ -19,6 +19,8 @@
 with groff; see the file COPYING.  If not, write to the Free Software
 Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
 
+#include "encoding.h"
+
 typedef void (*FONT_COMMAND_HANDLER)(const char *, const char *,
 				     const char *, int);
 
@@ -54,6 +56,9 @@
   const char *get_special_device_encoding(int index);
   const char *get_name();
   const char *get_internal_name();
+#ifdef NIPPON
+  const char *get_subfont_name(int index);
+#endif
 
   static int scan_papersize(const char *, const char **, double *, double *);
 
@@ -63,6 +68,9 @@
   static int load_desc();
   static int name_to_index(const char *);
   static int number_to_index(int);
+#ifdef NIPPON
+  static int wchar_index(wchar);
+#endif
   static FONT_COMMAND_HANDLER
     set_unknown_desc_command_handler(FONT_COMMAND_HANDLER);
 
@@ -77,6 +85,10 @@
   static int spare2;
   static int sizescale;
   static int tcommand;
+#ifdef NIPPON
+  static int lowerwchar;
+  static int wcharkern;
+#endif
   static int pass_filenames;
   static int use_charnames_in_special;
 
@@ -84,6 +96,9 @@
   static const char **style_table;
   static const char *family;
   static int *sizes;
+#ifdef NIPPON
+  static const char **on_demand_fonts;
+#endif
 private:
   unsigned ligatures;
   font_kern_list **kern_hash_table;
diff -uNr groff-1.19.1.orig/src/include/lib.h groff-1.19.1/src/include/lib.h
--- groff-1.19.1.orig/src/include/lib.h	2003-11-13 17:21:50.000000000 +0900
+++ groff-1.19.1/src/include/lib.h	2005-02-23 16:32:33.206767296 +0900
@@ -104,8 +104,15 @@
 
 extern char invalid_char_table[];
 
+#include "encoding.h"
+
 inline int invalid_input_char(int c)
 {
+#ifdef NIPPON
+  if (encoding->is_wchar_byte(c))
+    return 0;
+  else
+#endif
   return c >= 0 && invalid_char_table[c];
 }
 
diff -uNr groff-1.19.1.orig/src/include/printer.h groff-1.19.1/src/include/printer.h
--- groff-1.19.1.orig/src/include/printer.h	2004-04-17 13:37:24.000000000 +0900
+++ groff-1.19.1/src/include/printer.h	2005-02-23 16:32:33.206767296 +0900
@@ -38,6 +38,8 @@
 
 #include "color.h"
 
+#include "encoding.h"
+
 struct environment {
   int fontno;
   int size;
@@ -63,6 +65,9 @@
   printer();
   virtual ~printer();
   void load_font(int i, const char *name);
+#ifdef NIPPON
+  void set_wchar_char(wchar c, const environment *env, int *widthp = 0);
+#endif
   void set_ascii_char(unsigned char c, const environment *env,
 		      int *widthp = 0);
   void set_special_char(const char *nm, const environment *env,
diff -uNr groff-1.19.1.orig/src/libs/libdriver/input.cpp groff-1.19.1/src/libs/libdriver/input.cpp
--- groff-1.19.1.orig/src/libs/libdriver/input.cpp	2004-04-07 23:30:36.000000000 +0900
+++ groff-1.19.1/src/libs/libdriver/input.cpp	2005-02-23 16:32:33.207767144 +0900
@@ -243,6 +243,7 @@
 
 #include "driver.h"
 #include "device.h"
+#include "encoding.h"
 
 #include <stdlib.h>
 #include <errno.h>
@@ -1533,6 +1534,17 @@
   return stopped;
 }
 
+////////////////////////////////////////////////////////////////
+#ifdef	NIPPON
+class encoding_istream_current_file : public encoding_istream {
+public:
+  encoding_istream_current_file() {};
+  ~encoding_istream_current_file() {};
+  int getbyte() { return getc(current_file); };
+  int peekbyte() { int ch = getc(current_file); ungetc(ch, current_file); return ch; };
+  void ungetbyte(int c) { ungetc(c, current_file); };
+};
+#endif
 
 /**********************************************************************
                      exported part (by driver.h)
@@ -1779,6 +1791,16 @@
 	size_t i = 0;
 	while ((c = str_arg[i++]) != '\0') {
 	  EnvInt w;
+#ifdef	NIPPON
+ 	  if (encoding->is_wchar_byte(c)) {
+ 	    wchar wc = encoding->make_wchar(c, (const unsigned char *)str_arg, (int *)&i);
+ 	    if (encoding->is_wchar_code(wc)) {
+ 	      pr->set_wchar_char(wc, current_env, &w);
+ 	    } else {
+ 	      pr->set_ascii_char((unsigned char) c, current_env, &w);
+ 	    }
+ 	  } else
+#endif
 	  pr->set_ascii_char((unsigned char) c, current_env, &w);
 	  current_env->hpos += w;
 	}
diff -uNr groff-1.19.1.orig/src/libs/libdriver/printer.cpp groff-1.19.1/src/libs/libdriver/printer.cpp
--- groff-1.19.1.orig/src/libs/libdriver/printer.cpp	2003-04-12 22:58:14.000000000 +0900
+++ groff-1.19.1/src/libs/libdriver/printer.cpp	2005-02-23 16:32:33.207767144 +0900
@@ -27,6 +27,7 @@
 */
 
 #include "driver.h"
+#include "encoding.h"
 
 font_pointer_list::font_pointer_list(font *f, font_pointer_list *fp)
 : p(f), next(fp)
@@ -136,6 +137,19 @@
   }
 }
 
+#ifdef	NIPPON
+void printer::set_wchar_char(wchar c, const environment *env, int *widthp)
+{
+  int len = encoding->max_wchar_len() + 1;
+  unsigned char *buf = new unsigned char[len];
+  memset(buf, 0, len);
+  int i = 0;
+  encoding->put_wchar(c, buf, &i, len);
+  set_special_char((const char *)buf, env, widthp);
+  delete [] buf;
+}
+#endif
+
 void printer::set_special_char(const char *nm, const environment *env,
 			       int *widthp)
 {
diff -uNr groff-1.19.1.orig/src/libs/libgroff/Makefile.sub groff-1.19.1/src/libs/libgroff/Makefile.sub
--- groff-1.19.1.orig/src/libs/libgroff/Makefile.sub	2004-02-22 06:16:47.000000000 +0900
+++ groff-1.19.1/src/libs/libgroff/Makefile.sub	2005-02-23 16:32:33.207767144 +0900
@@ -6,6 +6,7 @@
   color.$(OBJEXT) \
   cset.$(OBJEXT) \
   device.$(OBJEXT) \
+  encoding.$(OBJEXT) \
   errarg.$(OBJEXT) \
   error.$(OBJEXT) \
   fatal.$(OBJEXT) \
@@ -52,6 +53,7 @@
   $(srcdir)/color.cpp \
   $(srcdir)/cset.cpp \
   $(srcdir)/device.cpp \
+  $(srcdir)/encoding.cpp \
   $(srcdir)/errarg.cpp \
   $(srcdir)/error.cpp \
   $(srcdir)/fatal.cpp \
diff -uNr groff-1.19.1.orig/src/libs/libgroff/encoding.cpp groff-1.19.1/src/libs/libgroff/encoding.cpp
--- groff-1.19.1.orig/src/libs/libgroff/encoding.cpp	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/src/libs/libgroff/encoding.cpp	2005-02-23 16:32:33.208766992 +0900
@@ -0,0 +1,234 @@
+// -*- C++ -*-
+/* Copyright (C) 2001 Fumitoshi UKAI <ukai@debian.or.jp>
+
+This file is part of groff.
+
+groff is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+groff is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#include "encoding.h"
+#include <string.h>
+#ifdef NIPPON
+#include <locale.h>
+#if HAVE_LANGINFO_CODESET
+#include <langinfo.h>
+#else
+#include <stdlib.h>
+#endif
+#endif
+
+class ascii8_handler : public encoding_handler {
+public:
+  ascii8_handler() {}
+  ~ascii8_handler() {}
+
+  inline int is_wchar_code(wchar wc) { return 0; }
+  inline int is_wchar_byte(unsigned char c) { return 0; }
+
+  inline wchar make_wchar(unsigned char c0, encoding_istream& in) {
+    return wchar(c0);
+  }
+  inline int put_wchar(wchar wc, encoding_ostream& out) {
+    out.putbyte((unsigned char)wc);
+    return 1;
+  }
+  inline int max_wchar_len() { return 1; };
+
+  inline void foreach_wchar(void (*iter)(wchar wc, void *arg), void *arg) {
+    return;
+  }
+  inline int wchar_iter_first(wchar *wc) {
+    return 0;
+  }
+  inline int wchar_iter_next(wchar *wc) {
+    return 0;
+  }
+
+  inline int wchar_index(wchar wc) {
+    return 0;
+  }
+
+  inline void set_wchar_index(wchar wc, int index) {
+    return;
+  }
+
+  inline int wchar_table_index(wchar wc) { return 0; }
+  inline void* init_table() { return NULL;  }
+};
+
+#ifdef NIPPON
+class euc_handler : public encoding_handler {
+  static const int WCTABLE_OFFSET = 0xa1;
+  static const int WCTABLE_SIZE = 94;
+  static const int EUCMASK = 0x8080;
+
+private:
+  int euc_index[WCTABLE_SIZE][WCTABLE_SIZE];
+  int iter_ku, iter_ten;
+
+public:
+  euc_handler() {
+    for (int i = 0; i < WCTABLE_SIZE; i++) {
+      for (int j = 0; j < WCTABLE_SIZE; j++) {
+	euc_index[i][j] = -1;
+      }
+    }
+  };
+  ~euc_handler() {};
+
+  inline int is_wchar_code(wchar wc) {
+    return ((wc & EUCMASK) == (wchar)EUCMASK);
+  }
+
+  inline int is_wchar_byte(unsigned char c) {
+    return (c >= 0xa1 && c <= 0xfe);
+  }
+
+  inline wchar make_wchar(unsigned char c0, encoding_istream& in) {
+    wchar wc;
+    if (! is_wchar_byte(c0)) {
+      return c0;
+    }
+    int c1 = in.peekbyte();
+    if (! is_wchar_byte(c1)) {
+      return c0;
+    }
+    c1 = in.getbyte();
+    wc = (c0 & 0xff) << 8;
+    wc |= (c1 & 0xff);
+
+    if (wc == 0xa1a1)
+      wc = ' ';
+    return wc;
+  }
+
+  inline int put_wchar(wchar wc, encoding_ostream& out) {
+    if (is_wchar_code(wc)) {
+      out.putbyte((wc >> 8) & 0x0ff);
+      out.putbyte((wc >> 0) & 0x0ff);
+      return 2;    
+    } else {
+      out.putbyte(wc & 0x0ff);
+      return 1;
+    }
+  }
+  inline int max_wchar_len() { return 2; }; /* XXX */
+
+  inline void foreach_wchar(void (*iter)(wchar wc, void *arg), void *arg) {
+    int ku, ten;
+    wchar wc;
+    for (ku = 0; ku < WCTABLE_SIZE; ku++) {
+      for (ten = 0; ten < WCTABLE_SIZE; ten++) {
+	wc = 0;
+	wc = ((ku + WCTABLE_OFFSET) << 8) & 0xff00;
+	wc |= (ten + WCTABLE_OFFSET) & 0xff;
+	iter(wc, arg);
+      }
+    }
+  }
+  inline int wchar_iter_first(wchar *wc) {
+    iter_ku = iter_ten = 0;
+    *wc = 0;
+    *wc = ((iter_ku + WCTABLE_OFFSET) << 8) & 0xff00;
+    *wc |= (iter_ten + WCTABLE_OFFSET) & 0xff;
+    return 1;
+  }
+  inline int wchar_iter_next(wchar *wc) {
+    *wc = 0;
+    iter_ten++;
+    if (iter_ten >= WCTABLE_SIZE) {
+      iter_ten = 0; 
+      iter_ku++;
+      if (iter_ku >= WCTABLE_SIZE) {
+	return 0;
+      }
+    }
+    *wc = ((iter_ku + WCTABLE_OFFSET) << 8) & 0xff00;
+    *wc |= (iter_ten + WCTABLE_OFFSET) & 0xff;
+    return 1;
+  }
+
+  inline int wchar_index(wchar wc) {
+    int ku = ((wc >> 8) & 0xff) - WCTABLE_OFFSET;
+    int ten = (wc & 0xff) - WCTABLE_OFFSET;
+    return euc_index[ku][ten];
+  }
+
+  inline void set_wchar_index(wchar wc, int index) {
+    int ku = ((wc >> 8) & 0xff) - WCTABLE_OFFSET;
+    int ten = (wc & 0xff) - WCTABLE_OFFSET;
+    euc_index[ku][ten] = index;
+  }
+
+  inline int wchar_table_index(wchar wc) {
+    int ku = ((wc >> 8) & 0xff) - WCTABLE_OFFSET;
+    int ten = (wc & 0xff) - WCTABLE_OFFSET;
+    return ku * WCTABLE_SIZE + ten;
+  }
+  inline void* init_table() { 
+    void *tbl = new void*[WCTABLE_SIZE * WCTABLE_SIZE];
+    memset(tbl, 0, WCTABLE_SIZE * WCTABLE_SIZE);
+    return tbl;
+  }
+};
+#endif
+
+static ascii8_handler ascii8;
+#ifdef NIPPON
+static euc_handler eucjp;
+#endif
+
+encoding_handler *encoding = &ascii8;
+
+encoding_handler *
+new_encoding_handler(const char *encoding_name)
+{
+#ifdef NIPPON
+  // printf("encoding request: [%s]\n", encoding_name);
+  if (strcmp(encoding_name, "EUC-JP") == 0) {
+    // printf("encoding: [EUC-JP]\n");
+    encoding = &eucjp;
+    return &eucjp;
+  }
+#endif
+  // default
+  encoding = &ascii8;
+  return &ascii8;
+}
+
+encoding_handler *
+init_encoding_handler()
+{
+#ifdef NIPPON
+  const char *locale;
+  setlocale(LC_ALL, "");
+#if HAVE_LANGINFO_CODESET
+  locale = nl_langinfo(CODESET);
+#else
+  /* Emulation taken from gettext's locale_charset() function. */
+  locale = setlocale(LC_CTYPE, NULL);
+  if (locale == NULL || locale[0] == '\0') {
+    locale = getenv("LC_ALL");
+    if (locale == NULL || locale[0] == '\0') {
+      locale = getenv("LC_CTYPE");
+      if (locale == NULL || locale[0] == '\0')
+	locale = getenv("LANG");
+    }
+  }
+#endif
+  new_encoding_handler(locale);
+#endif
+
+  return encoding;
+}
diff -uNr groff-1.19.1.orig/src/libs/libgroff/font.cpp groff-1.19.1/src/libs/libgroff/font.cpp
--- groff-1.19.1.orig/src/libs/libgroff/font.cpp	2004-04-18 15:17:40.000000000 +0900
+++ groff-1.19.1/src/libs/libgroff/font.cpp	2005-02-23 16:45:58.531339352 +0900
@@ -25,6 +25,7 @@
 #include <assert.h>
 #include <math.h>
 #include <stdlib.h>
+#include "encoding.h"
 #include "errarg.h"
 #include "error.h"
 #include "cset.h"
@@ -43,6 +44,9 @@
   int italic_correction;
   int subscript_correction;
   char *special_device_coding;
+#ifdef NIPPON
+  char *subfont_name;
+#endif
 };
 
 struct font_kern_list {
@@ -397,6 +401,14 @@
   return( ch[ch_index[c]].special_device_coding );
 }
 
+#ifdef NIPPON
+const char *font::get_subfont_name(int c)
+{
+  assert(c >= 0 && c < nindices && ch_index[c] >= 0);
+  return ch[ch_index[c]].subfont_name;
+}
+#endif
+
 void font::alloc_ch_index(int idx)
 {
   if (nindices == 0) {
@@ -560,6 +572,9 @@
 int font::load(int *not_found)
 {
   char *path;
+#ifdef NIPPON
+  int had_fixedkanji = 0;
+#endif
   FILE *fp;
   if ((fp = open_file(name, &path)) == NULL) {
     if (not_found)
@@ -630,6 +645,60 @@
     else if (strcmp(p, "special") == 0) {
       special = 1;
     }
+#ifdef NIPPON
+    else if (strcmp(p, "fixedkanji") == 0) {
+      font_char_metric metric;
+      int last_index;
+
+      had_fixedkanji = 1;
+
+      metric.height = 0;
+      metric.depth = 0;
+      metric.pre_math_space = 0;
+      metric.italic_correction = 0;
+      metric.subscript_correction = 0;
+      metric.special_device_coding = NULL;
+      metric.subfont_name = NULL;
+      p = strtok(0, WS);
+      if (p == 0) {
+	  t.error("missing metric infomation");
+	  return 0;
+      }
+      int nparms = sscanf(p, "%d,%d,%d,%d,%d,%d",
+			  &metric.width, &metric.height, &metric.depth,
+			  &metric.italic_correction,
+			  &metric.pre_math_space,
+			  &metric.subscript_correction);
+      if (nparms < 1) {
+	  t.error("bad width");
+	  return 0;
+      }
+      p = strtok(0, WS);
+      if (p == 0) {
+	  t.error("missing character type");
+	  return 0;
+      }
+      int type;
+      if (sscanf(p, "%d", &type) != 1) {
+	  t.error("bad character type");
+	  return 0;
+      }
+      if (type < 0 || type > 255) {
+	  t.error("character type `%1' out of range", type);
+	  return 0;
+      }
+      metric.type = type;
+
+      wchar wc;
+
+      for (encoding->wchar_iter_first(&wc); encoding->wchar_iter_next(&wc);) {
+	metric.code = wc;
+	last_index = wchar_index(wc);
+	add_entry(last_index, metric);
+	copy_entry(number_to_index(metric.code), last_index);
+      }
+    }
+#endif
     else if (strcmp(p, "kernpairs") != 0 && strcmp(p, "charset") != 0) {
       char *command = p;
       p = strtok(0, "\n");
@@ -680,6 +749,10 @@
       }
     }
     else if (strcmp(command, "charset") == 0) {
+#ifdef NIPPON
+      if (had_fixedkanji)
+        goto end;
+#endif
       had_charset = 1;
       int last_index = -1;
       for (;;) {
@@ -718,6 +791,10 @@
 	  metric.pre_math_space = 0;
 	  metric.italic_correction = 0;
 	  metric.subscript_correction = 0;
+#ifdef NIPPON
+      metric.special_device_coding = NULL;
+      metric.subfont_name = NULL;
+#endif
 	  int nparms = sscanf(p, "%d,%d,%d,%d,%d,%d",
 			      &metric.width, &metric.height, &metric.depth,
 			      &metric.italic_correction,
@@ -747,6 +824,16 @@
 	    t.error("missing code for `%1'", nm);
 	    return 0;
 	  }
+#ifdef	NIPPON
+	  char *subp = strchr(p, ':');
+	  if (subp) {
+	    *subp++ = '\0';
+	    metric.subfont_name = new char[strlen(subp) + 1];
+	    strcpy(metric.subfont_name, subp);
+	  } else {
+	    metric.subfont_name = NULL;
+	  }
+#endif
 	  char *ptr;
 	  metric.code = (int)strtol(p, &ptr, 0);
 	  if (metric.code == 0 && ptr == p) {
@@ -791,6 +878,9 @@
     t.error("missing charset command");
     return 0;
   }
+#ifdef	NIPPON
+end:
+#endif
   if (space_width == 0)
     space_width = scale_round(unitwidth, res, 72*3*sizescale);
   compact();
@@ -811,6 +901,11 @@
   { "biggestfont", &font::biggestfont },
   { "spare2", &font::spare2 },
   { "sizescale", &font::sizescale }
+#ifdef	NIPPON
+  ,
+  { "lowerwchar", &font::lowerwchar },
+  { "wcharkern", &font::wcharkern }
+#endif
   };
 
 int font::load_desc()
@@ -981,6 +1076,24 @@
       tcommand = 1;
     else if (strcmp("use_charnames_in_special", p) == 0)
       use_charnames_in_special = 1;
+#ifdef	NIPPON
+    else if (strcmp("ondemand", p) == 0) { 
+      int table_size = 3;	// enough room for M and G.
+      on_demand_fonts = (const char **)new char *[table_size];
+      for (int j = 0; j < table_size; j++)
+	on_demand_fonts[j] = 0;
+      int i = 0;
+      for (;;) {
+	p = strtok(0, WS);
+	if (p == 0)
+	  break;
+	assert(i + 1 < table_size);	// scamped work  *^_^*
+	char *tem = new char[strlen(p) + 1];
+	strcpy(tem, p);
+	on_demand_fonts[i++] = tem;
+      }
+    }
+#endif
     else if (strcmp("charset", p) == 0)
       break;
     else if (unknown_desc_command_handler) {
diff -uNr groff-1.19.1.orig/src/libs/libgroff/fontfile.cpp groff-1.19.1/src/libs/libgroff/fontfile.cpp
--- groff-1.19.1.orig/src/libs/libgroff/fontfile.cpp	2004-04-07 23:25:28.000000000 +0900
+++ groff-1.19.1/src/libs/libgroff/fontfile.cpp	2005-02-23 16:32:33.209766840 +0900
@@ -24,6 +24,7 @@
 #include <assert.h>
 #include <stdlib.h>
 #include <errno.h>
+#include "encoding.h"
 #include "font.h"
 #include "searchpath.h"
 #include "device.h"
@@ -36,6 +37,10 @@
 int font::res = 0;
 int font::hor = 1;
 int font::vert = 1;
+#ifdef	NIPPON
+int font::lowerwchar = 0;
+int font::wcharkern = 0;
+#endif
 int font::unitwidth = 0;
 int font::paperwidth = 0;
 int font::paperlength = 0;
@@ -50,6 +55,9 @@
 int *font::sizes = 0;
 const char *font::family = 0;
 const char **font::style_table = 0;
+#ifdef	NIPPON
+const char **font::on_demand_fonts = 0;
+#endif
 FONT_COMMAND_HANDLER font::unknown_desc_command_handler = 0;
 
 void font::command_line_font_dir(const char *dir)
diff -uNr groff-1.19.1.orig/src/libs/libgroff/nametoindex.cpp groff-1.19.1/src/libs/libgroff/nametoindex.cpp
--- groff-1.19.1.orig/src/libs/libgroff/nametoindex.cpp	2004-04-07 23:28:07.000000000 +0900
+++ groff-1.19.1/src/libs/libgroff/nametoindex.cpp	2005-02-23 16:32:33.209766840 +0900
@@ -24,6 +24,7 @@
 #include <ctype.h>
 #include <assert.h>
 #include <stdlib.h>
+#include "encoding.h"
 #include "errarg.h"
 #include "error.h"
 #include "font.h"
@@ -37,6 +38,9 @@
   character_indexer();
   ~character_indexer();
   int ascii_char_index(unsigned char);
+#ifdef	NIPPON
+  int wchar_index(wchar);
+#endif
   int named_char_index(const char *);
   int numbered_char_index(int);
 private:
@@ -68,6 +72,15 @@
   return ascii_index[c];
 }
 
+#ifdef	NIPPON
+int character_indexer::wchar_index(wchar wc)
+{
+  if (encoding->wchar_index(wc) < 0)
+    encoding->set_wchar_index(wc, next_index++);
+  return encoding->wchar_index(wc);
+}
+#endif
+
 int character_indexer::numbered_char_index(int n)
 {
   if (n >= 0 && n < NSMALL) {
@@ -103,6 +116,15 @@
 int font::name_to_index(const char *s)
 {
   assert(s != 0 && s[0] != '\0' && s[0] != ' ');
+#ifdef	NIPPON
+ {
+   int i = 1;
+   wchar wc = encoding->make_wchar(s[0], (const unsigned char *)s, &i);
+   if (encoding->is_wchar_code(wc)) {
+    return indexer.wchar_index(wc);
+   }
+ }
+#endif
   if (s[1] == '\0')
     return indexer.ascii_char_index(s[0]);
   /* char128 and \200 are synonyms */
@@ -115,3 +137,9 @@
   return indexer.named_char_index(s);
 }
 
+#ifdef	NIPPON
+int font::wchar_index(wchar wc)
+{
+  return indexer.wchar_index(wc);
+}
+#endif
diff -uNr groff-1.19.1.orig/src/libs/libgroff/searchpath.cpp groff-1.19.1/src/libs/libgroff/searchpath.cpp
--- groff-1.19.1.orig/src/libs/libgroff/searchpath.cpp	2003-12-06 21:28:56.000000000 +0900
+++ groff-1.19.1/src/libs/libgroff/searchpath.cpp	2005-02-23 16:32:33.210766688 +0900
@@ -19,6 +19,7 @@
 with groff; see the file COPYING.  If not, write to the Free Software
 Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
 
+#include "encoding.h"
 #include "lib.h"
 
 #include <stdlib.h>
diff -uNr groff-1.19.1.orig/src/libs/libgroff/tmpfile.cpp groff-1.19.1/src/libs/libgroff/tmpfile.cpp
--- groff-1.19.1.orig/src/libs/libgroff/tmpfile.cpp	2003-10-21 18:32:49.000000000 +0900
+++ groff-1.19.1/src/libs/libgroff/tmpfile.cpp	2005-02-23 16:32:33.210766688 +0900
@@ -24,6 +24,7 @@
 #include <errno.h>
 #include <stdlib.h>
 
+#include "encoding.h"
 #include "posix.h"
 #include "errarg.h"
 #include "error.h"
diff -uNr groff-1.19.1.orig/src/preproc/eqn/eqn.h groff-1.19.1/src/preproc/eqn/eqn.h
--- groff-1.19.1.orig/src/preproc/eqn/eqn.h	2001-08-20 06:32:29.000000000 +0900
+++ groff-1.19.1/src/preproc/eqn/eqn.h	2005-02-23 16:32:33.210766688 +0900
@@ -23,6 +23,9 @@
 #include <assert.h>
 #include <stdlib.h>
 #include <errno.h>
+#ifdef	NIPPON
+# include "eucmac.h"
+#endif
 #include "cset.h"
 #include "errarg.h"
 #include "error.h"
diff -uNr groff-1.19.1.orig/src/preproc/eqn/eqn.y groff-1.19.1/src/preproc/eqn/eqn.y
--- groff-1.19.1.orig/src/preproc/eqn/eqn.y	2004-04-08 00:36:41.000000000 +0900
+++ groff-1.19.1/src/preproc/eqn/eqn.y	2005-02-23 16:32:33.210766688 +0900
@@ -21,6 +21,7 @@
 #include <string.h>
 #include <stdlib.h>
 
+#include "encoding.h"
 #include "lib.h"
 #include "box.h"
 extern int non_empty_flag;
diff -uNr groff-1.19.1.orig/src/preproc/eqn/lex.cpp groff-1.19.1/src/preproc/eqn/lex.cpp
--- groff-1.19.1.orig/src/preproc/eqn/lex.cpp	2003-02-08 23:48:57.000000000 +0900
+++ groff-1.19.1/src/preproc/eqn/lex.cpp	2005-02-23 16:32:33.211766536 +0900
@@ -23,6 +23,7 @@
 #include "eqn_tab.h"
 #include "stringclass.h"
 #include "ptable.h"
+#include "encoding.h"
 
 struct definition {
   char is_macro;
@@ -375,6 +376,11 @@
 	lex_error("invalid input character code %1", c);
       else {
 	line += char(c);
+#ifdef	NIPPON
+	if (encoding->is_wchar_byte(c)) {
+	  line += char(getc(fp));
+	}
+#endif
 	if (c == '\n') 
 	  break;
       }
diff -uNr groff-1.19.1.orig/src/preproc/eqn/main.cpp groff-1.19.1/src/preproc/eqn/main.cpp
--- groff-1.19.1.orig/src/preproc/eqn/main.cpp	2002-02-20 01:28:31.000000000 +0900
+++ groff-1.19.1/src/preproc/eqn/main.cpp	2005-02-23 16:32:33.211766536 +0900
@@ -258,6 +258,7 @@
   program_name = argv[0];
   static char stderr_buf[BUFSIZ];
   setbuf(stderr, stderr_buf);
+  init_encoding_handler();
   int opt;
   int load_startup_file = 1;
   static const struct option long_options[] = {
diff -uNr groff-1.19.1.orig/src/preproc/eqn/text.cpp groff-1.19.1/src/preproc/eqn/text.cpp
--- groff-1.19.1.orig/src/preproc/eqn/text.cpp	2003-02-09 00:00:18.000000000 +0900
+++ groff-1.19.1/src/preproc/eqn/text.cpp	2005-02-23 16:32:33.212766384 +0900
@@ -21,13 +21,20 @@
 #include "eqn.h"
 #include "pbox.h"
 #include "ptable.h"
+#include "encoding.h"
 
 class char_box : public simple_box {
   unsigned char c;
+#ifdef	NIPPON
+  wchar wc;
+#endif
   char next_is_italic;
   char prev_is_italic;
 public:
   char_box(unsigned char);
+#ifdef	NIPPON
+  char_box(unsigned char, wchar);
+#endif
   void debug_print();
   void output();
   int is_char();
@@ -166,10 +173,20 @@
 
 char_box::char_box(unsigned char cc)
 : c(cc), next_is_italic(0), prev_is_italic(0)
+#ifdef	NIPPON
+, wc(cc)
+#endif
 {
   spacing_type = char_table[c].spacing_type;
 }
 
+#ifdef	NIPPON
+char_box::char_box(unsigned char cc, wchar wc)
+: c(cc), wc(wc), prev_is_italic(0), next_is_italic(0)
+{
+}
+#endif
+
 void char_box::hint(unsigned flags)
 {
   if (flags & HINT_PREV_IS_ITALIC)
@@ -188,7 +205,11 @@
   if (c == '\\')
     fputs("\\e", stdout);
   else
+#ifdef	NIPPON
+    encoding->put_wchar(wc, stdout);
+#else
     putchar(c);
+#endif
   if (!next_is_italic)
     fputs("\\/", stdout);
   else
@@ -497,6 +518,14 @@
       break;
     default:
     normal_char:
+#ifdef	NIPPON
+      if (encoding->is_wchar_byte(c)) {
+        int i = 1;
+	wchar wc = encoding->make_wchar(c, (unsigned char *)s, &i);
+	b = new char_box('A', wc); // char_info of wc is same the 'A'.
+	s += i;
+      } else
+#endif
       b = new char_box(c);
       break;
     }
diff -uNr groff-1.19.1.orig/src/roff/groff/groff.cpp groff-1.19.1/src/roff/groff/groff.cpp
--- groff-1.19.1.orig/src/roff/groff/groff.cpp	2004-04-07 23:40:23.000000000 +0900
+++ groff-1.19.1/src/roff/groff/groff.cpp	2005-02-23 16:32:33.212766384 +0900
@@ -108,6 +108,7 @@
   program_name = argv[0];
   static char stderr_buf[BUFSIZ];
   setbuf(stderr, stderr_buf);
+  init_encoding_handler();
   assert(NCOMMANDS <= MAX_COMMANDS);
   string Pargs, Largs, Fargs;
   int vflag = 0;
diff -uNr groff-1.19.1.orig/src/roff/groff/groff.man groff-1.19.1/src/roff/groff/groff.man
--- groff-1.19.1.orig/src/roff/groff/groff.man	2004-01-15 15:39:31.000000000 +0900
+++ groff-1.19.1/src/roff/groff/groff.man	2005-02-23 16:32:33.213766232 +0900
@@ -1017,6 +1017,10 @@
 Text output using the EBCDIC code page IBM cp1047 (e.g. OS/390 Unix).
 .
 .TP
+.B nippon
+Text output using the Japanese-EUC character set.
+.
+.TP
 .B dvi
 TeX DVI format.
 .
@@ -1025,6 +1029,12 @@
 HTML output.
 .
 .TP
+.B ascii8
+For typewriter-like devices.  Unlike
+.BR ascii ,
+this device is 8 bit clean.  This device is intended to be used
+for codesets other than ASCII and ISO-8859-1.
+.TP
 .B latin1
 Text output using the ISO \%Latin-1 (ISO \%8859-1) character set; see
 .BR \%iso_8859_1 (7).
diff -uNr groff-1.19.1.orig/src/roff/nroff/nroff.man groff-1.19.1/src/roff/nroff/nroff.man
--- groff-1.19.1.orig/src/roff/nroff/nroff.man	2004-01-06 07:41:36.000000000 +0900
+++ groff-1.19.1/src/roff/nroff/nroff.man	2005-02-23 16:32:33.213766232 +0900
@@ -48,8 +48,10 @@
 command using groff.
 Only 
 .BR ascii ,
+.BR ascii8 ,
 .BR latin1 ,
 .BR utf8 ,
+.BR nippon ,
 and
 .B cp1047
 are valid arguments for the
diff -uNr groff-1.19.1.orig/src/roff/nroff/nroff.sh groff-1.19.1/src/roff/nroff/nroff.sh
--- groff-1.19.1.orig/src/roff/nroff/nroff.sh	2004-04-06 23:10:32.000000000 +0900
+++ groff-1.19.1/src/roff/nroff/nroff.sh	2005-02-23 16:32:33.214766080 +0900
@@ -12,6 +12,8 @@
     T=-Tlatin1 ;;
   IBM-1047)
     T=-Tcp1047 ;;
+  EUC-JP)
+    T=-Tnippon ;;
   *)
     case "${LC_ALL-${LC_CTYPE-${LANG}}}" in
       *.UTF-8)
@@ -20,6 +22,8 @@
         T=-Tlatin1 ;;
       *.IBM-1047)
         T=-Tcp1047 ;;
+      ja_JP.ujis | ja_JP.eucJP)
+	T=-Tnippon ;;
       *)
         case "$LESSCHARSET" in
           utf-8)
@@ -28,8 +32,10 @@
             T=-Tlatin1 ;;
           cp1047)
             T=-Tcp1047 ;;
+          japanese)
+	    T=-Tnippon ;;
           *)
-            T=-Tascii ;;
+            T=-Tascii8 ;;
           esac ;;
      esac ;;
 esac
@@ -52,7 +58,7 @@
       exit 1 ;;
     -[iptSUC] | -[dmrno]*)
       opts="$opts $1" ;;
-    -Tascii | -Tlatin1 | -Tutf8 | -Tcp1047)
+    -Tascii | -Tlatin1 | -Tutf8 | -Tcp1047 | -Tascii8 | -Tnippon)
       T=$1 ;;
     -T*)
       # ignore other devices
diff -uNr groff-1.19.1.orig/src/roff/troff/charinfo.h groff-1.19.1/src/roff/troff/charinfo.h
--- groff-1.19.1.orig/src/roff/troff/charinfo.h	2002-12-22 18:26:50.000000000 +0900
+++ groff-1.19.1/src/roff/troff/charinfo.h	2005-02-23 16:32:33.214766080 +0900
@@ -29,9 +29,16 @@
   macro *mac;
   unsigned char special_translation;
   unsigned char hyphenation_code;
+#ifdef NIPPON
+  unsigned short flags;
+#else
   unsigned char flags;
+#endif
   unsigned char ascii_code;
   unsigned char asciify_code;
+#ifdef NIPPON
+  wchar wchar_code;
+#endif
   char not_found;
   char transparent_translate;	// non-zero means translation applies
 				// to transparent throughput
@@ -47,6 +54,11 @@
     OVERLAPS_VERTICALLY = 16,
     TRANSPARENT = 32,
     NUMBERED = 64
+#ifdef	NIPPON
+    ,
+    DONT_BREAK_BEFORE = 0x100,	// 256, pre kinsoku
+    DONT_BREAK_AFTER = 0x200	// 512, post kinsoku
+#endif
   };
   enum {
     TRANSLATE_NONE,
@@ -74,7 +86,11 @@
   int get_translation_input();
   charinfo *get_translation(int = 0);
   void set_translation(charinfo *, int, int);
+#ifdef NIPPON
+  void set_flags(unsigned short);
+#else
   void set_flags(unsigned char);
+#endif
   void set_special_translation(int, int);
   int get_special_translation(int = 0);
   macro *set_macro(macro *);
@@ -87,6 +103,12 @@
   int is_normal();
   int is_fallback();
   int is_special();
+#ifdef	NIPPON
+  wchar get_wchar_code();
+  void set_wchar_code(wchar);
+  int cannot_break_before(); // pre kinsoku
+  int cannot_break_after(); // post kinsoku
+#endif
   symbol *get_symbol();
 };
 
@@ -144,6 +166,19 @@
   return mode == CHAR_SPECIAL;
 }
 
+#ifdef	NIPPON
+inline int charinfo::cannot_break_before()
+{
+  return flags & DONT_BREAK_BEFORE;
+}
+
+inline int charinfo::cannot_break_after()
+{
+  return flags & DONT_BREAK_AFTER;
+}
+
+#endif
+
 inline charinfo *charinfo::get_translation(int transparent_throughput)
 {
   return (transparent_throughput && !transparent_translate
@@ -166,7 +201,18 @@
   return (translate_input ? asciify_code : 0);
 }
 
+#ifdef	NIPPON
+inline wchar charinfo::get_wchar_code()
+{
+  return wchar_code;
+}
+#endif
+
+#ifdef	NIPPON
+inline void charinfo::set_flags(unsigned short c)
+#else
 inline void charinfo::set_flags(unsigned char c)
+#endif
 {
   flags = c;
 }
diff -uNr groff-1.19.1.orig/src/roff/troff/env.cpp groff-1.19.1/src/roff/troff/env.cpp
--- groff-1.19.1.orig/src/roff/troff/env.cpp	2004-05-06 03:09:05.000000000 +0900
+++ groff-1.19.1/src/roff/troff/env.cpp	2005-02-23 16:32:33.216765776 +0900
@@ -31,6 +31,7 @@
 #include "charinfo.h"
 #include "macropath.h"
 #include "input.h"
+#include "font.h"
 #include <math.h>
 
 symbol default_family("T");
@@ -288,10 +289,82 @@
   else {
     if (line == 0)
       start_line();
+#ifdef	NIPPON
+    if (!ci->get_wchar_code()) {
+      /*
+       * This node is a ASCII character node.
+       */
+      if (!pre_char_is_ascii && enable_wcharkern && !hwkern.is_zero()) {
+	/*
+	 * Insert a little space node between EUC and ASCII.
+	 */
+	word_space_node *ws;
+
+	if (ci->ends_sentence() || ci->transparent() || ci->cannot_break_before())
+	  ws = new unbreakable_space_node(hwkern, get_fill_color());
+	else
+	  ws = new word_space_node(hwkern, get_fill_color(),
+				   new width_list(env_space_width(this),
+						  env_sentence_space_width(this)));
+	curenv->add_node(ws);
+      }
+      pre_char_is_ascii = 1;
+      pre_wchar_cannot_break_after = 0;
+    } else {
+      /*
+       * This node is a EUC charcater node.
+       */
+      if (!pre_char_is_ascii && line->get_node_type() == NODE_NEWLINE_SPACE) {
+	/*
+	 * remove a newline-node.
+	 */
+	node *ns_node = line;
+	line = line->next;
+	width_total -= ns_node->width();
+	space_total -= ns_node->nspaces();
+	delete ns_node;
+      }
+
+      if (!pre_wchar_cannot_break_after && !ci->cannot_break_before()) {
+	/*
+	 * add a zero-width-space-node before EUC charcater node.
+	 */
+	add_node(new kword_space_node(get_fill_color()));
+	met_with_kword_space = 1;
+      }
+      pre_wchar_cannot_break_after = ci->cannot_break_after();
+
+      if (pre_char_is_ascii && enable_wcharkern && !hwkern.is_zero()) {
+	/*
+	 * Insert a little space node between ASCII and EUC.
+	 */
+	unbreakable_space_node *ws =
+	  new unbreakable_space_node(hwkern, get_fill_color());
+	curenv->add_node(ws);
+      }
+      pre_char_is_ascii = 0;
+
+      if (!vlower.is_zero()) {
+	/*
+	 * Lower a EUC charcater node.
+	 */
+	curenv->add_node(new vmotion_node(vlower, get_fill_color())); // lower
+      }
+    }
+#endif
     if (ci != hyphen_indicator_char)
       line = line->add_char(ci, this, &width_total, &space_total);
     else
       line = line->add_discretionary_hyphen();
+#ifdef	NIPPON
+    enable_wcharkern = 1;
+    if (!vlower.is_zero() && ci->get_wchar_code()) {
+      /*
+       * Raise a EUC charcater node.
+       */
+      curenv->add_node(new vmotion_node(-vlower, get_fill_color())); // raise
+    }
+#endif
   }
 }
 
@@ -396,7 +469,11 @@
     width_total += x;
     return;
   }
+#ifdef	NIPPON
+  add_node(new newline_space_node(x, get_fill_color())); // This node may be removed.
+#else
   add_node(new word_space_node(x, get_fill_color(), w));
+#endif
   possibly_break_line(0, spread_flag);
   spread_flag = 0;
 }
@@ -482,6 +559,27 @@
     warning(WARN_FONT, "bad font number");
 }
 
+#ifdef	NIPPON
+void environment::change_curfont(symbol nm)
+{
+  int n = symbol_fontno(nm);
+  if (n < 0) {
+    n = next_available_font_position();
+    if (!mount_font(n, nm))
+      return;
+  }
+  fontno = n;
+}
+
+void environment::change_curfont(int n)
+{
+  if (is_good_fontno(n))
+    fontno = n;
+  else
+    error("bad font number");
+}
+#endif /* NIPPON */
+
 void environment::set_family(symbol fam)
 {
   if (interrupted)
@@ -741,6 +839,16 @@
   control_char(e->control_char),
   no_break_control_char(e->no_break_control_char),
   hyphen_indicator_char(e->hyphen_indicator_char)
+#ifdef	NIPPON
+  ,
+  stretch_threshold(e->stretch_threshold),
+  pre_wchar_cannot_break_after(0),
+  pre_char_is_ascii(-1),
+  enable_wcharkern(0),
+  met_with_kword_space(0),
+  hwkern(font::wcharkern),
+  vlower(font::lowerwchar)
+#endif
 {
 }
 
@@ -1783,6 +1891,9 @@
   target_text_length = line_length - saved_indent;
   width_total = H0;
   space_total = 0;
+#ifdef	NIPPON
+  enable_wcharkern = 0;
+#endif
 }
 
 hunits environment::get_hyphenation_space()
@@ -1821,6 +1932,23 @@
   skip_line();
 }
 
+#ifdef NIPPON
+void stretch_threshold_request()
+{
+  int n;
+  if (has_arg() && get_integer(&n)) {
+      if (n < 0 || n > 100) {
+	  warning(WARN_RANGE, "stretch threshold value %1 out of range", n);
+      } else {
+	  curenv->stretch_threshold = n;
+      }
+  } else {
+      curenv->stretch_threshold = 0;
+  }
+  skip_line();
+}
+#endif
+
 breakpoint *environment::choose_breakpoint()
 {
   hunits x = width_total;
@@ -2021,6 +2149,30 @@
 	     // When a macro follows a paragraph in fill mode, the
 	     // current line should not be empty.
 	     || (width_total - line->width()) > target_text_length)) {
+#ifdef NIPPON
+    if (met_with_kword_space) {
+      node *linep = line;
+      node *prep = 0;
+      while (linep->next) {
+      if (linep->next->get_node_type() == NODE_GLYPH)
+        prep = 0;
+      else if (linep->next->get_node_type() == NODE_KWORD_SPACE)
+        prep = linep;
+        linep = linep->next;
+      }
+      if (prep) {
+        /*
+         * delete a kword_space_node which is in the top of line.
+         */
+        linep = prep->next;
+        prep->next = linep->next;
+        width_total -= linep->width();
+        space_total -= linep->nspaces();
+        delete linep;
+      }
+      met_with_kword_space = 0;
+    }
+#endif
     hyphenate_line(start_here);
     breakpoint *bp = choose_breakpoint();
     if (bp == 0)
@@ -2033,6 +2185,15 @@
     bp->nd->split(bp->index, &pre, &post);
     *ndp = post;
     hunits extra_space_width = H0;
+#ifdef NIPPON
+    int sv_adjust_mode = adjust_mode;
+    if (stretch_threshold) {
+	int ratio = bp->width * 100 / target_text_length;
+	if ( ratio < stretch_threshold) {
+	    adjust_mode = ADJUST_LEFT;
+	}
+    }
+#endif
     switch(adjust_mode) {
     case ADJUST_BOTH:
       if (bp->nspaces != 0)
@@ -2048,6 +2209,9 @@
       saved_indent += target_text_length - bp->width;
       break;
     }
+#ifdef NIPPON
+    adjust_mode = sv_adjust_mode;
+#endif
     distribute_space(pre, bp->nspaces, extra_space_width);
     hunits output_width = bp->width + extra_space_width;
     input_line_start -= output_width;
@@ -3222,6 +3386,9 @@
   init_request("nn", no_number);
   init_request("ps", point_size);
   init_request("pvs", post_vertical_spacing);
+#ifdef NIPPON
+  init_request("stt", stretch_threshold_request);
+#endif
   init_request("rj", right_justify);
   init_request("sizes", override_sizes);
   init_request("ss", space_size);
diff -uNr groff-1.19.1.orig/src/roff/troff/env.h groff-1.19.1/src/roff/troff/env.h
--- groff-1.19.1.orig/src/roff/troff/env.h	2004-04-17 14:08:17.000000000 +0900
+++ groff-1.19.1/src/roff/troff/env.h	2005-02-23 16:32:33.217765624 +0900
@@ -183,6 +183,15 @@
 #ifdef WIDOW_CONTROL
   int widow_control;
 #endif /* WIDOW_CONTROL */
+#ifdef	NIPPON
+  int stretch_threshold;
+  int pre_wchar_cannot_break_after;
+  int pre_char_is_ascii;
+  int enable_wcharkern;
+  int met_with_kword_space;
+  hunits hwkern;
+  vunits vlower;
+#endif
   int ignore_next_eol;
   int emitted_node;    // have we emitted a node since the last html eol tag?
   color *glyph_color;
@@ -279,6 +288,10 @@
   void wrap_up_tab();
   void set_font(int);
   void set_font(symbol);
+#ifdef	NIPPON
+  void change_curfont(int);
+  void change_curfont(symbol);
+#endif
   void set_family(symbol);
   void set_size(int);
   void set_char_height(int);
@@ -349,6 +362,9 @@
 #ifdef WIDOW_CONTROL
   friend void widow_control_request();
 #endif /* WIDOW_CONTROL */
+#ifdef	NIPPON
+  friend void stretch_threshold_request();
+#endif
 
   friend void do_divert(int append, int boxing);
 };
diff -uNr groff-1.19.1.orig/src/roff/troff/input.cpp groff-1.19.1/src/roff/troff/input.cpp
--- groff-1.19.1.orig/src/roff/troff/input.cpp	2004-05-06 01:41:58.000000000 +0900
+++ groff-1.19.1/src/roff/troff/input.cpp	2005-02-23 16:40:53.158763040 +0900
@@ -34,6 +34,7 @@
 #include "macropath.h"
 #include "defs.h"
 #include "input.h"
+#include "encoding.h"
 #include "unicode.h"
 
 // Needed for getpid() and isatty()
@@ -88,6 +89,27 @@
 charinfo *charset_table[256];
 unsigned char hpf_code_table[256];
 
+#ifdef	NIPPON
+charinfo **wcharset_table = NULL;
+
+charinfo *wcharset_table_entry(wchar wc)
+{
+  return wcharset_table[encoding->wchar_table_index(wc)];
+}
+
+static int mount_on_demand(const char *font_name)
+{
+  const char **p = font::on_demand_fonts;
+
+  while (p && *p) {
+    if (strcmp(*p, font_name) == 0)
+      return(1);
+    p++;
+  }
+  return(0);
+}    
+#endif /* NIPPON */
+
 static int warning_mask = DEFAULT_WARNING_MASK;
 static int inhibit_errors = 0;
 static int ignoring = 0;
@@ -1544,6 +1566,19 @@
   type = TOKEN_NEWLINE;
 }
 
+#ifdef NIPPON
+class encoding_istream_input : public encoding_istream {
+private:
+  node **np;
+public:
+  encoding_istream_input(node **n) : np(n) {};
+  ~encoding_istream_input() {};
+  int getbyte() { return input_stack::get(np); };
+  int peekbyte() { return input_stack::peek(); };
+  void ungetbyte(int ch) { return; };
+};
+#endif
+
 void token::next()
 {
   if (nd) {
@@ -1553,6 +1588,10 @@
   units x;
   for (;;) {
     node *n = 0;
+#ifdef NIPPON
+    encoding_istream_input einput(&n);
+#endif
+
     int cc = input_stack::get(&n);
     if (cc != escape_char || escape_char == 0) {
     handle_normal_char:
@@ -1707,8 +1746,22 @@
 	}
 	return;
       default:
+#ifdef	NIPPON
+	wc = encoding->make_wchar(cc, einput);
+	if (encoding->is_wchar_code(wc)) {
+	  type = TOKEN_WCHAR;
+	  c = 0;
+	} else if (wc == ' ') {
+	  type = TOKEN_SPACE;
+	  c = cc;
+	} else {
+	  type = TOKEN_CHAR;
+	  c = cc;
+	}
+#else
 	type = TOKEN_CHAR;
 	c = cc;
+#endif
 	return;
       }
     }
@@ -2103,6 +2156,10 @@
   switch(type) {
   case TOKEN_CHAR:
     return c == t.c;
+#ifdef	NIPPON
+  case TOKEN_WCHAR:
+    return wc == t.wc;
+#endif
   case TOKEN_SPECIAL:
     return nm == t.nm;
   case TOKEN_NUMBERED_CHAR:
@@ -2581,6 +2638,9 @@
 {
   int_stack trap_bol_stack;
   int bol = 1;
+#ifdef NIPPON
+  int fontno;
+#endif
   for (;;) {
     int suppress_next = 0;
     switch (tok.type) {
@@ -2619,6 +2679,33 @@
 	}
 	break;
       }
+#ifdef	NIPPON
+    case token::TOKEN_WCHAR:
+      {
+	wchar wch = tok.wc;
+
+	if (possibly_handle_first_page_transition())
+	  ;
+	else {
+	  for (;;) {
+	    fontno = curenv->get_font(); // save a current font #
+	    if (is_boldfont(fontno))
+	      curenv->change_curfont(symbol("G")); // set Gothic font
+	    else
+	      curenv->change_curfont(symbol("M")); // set Mintyo font
+	    curenv->add_char(wcharset_table_entry(wch));
+	    curenv->change_curfont(fontno); // restore a saved font #
+	    tok.next();
+	    if (tok.type != token::TOKEN_WCHAR)
+	      break;
+	    wch = tok.wc;
+	  }
+	  suppress_next = 1;
+	  bol = 0;
+	}
+	break;
+      }
+#endif	/* NIPPON */
     case token::TOKEN_TRANSPARENT:
       {
 	if (bol) {
@@ -5698,6 +5785,37 @@
   }
 }
 
+#ifdef NIPPON
+static void init_wchar_charinfo(wchar wc, void *arg)
+{
+  char buf[16];
+  charinfo *ci;
+  sprintf(buf, "wchar%x", wc);
+  wcharset_table[encoding->wchar_table_index(wc)] = get_charinfo(symbol(buf));
+  ci = wcharset_table[encoding->wchar_table_index(wc)];
+  ci->set_wchar_code(wc);
+}
+
+#if 0
+void encoding_request()
+{
+  symbol nm = get_long_name(1);
+  if (nm.is_null())
+    skip_line();
+  else {
+    while (!tok.newline() && !tok.eof())
+      tok.next();
+    if (wcharset_table)
+      delete [] wcharset_table;
+    new_encoding_handler(nm.contents());
+    wcharset_table = (charinfo**)encoding->init_table();
+    encoding->foreach_wchar(init_wchar_charinfo, wcharset_table);
+    tok.next();
+  }
+}
+#endif
+#endif
+
 const char *asciify(int c)
 {
   static char buf[3];
@@ -6202,6 +6320,10 @@
 {
   if (type == TOKEN_CHAR)
     return charset_table[c];
+#ifdef	NIPPON
+  if (type == TOKEN_WCHAR)
+    return wcharset_table_entry(wc);
+#endif
   if (type == TOKEN_SPECIAL)
     return get_charinfo(nm);
   if (type == TOKEN_NUMBERED_CHAR)
@@ -6250,10 +6372,24 @@
   hunits w;
   int s;
   node *n = 0;
+#ifdef NIPPON
+  int fontno;
+#endif
   switch (type) {
   case TOKEN_CHAR:
     *pp = (*pp)->add_char(charset_table[c], curenv, &w, &s);
     break;
+#ifdef	NIPPON
+  case TOKEN_WCHAR:
+    fontno = curenv->get_font(); // save a current font #
+    if (is_boldfont(fontno))
+      curenv->change_curfont(symbol("G")); // set Gothic font
+    else
+      curenv->change_curfont(symbol("M")); // set Mintyo font
+    *pp = (*pp)->add_char(wcharset_table_entry(wc), curenv, &w, &s);
+    curenv->change_curfont(fontno); // restore a saved font #
+    break;
+#endif
   case TOKEN_DUMMY:
     n = new dummy_node;
     break;
@@ -6316,6 +6452,9 @@
 
 void token::process()
 {
+#ifdef NIPPON
+  int fontno;
+#endif
   if (possibly_handle_first_page_transition())
     return;
   switch (type) {
@@ -6326,6 +6465,17 @@
   case TOKEN_CHAR:
     curenv->add_char(charset_table[c]);
     break;
+#ifdef	NIPPON
+  case TOKEN_WCHAR:
+    fontno = curenv->get_font(); // save a current font #
+    if (is_boldfont(fontno))
+      curenv->change_curfont(symbol("G")); // set Gothic font
+    else
+      curenv->change_curfont(symbol("M")); // set Mintyo font
+    curenv->add_char(wcharset_table_entry(wc));
+    curenv->change_curfont(fontno); // restore a saved font #
+    break;
+#endif
   case TOKEN_DUMMY:
     curenv->add_node(new dummy_node);
     break;
@@ -6953,6 +7103,7 @@
   program_name = argv[0];
   static char stderr_buf[BUFSIZ];
   setbuf(stderr, stderr_buf);
+  init_encoding_handler();
   int c;
   string_list *macros = 0;
   string_list *register_assignments = 0;
@@ -7091,6 +7242,10 @@
   set_string(".T", device);
   init_charset_table();
   init_hpf_code_table();
+#ifdef NIPPON
+  wcharset_table = (charinfo**)encoding->init_table();
+  encoding->foreach_wchar(init_wchar_charinfo, wcharset_table);
+#endif
   if (!font::load_desc())
     fatal("sorry, I can't continue");
   units_per_inch = font::res;
@@ -7113,6 +7268,9 @@
     // In the DESC file a font name of 0 (zero) means leave this
     // position empty.
     if (strcmp(font::font_name_table[i], "0") != 0)
+#ifdef NIPPON
+      if (!mount_on_demand(font::font_name_table[i]))
+#endif
       mount_font(j, symbol(font::font_name_table[i]));
   curdiv = topdiv = new top_level_diversion;
   if (nflag)
@@ -7296,6 +7454,9 @@
   init_request("pi", pipe_output);
   init_request("pm", print_macros);
   init_request("psbb", ps_bbox_request);
+#if 0 /* def NIPPON */
+  init_request("encoding", encoding_request);
+#endif
 #ifndef POPEN_MISSING
   init_request("pso", pipe_source);
 #endif /* not POPEN_MISSING */
@@ -7787,6 +7948,9 @@
 charinfo::charinfo(symbol s)
 : translation(0), mac(0), special_translation(TRANSLATE_NONE),
   hyphenation_code(0), flags(0), ascii_code(0), asciify_code(0),
+#ifdef NIPPON
+  wchar_code(0),
+#endif
   not_found(0), transparent_translate(1), translate_input(0),
   mode(CHAR_NORMAL), nm(s)
 {
@@ -7831,6 +7995,13 @@
   asciify_code = c;
 }
 
+#ifdef NIPPON
+void charinfo::set_wchar_code(wchar wc)
+{
+  wchar_code = wc;
+}
+#endif
+
 macro *charinfo::set_macro(macro *m)
 {
   macro *tem = mac;
@@ -7893,6 +8064,13 @@
 int font::name_to_index(const char *nm)
 {
   charinfo *ci;
+#ifdef	NIPPON
+  int i = 1;
+  wchar wc = encoding->make_wchar(nm[0], (const unsigned char *)nm, &i);
+  if (encoding->is_wchar_code(wc)) {
+    ci = wcharset_table_entry(wc);
+  } else
+#endif
   if (nm[1] == 0)
     ci = charset_table[nm[0] & 0xff];
   else if (nm[0] == '\\' && nm[2] == 0)
@@ -7909,3 +8087,10 @@
 {
   return get_charinfo_by_number(n)->get_index();
 }
+
+#ifdef	NIPPON
+int font::wchar_index(wchar wc)
+{
+  return(wcharset_table_entry(wc)->get_index());
+}
+#endif
diff -uNr groff-1.19.1.orig/src/roff/troff/node.cpp groff-1.19.1/src/roff/troff/node.cpp
--- groff-1.19.1.orig/src/roff/troff/node.cpp	2004-05-09 02:00:04.000000000 +0900
+++ groff-1.19.1/src/roff/troff/node.cpp	2005-02-23 16:45:07.763057304 +0900
@@ -37,6 +37,7 @@
 #include "input.h"
 #include "div.h"
 #include "geometry.h"
+#include "encoding.h"
 #include "stringclass.h"
 
 #include "nonposix.h"
@@ -151,6 +152,9 @@
   int is_special();
   int is_style();
   friend symbol get_font_name(int, environment *);
+#ifdef NIPPON
+  friend int is_boldfont(int);
+#endif
 };
 
 class tfont_spec {
@@ -399,6 +403,14 @@
   return f;
 }
 
+#ifdef        NIPPON
+int is_boldfont(int fontno)
+{
+  hunits h;
+  return font_table[fontno]->get_bold(&h);
+}
+#endif
+
 hunits font_info::get_space_width(font_size fs, int space_sz)
 {
   if (is_constant_spaced == CONSTANT_SPACE_NONE)
@@ -746,7 +758,11 @@
   symbol *font_position;
   int nfont_positions;
   enum { TBUF_SIZE = 256 };
+#ifdef	NIPPON
+  wchar tbuf[TBUF_SIZE];
+#else
   char tbuf[TBUF_SIZE];
+#endif
   int tbuf_len;
   int tbuf_kern;
   int begun_page;
@@ -756,6 +772,9 @@
   void put(int i);
   void put(unsigned int i);
   void put(const char *s);
+#ifdef	NIPPON
+  void putw(const wchar wc);
+#endif
   void set_font(tfont *tf);
   void flush_tbuf();
 public:
@@ -801,6 +820,13 @@
   putc(c, fp);
 }
 
+#ifdef	NIPPON
+inline void troff_output_file::putw(const wchar wc)
+{
+  encoding->put_wchar(wc, fp);
+}
+#endif
+
 inline void troff_output_file::put(unsigned char c)
 {
   putc(c, fp);
@@ -957,7 +983,11 @@
   check_output_limits(hpos, vpos - current_size);
 
   for (int i = 0; i < tbuf_len; i++)
+#ifdef NIPPON
+    putw(tbuf[i]);
+#else
     put(tbuf[i]);
+#endif
   put('\n');
   tbuf_len = 0;
 }
@@ -986,7 +1016,13 @@
     return;
   }
   set_font(tf);
+#ifdef NIPPON
+  wchar c = ci->get_wchar_code();
+  if (c == '\0')
+    c = ci->get_ascii_code();
+#else
   unsigned char c = ci->get_ascii_code();
+#endif
   if (c == '\0') {
     glyph_color(gcol);
     fill_color(fcol);
@@ -1043,7 +1079,11 @@
 	&& n > 0 && n < 100 && !force_motion) {
       put(char(n/10 + '0'));
       put(char(n%10 + '0'));
+#ifdef NIPPON
+      putw(c);
+#else
       put(c);
+#endif
       output_hpos = hpos;
     }
     else {
@@ -1051,7 +1091,11 @@
       fill_color(fcol);
       do_motion();
       put('c');
+#ifdef NIPPON
+      putw(c);
+#else
       put(c);
+#endif
     }
     hpos += w.to_units() + kk;
   }
@@ -1064,7 +1108,13 @@
   if (!is_on())
     return;
   set_font(tf);
+#ifdef NIPPON
+  wchar c = ci->get_wchar_code();
+  if (c == '\0')
+    c = ci->get_ascii_code();
+#else
   unsigned char c = ci->get_ascii_code();
+#endif
   if (c == '\0') {
     glyph_color(gcol);
     fill_color(fcol);
@@ -1094,7 +1144,11 @@
 	&& n > 0 && n < 100) {
       put(char(n/10 + '0'));
       put(char(n%10 + '0'));
+#ifdef NIPPON
+      putw(c);
+#else
       put(c);
+#endif
       output_hpos = hpos;
     }
     else {
@@ -1103,7 +1157,11 @@
       flush_tbuf();
       do_motion();
       put('c');
+#ifdef NIPPON
+      putw(c);
+#else
       put(c);
+#endif
     }
   }
 }
@@ -1797,6 +1855,9 @@
   int same(node *);
   const char *type();
   int force_tprint();
+#ifdef	NIPPON
+  node_type get_node_type();
+#endif
 };
 
 glyph_node *glyph_node::free_list = 0;
@@ -3605,6 +3666,49 @@
 {
 }
 
+#ifdef	NIPPON
+kword_space_node::kword_space_node(color *c, node *x) : word_space_node(0, c, new width_list(0, 0), x)
+{}
+
+node *kword_space_node::copy()
+{
+    return new kword_space_node(col, 0);
+}
+newline_space_node::newline_space_node(hunits d, color *c, node *x) : word_space_node(d, c, new width_list(0, 0), x)
+{}
+
+node *newline_space_node::copy()
+{
+    return new newline_space_node(n, col);
+}
+
+const char *kword_space_node::type()
+{
+  return "kword_space_node";
+}
+const char *newline_space_node::type()
+{
+  return "newline_space_node";
+}
+
+node_type node::get_node_type()
+{
+    return NODE_ANOTHER;
+}
+node_type glyph_node::get_node_type()
+{
+    return NODE_GLYPH;
+}
+node_type kword_space_node::get_node_type()
+{
+    return NODE_KWORD_SPACE;
+}
+node_type newline_space_node::get_node_type()
+{
+    return NODE_NEWLINE_SPACE;
+}
+#endif
+
 int special_node::same(node *n)
 {
   return mac == ((special_node *)n)->mac
diff -uNr groff-1.19.1.orig/src/roff/troff/node.h groff-1.19.1/src/roff/troff/node.h
--- groff-1.19.1.orig/src/roff/troff/node.h	2004-04-17 14:06:50.000000000 +0900
+++ groff-1.19.1/src/roff/troff/node.h	2005-02-23 16:41:30.080150136 +0900
@@ -30,6 +30,9 @@
 void hyphenate(hyphen_list *, unsigned);
 
 enum hyphenation_type { HYPHEN_MIDDLE, HYPHEN_BOUNDARY, HYPHEN_INHIBIT };
+#ifdef	NIPPON
+enum node_type {NODE_GLYPH, NODE_KWORD_SPACE, NODE_NEWLINE_SPACE, NODE_ANOTHER};
+#endif
 
 class ascii_output_file;
 
@@ -105,6 +108,9 @@
 
   virtual int same(node *) = 0;
   virtual const char *type() = 0;
+#ifdef	NIPPON
+  virtual node_type get_node_type();
+#endif
 };
 
 inline node::node()
@@ -211,6 +217,24 @@
   int force_tprint();
 };
 
+#ifdef	NIPPON
+class kword_space_node : public word_space_node {
+public:
+  kword_space_node(color *, node * = 0);
+  node *copy();
+  const char *type();
+  node_type get_node_type();
+};
+
+class newline_space_node : public word_space_node {
+public:
+  newline_space_node(hunits, color *, node * = 0);
+  node *copy();
+  const char *type();
+  node_type get_node_type();
+};
+#endif
+
 class unbreakable_space_node : public word_space_node {
   unbreakable_space_node(hunits, int, color *, node * = 0);
 public:
@@ -597,3 +621,6 @@
 font_family *lookup_family(symbol);
 symbol get_font_name(int, environment *);
 extern search_path include_search_path;
+#ifdef NIPPON
+int is_boldfont(int);
+#endif
diff -uNr groff-1.19.1.orig/src/roff/troff/token.h groff-1.19.1/src/roff/troff/token.h
--- groff-1.19.1.orig/src/roff/troff/token.h	2004-04-17 14:06:28.000000000 +0900
+++ groff-1.19.1/src/roff/troff/token.h	2005-02-23 16:32:33.227764104 +0900
@@ -28,12 +28,18 @@
   symbol nm;
   node *nd;
   unsigned char c;
+#ifdef	NIPPON
+  wchar wc;
+#endif
   int val;
   units dim;
   enum token_type {
     TOKEN_BACKSPACE,
     TOKEN_BEGIN_TRAP,
     TOKEN_CHAR,			// a normal printing character
+#ifdef	NIPPON
+    TOKEN_WCHAR,		// a japanese EUC character
+#endif
     TOKEN_DUMMY,		// \&
     TOKEN_EMPTY,		// this is the initial value
     TOKEN_END_TRAP,
diff -uNr groff-1.19.1.orig/src/roff/troff/troff.h groff-1.19.1/src/roff/troff/troff.h
--- groff-1.19.1.orig/src/roff/troff/troff.h	2004-04-07 23:48:18.000000000 +0900
+++ groff-1.19.1/src/roff/troff/troff.h	2005-02-23 16:32:33.227764104 +0900
@@ -20,6 +20,9 @@
 Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
 
 
+#ifdef	NIPPON
+# include "eucmac.h"
+#endif
 #include "lib.h"
 
 #include <ctype.h>
diff -uNr groff-1.19.1.orig/src/xditview/Dvi.c groff-1.19.1/src/xditview/Dvi.c
--- groff-1.19.1.orig/src/xditview/Dvi.c	2003-07-02 23:44:15.000000000 +0900
+++ groff-1.19.1/src/xditview/Dvi.c	2005-02-23 16:32:33.228763952 +0900
@@ -49,6 +49,8 @@
 NBI	-adobe-new century schoolbook-bold-i-normal--*-100-*-*-*-*-iso8859-1\n\
 S	-adobe-symbol-medium-r-normal--*-100-*-*-*-*-adobe-fontspecific\n\
 SS	-adobe-symbol-medium-r-normal--*-100-*-*-*-*-adobe-fontspecific\n\
+M	-misc-fixed-medium-r-normal--*-100-*-*-*-*-jisx0208.1983-0\n\
+G	-misc-fixed-medium-r-normal--*-100-*-*-*-*-jisx0208.1983-0\
 ";
 
 #define offset(field) XtOffset(DviWidget, field)
diff -uNr groff-1.19.1.orig/src/xditview/DviChar.c groff-1.19.1/src/xditview/DviChar.c
--- groff-1.19.1.orig/src/xditview/DviChar.c	2003-07-02 23:44:15.000000000 +0900
+++ groff-1.19.1/src/xditview/DviChar.c	2005-02-23 16:39:36.861362008 +0900
@@ -8,6 +8,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include "DviChar.h"
+#include "encoding.h"
 
 extern char *xmalloc();
 
@@ -122,7 +123,16 @@
 {
 	int		i;
 	DviCharNameHash	*h;
-
+#if 0 /* def	NIPPON */
+	unsigned char ub = *name, lb = *(name + 1);
+ 
+	if (is_euc_byte(ub) && is_euc_byte(lb)) {
+	  int wc;
+	  wc = (name[0] & 0xff) << 8;
+	  wc |= (name[1] & 0xff);
+	  return(wc);
+	}
+#endif
 	i = hash_name (name) % DVI_HASH_SIZE;
 	for (h = map->buckets[i]; h; h=h->next)
 		if (!strcmp (h->name, name))
@@ -130,6 +140,15 @@
 	return -1;
 }
 
+#if 0 /* def	NIPPON */
+static DviCharNameMap JISX0208_1983_0_map = {
+	"jisx0208.1983-0",
+	0,
+{
+{	"DummyEntry",		/* 0 */},
+}};
+#endif
+
 static DviCharNameMap ISO8859_1_map = {
 	"iso8859-1",
 	0,
@@ -661,4 +680,7 @@
 	standard_maps_loaded = 1;
 	DviRegisterMap (&ISO8859_1_map);
 	DviRegisterMap (&Adobe_Symbol_map);
+#if 0 /* def	NIPPON */
+	DviRegisterMap (&JISX0208_1983_0_map);
+#endif
 }
diff -uNr groff-1.19.1.orig/src/xditview/DviP.h groff-1.19.1/src/xditview/DviP.h
--- groff-1.19.1.orig/src/xditview/DviP.h	2003-07-02 23:44:15.000000000 +0900
+++ groff-1.19.1/src/xditview/DviP.h	2005-02-23 16:32:33.229763800 +0900
@@ -89,9 +89,17 @@
 #define DVI_CHAR_CACHE_SIZE	1024
 
 typedef struct _dviCharCache {
+#if 0 /* def	NIPPON */
+	XTextItem16	cache[DVI_TEXT_CACHE_SIZE];
+#else
 	XTextItem	cache[DVI_TEXT_CACHE_SIZE];
+#endif
 	char		adjustable[DVI_TEXT_CACHE_SIZE];
+#if 0 /* def	NIPPON */
+	XChar2b		char_cache[DVI_CHAR_CACHE_SIZE];
+#else
 	char		char_cache[DVI_CHAR_CACHE_SIZE];
+#endif
 	int		index;
 	int		max;
 	int		char_index;
diff -uNr groff-1.19.1.orig/src/xditview/FontMap.jisx0208 groff-1.19.1/src/xditview/FontMap.jisx0208
--- groff-1.19.1.orig/src/xditview/FontMap.jisx0208	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/src/xditview/FontMap.jisx0208	2005-02-23 16:32:33.229763800 +0900
@@ -0,0 +1,2 @@
+M	-misc-fixed-medium-r-normal--*-100-*-*-*-*-jisx0208.1983-0
+G	-misc-fixed-medium-r-normal--*-100-*-*-*-*-jisx0208.1983-0
diff -uNr groff-1.19.1.orig/src/xditview/GXditview-ad.h groff-1.19.1/src/xditview/GXditview-ad.h
--- groff-1.19.1.orig/src/xditview/GXditview-ad.h	2000-02-06 18:39:04.000000000 +0900
+++ groff-1.19.1/src/xditview/GXditview-ad.h	2005-02-23 16:32:33.229763800 +0900
@@ -50,3 +50,24 @@
 "GXditview.promptShell.promptDialog.cancel.label: Cancel",
 "GXditview.promptShell.promptDialog.cancel.translations: #override \
 	<BtnUp>:	Cancel() unset()",
+"GXditview*fontMap: \
+TR	-adobe-times-medium-r-normal--*-100-*-*-*-*-iso8859-1\\n\
+TI	-adobe-times-medium-i-normal--*-100-*-*-*-*-iso8859-1\\n\
+TB	-adobe-times-bold-r-normal--*-100-*-*-*-*-iso8859-1\\n\
+TBI	-adobe-times-bold-i-normal--*-100-*-*-*-*-iso8859-1\\n\
+CR	-adobe-courier-medium-r-normal--*-100-*-*-*-*-iso8859-1\\n\
+CI	-adobe-courier-medium-o-normal--*-100-*-*-*-*-iso8859-1\\n\
+CB	-adobe-courier-bold-r-normal--*-100-*-*-*-*-iso8859-1\\n\
+CBI	-adobe-courier-bold-o-normal--*-100-*-*-*-*-iso8859-1\\n\
+HR	-adobe-helvetica-medium-r-normal--*-100-*-*-*-*-iso8859-1\\n\
+HI	-adobe-helvetica-medium-o-normal--*-100-*-*-*-*-iso8859-1\\n\
+HB	-adobe-helvetica-bold-r-normal--*-100-*-*-*-*-iso8859-1\\n\
+HBI	-adobe-helvetica-bold-o-normal--*-100-*-*-*-*-iso8859-1\\n\
+NR	-adobe-new century schoolbook-medium-r-normal--*-100-*-*-*-*-iso8859-1\\n\
+NI	-adobe-new century schoolbook-medium-i-normal--*-100-*-*-*-*-iso8859-1\\n\
+NB	-adobe-new century schoolbook-bold-r-normal--*-100-*-*-*-*-iso8859-1\\n\
+NBI	-adobe-new century schoolbook-bold-i-normal--*-100-*-*-*-*-iso8859-1\\n\
+S	-adobe-symbol-medium-r-normal--*-100-*-*-*-*-adobe-fontspecific\\n\
+SS	-adobe-symbol-medium-r-normal--*-100-*-*-*-*-adobe-fontspecific\\n\
+M	-misc-fixed-medium-r-normal--*-100-*-*-*-*-jisx0208.1983-0\\n\
+G	-misc-fixed-medium-r-normal--*-100-*-*-*-*-jisx0208.1983-0",
diff -uNr groff-1.19.1.orig/src/xditview/GXditview.ad groff-1.19.1/src/xditview/GXditview.ad
--- groff-1.19.1.orig/src/xditview/GXditview.ad	2000-02-06 18:38:57.000000000 +0900
+++ groff-1.19.1/src/xditview/GXditview.ad	2005-02-23 16:32:33.229763800 +0900
@@ -55,3 +55,25 @@
 GXditview.promptShell.promptDialog.cancel.label: Cancel
 GXditview.promptShell.promptDialog.cancel.translations: #override \
 	<BtnUp>:	Cancel() unset()
+
+GXditview*fontMap: \
+TR	-adobe-times-medium-r-normal--*-100-*-*-*-*-iso8859-1\n\
+TI	-adobe-times-medium-i-normal--*-100-*-*-*-*-iso8859-1\n\
+TB	-adobe-times-bold-r-normal--*-100-*-*-*-*-iso8859-1\n\
+TBI	-adobe-times-bold-i-normal--*-100-*-*-*-*-iso8859-1\n\
+CR	-adobe-courier-medium-r-normal--*-100-*-*-*-*-iso8859-1\n\
+CI	-adobe-courier-medium-o-normal--*-100-*-*-*-*-iso8859-1\n\
+CB	-adobe-courier-bold-r-normal--*-100-*-*-*-*-iso8859-1\n\
+CBI	-adobe-courier-bold-o-normal--*-100-*-*-*-*-iso8859-1\n\
+HR	-adobe-helvetica-medium-r-normal--*-100-*-*-*-*-iso8859-1\n\
+HI	-adobe-helvetica-medium-o-normal--*-100-*-*-*-*-iso8859-1\n\
+HB	-adobe-helvetica-bold-r-normal--*-100-*-*-*-*-iso8859-1\n\
+HBI	-adobe-helvetica-bold-o-normal--*-100-*-*-*-*-iso8859-1\n\
+NR	-adobe-new century schoolbook-medium-r-normal--*-100-*-*-*-*-iso8859-1\n\
+NI	-adobe-new century schoolbook-medium-i-normal--*-100-*-*-*-*-iso8859-1\n\
+NB	-adobe-new century schoolbook-bold-r-normal--*-100-*-*-*-*-iso8859-1\n\
+NBI	-adobe-new century schoolbook-bold-i-normal--*-100-*-*-*-*-iso8859-1\n\
+S	-adobe-symbol-medium-r-normal--*-100-*-*-*-*-adobe-fontspecific\n\
+SS	-adobe-symbol-medium-r-normal--*-100-*-*-*-*-adobe-fontspecific\n\
+M	-misc-fixed-medium-r-normal--*-100-*-*-*-*-jisx0208.1983-0\n\
+G	-misc-fixed-medium-r-normal--*-100-*-*-*-*-jisx0208.1983-0
diff -uNr groff-1.19.1.orig/src/xditview/draw.c groff-1.19.1/src/xditview/draw.c
--- groff-1.19.1.orig/src/xditview/draw.c	2003-07-02 23:44:15.000000000 +0900
+++ groff-1.19.1/src/xditview/draw.c	2005-02-23 16:32:33.230763648 +0900
@@ -17,6 +17,7 @@
 #endif
 
 #include "DviP.h"
+#include "encoding.h" /* XXX */
 
 #define DeviceToX(dw, n) ((int)((n) * (dw)->dvi.scale_factor + .5))
 #define XPos(dw) (DeviceToX((dw), (dw)->dvi.state->x - \
@@ -108,9 +109,15 @@
 {
 	if (dw->dvi.cache.char_index != 0) {
 		AdjustCacheDeltas (dw);
+#if 0 /* def	NIPPON */
+		XDrawText16 (XtDisplay (dw), XtWindow (dw), dw->dvi.normal_GC,
+			   dw->dvi.cache.start_x, dw->dvi.cache.start_y,
+			   dw->dvi.cache.cache, dw->dvi.cache.index + 1);
+#else
 		XDrawText (XtDisplay (dw), XtWindow (dw), dw->dvi.normal_GC,
 			   dw->dvi.cache.start_x, dw->dvi.cache.start_y,
 			   dw->dvi.cache.cache, dw->dvi.cache.index + 1);
+#endif
 	}	
 	dw->dvi.cache.index = 0;
 	dw->dvi.cache.max = DVI_TEXT_CACHE_SIZE;
@@ -140,12 +147,27 @@
 	dw->dvi.word_flag = 1;
 }
 
+#if 0 /* def	NIPPON */
+int charWidth(fi, c)
+XFontStruct *fi;
+int	c;
+{
+	if (is_euc_code(c)) {
+		return fi->max_bounds.width;
+	} else {
+		return fi->per_char ?
+			fi->per_char[c - fi->min_char_or_byte2].width :
+			fi->max_bounds.width;
+	}
+}
+#else
 #define charWidth(fi,c) (\
     (fi)->per_char ?\
 	(fi)->per_char[(c) - (fi)->min_char_or_byte2].width\
     :\
 	(fi)->max_bounds.width\
 )
+#endif /* NIPPON */
  
 
 static
@@ -155,6 +177,10 @@
 {
 	XCharStruct *p;
 
+#if 0 /* def	NIPPON */
+	if (is_euc_code(c))
+		return 1;	/* Neglect ;-P */
+#endif
 	if (fi->per_char == NULL ||
 	    c < fi->min_char_or_byte2 || c > fi->max_char_or_byte2)
 		return 0;
@@ -170,7 +196,11 @@
 	int wid;    /* width in device units */
 {
 	register XFontStruct	*font;
+#if 0 /* def	NIPPON */
+	register XTextItem16	*text;
+#else
 	register XTextItem	*text;
+#endif
 	int	x, y;
 	
 	x = XPos(dw);
@@ -242,7 +272,21 @@
 	}
 	if (charExists(font, c)) {
 		int w;
+#if 0 /* def	NIPPON */
+		if (is_euc_code(c)) {
+			dw->dvi.cache.char_cache[dw->dvi.cache.char_index].
+				byte1 =	(unsigned char)jis_ubyte(c);
+			dw->dvi.cache.char_cache[dw->dvi.cache.char_index++].
+				byte2 =	(unsigned char)jis_lbyte(c);
+		} else {
+			dw->dvi.cache.char_cache[dw->dvi.cache.char_index].
+				byte1 =	(unsigned char)'\0';
+			dw->dvi.cache.char_cache[dw->dvi.cache.char_index++].
+				byte2 =	(unsigned char)c;
+		}
+#else
 		dw->dvi.cache.char_cache[dw->dvi.cache.char_index++] = (char) c;
+#endif
 		++text->nchars;
 		w = charWidth(font, c);
 		dw->dvi.cache.x += w;
diff -uNr groff-1.19.1.orig/src/xditview/encoding.h groff-1.19.1/src/xditview/encoding.h
--- groff-1.19.1.orig/src/xditview/encoding.h	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/src/xditview/encoding.h	2005-02-23 16:32:33.230763648 +0900
@@ -0,0 +1,37 @@
+// -*- C++ -*-
+/* Copyright (c) 2001 Fumitoshi UKAI <ukai@debian.or.jp>
+
+This file is part of groff.
+
+groff is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+groff is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#ifndef ENCODING_H
+#define ENCODING_H
+
+#ifdef NIPPON
+typedef unsigned int wchar;
+#else
+typedef char wchar;
+#endif
+
+#if 0
+#define EUCMASK	0x8080
+#define is_euc_code(c)	(((c) & EUCMASK) == EUCMASK)
+#define is_euc_byte(c)  ((c) >= 0xa1 && (c) <= 0xfe)
+#define jis_ubyte(wc)	(((wc) >> 8) & 0x7f)
+#define jis_lbyte(wc)	((wc) & 0x7f)
+#endif	/* 0 */
+
+#endif
diff -uNr groff-1.19.1.orig/src/xditview/eucmac.h groff-1.19.1/src/xditview/eucmac.h
--- groff-1.19.1.orig/src/xditview/eucmac.h	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/src/xditview/eucmac.h	2005-02-23 16:32:33.231763496 +0900
@@ -0,0 +1,14 @@
+/* 
+ * eucmac.h - japanese enhancement support module.
+ */
+
+#ifndef _EUCMAC_H
+#define _EUCMAC_H
+
+#define EUCMASK	0x8080
+#define is_euc_code(c)	(((c) & EUCMASK) == EUCMASK)
+#define is_euc_byte(c)  ((c) >= 0xa1 && (c) <= 0xfe)
+#define jis_ubyte(wc)	(((wc) >> 8) & 0x7f)
+#define jis_lbyte(wc)	((wc) & 0x7f)
+
+#endif	/* _EUCMAC_H */
diff -uNr groff-1.19.1.orig/src/xditview/parse.c groff-1.19.1/src/xditview/parse.c
--- groff-1.19.1.orig/src/xditview/parse.c	2003-07-02 23:44:15.000000000 +0900
+++ groff-1.19.1/src/xditview/parse.c	2005-02-23 16:32:33.231763496 +0900
@@ -94,6 +94,13 @@
 			    break;
 			Buffer[0] = c;
 			Buffer[1] = '\0';
+#if 0 /* def	NIPPON */
+			if (is_euc_byte(c)) {
+				DviGetC(dw,&c);
+				Buffer[1] = c;
+				Buffer[2] = '\0';
+			}
+#endif
 			(void) PutCharacter (dw, Buffer);
 			break;
 		case 'C':
@@ -105,6 +112,13 @@
 			while (DviGetC (dw, &c) != EOF
 			       && c != ' ' && c != '\n') {
 				Buffer[0] = c;
+#if 0 /* def	NIPPON */
+				if (is_euc_byte(c)) {
+					DviGetC(dw,&c);
+					Buffer[1] = c;
+					Buffer[2] = '\0';
+				}
+#endif
 				HorizontalMove (dw, PutCharacter (dw, Buffer));
 			}
 			break;
diff -uNr groff-1.19.1.orig/src/xditview/xtotroff.c groff-1.19.1/src/xditview/xtotroff.c
--- groff-1.19.1.orig/src/xditview/xtotroff.c	2003-07-02 23:44:15.000000000 +0900
+++ groff-1.19.1/src/xditview/xtotroff.c	2005-02-23 16:32:33.231763496 +0900
@@ -179,6 +179,47 @@
 			fprintf (out, "spacewidth %d\n", w);
 	}
 	fprintf (out, "charset\n");
+#if 0 /* def	NIPPON */
+	if (fi->min_byte1 != 0 || fi->max_byte1 != 0) {
+		/*
+		 * 2 byte code font.
+		 */
+		int N;
+		int D = fi->max_char_or_byte2 -	fi->min_char_or_byte2 + 1;
+		int max = (fi->max_byte1 - fi->min_byte1 + 1) *
+			(fi->max_char_or_byte2 - fi->min_char_or_byte2 + 1);
+		unsigned byte1;
+		unsigned byte2;
+		unsigned int euc_code;
+
+		for (N = 0; N < max; N++) {
+			byte1 = N / D + fi->min_byte1;
+			byte2 = N % D + fi->min_char_or_byte2;
+			euc_code = ((byte1 << 8) | byte2) & 0xffff | 0x8080;
+			wid = fi->max_bounds.width;
+			fputc(byte1 & 0xff | 0x80, out);/* output EUC code */
+			fputc(byte2 & 0xff | 0x80, out);/* output EUC code */
+			fprintf (out, "\t%d", wid);
+			if (groff_flag) {
+				int	param[5];
+				param[0] = fi->max_bounds.ascent;
+				param[1] = fi->max_bounds.descent;
+				param[2] = 0 /* charRBearing (fi, c) - wid */;
+				param[3] = 0 /* charLBearing (fi, c) */;
+				param[4] = 0; /* XXX */
+				for (j = 0; j < 5; j++)
+					if (param[j] < 0)
+						param[j] = 0;
+				for (j = 4; j >= 0; j--)
+					if (param[j] != 0)
+						break;
+				for (k = 0; k <= j; k++)
+					fprintf (out, ",%d", param[k]);
+			}
+			fprintf (out, "\t0\t%#x\n", euc_code);
+		}
+	} else
+#endif /* NIPPON */
 	for (c = fi->min_char_or_byte2; c <= fi->max_char_or_byte2; c++) {
 		char *name = DviCharName (char_map,c,0);
 		if (charExists (fi, c) && (groff_flag || name)) {
diff -uNr groff-1.19.1.orig/tmac/Makefile.sub groff-1.19.1/tmac/Makefile.sub
--- groff-1.19.1.orig/tmac/Makefile.sub	2003-04-09 02:47:27.000000000 +0900
+++ groff-1.19.1/tmac/Makefile.sub	2005-02-23 16:32:33.232763344 +0900
@@ -27,15 +27,18 @@
   composite.tmac \
   eqnrc \
   troffrc troffrc-end \
-  hyphen.us hyphenex.us
+  hyphen.us hyphenex.us \
+  andocj.tmac \
+  euc-jp.tmac
 SPECIALFILES=an.tmac man.tmac s.tmac ms.tmac
-STRIPFILES=e.tmac doc.tmac doc-old.tmac
-MDOCFILES=doc-common doc-ditroff doc-nroff doc-syms
+STRIPFILES=e.tmac doc.tmac doc-old.tmac docj.tmac
+MDOCFILES=doc-common doc-ditroff doc-nroff doc-syms doc-nippon
 mdocdir=$(tmacdir)/mdoc
 CLEANADD=\
   stamp-wrap stamp-sed *-wrap man.tmac-sed ms.tmac-sed www.tmac-sed \
   stamp-strip e.tmac-s doc.tmac-s doc-old.tmac-s \
-  doc-common-s doc-ditroff-s doc-nroff-s doc-syms-s mdoc.local-s
+  doc-common-s doc-ditroff-s doc-nroff-s doc-syms-s mdoc.local-s \
+  docj.tmac-s docj-ditroff-s docj-nroff-s
 tmac_s_prefix=
 tmac_an_prefix=
 tmac_wrap=
diff -uNr groff-1.19.1.orig/tmac/andocj.tmac groff-1.19.1/tmac/andocj.tmac
--- groff-1.19.1.orig/tmac/andocj.tmac	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/tmac/andocj.tmac	2005-02-23 16:32:33.232763344 +0900
@@ -0,0 +1,19 @@
+.\" andoc.tmac
+.\"
+.\" Load either an-old.tmac or doc.tmac.
+.if !\n(.g .ab These macros require groff.
+.de Dd
+.rm Dd
+.do mso docj.tmac
+\\*(Dd\\
+..
+.de TH
+.rm TH
+.do mso an-old.tmac
+\\*(TH\\
+..
+.\" dummy equation macros -- eqnrc is read before .TH or .Dd is parsed.
+.de EQ
+..
+.de EN
+..
diff -uNr groff-1.19.1.orig/tmac/doc-nippon groff-1.19.1/tmac/doc-nippon
--- groff-1.19.1.orig/tmac/doc-nippon	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/tmac/doc-nippon	2005-02-23 16:32:33.232763344 +0900
@@ -0,0 +1,209 @@
+.\" Copyright (c) 1991, 1993
+.\"	The Regents of the University of California.  All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. All advertising materials mentioning features or use of this software
+.\"    must display the following acknowledgement:
+.\"      This product includes software developed by the University of
+.\"      California, Berkeley and its contributors.
+.\" 4. Neither the name of the University nor the names of its contributors
+.\"    may be used to endorse or promote products derived from this software
+.\"    without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\"     @(#)doc-nippon	8.1 (Berkeley) 06/08/93
+.\"
+.\"     %beginstrip%
+.
+.
+.\" NS Sh user macro (not callable)
+.\" NS   section headers
+.\" NS
+.\" NS modifies:
+.\" NS   doc-func-args-processed
+.\" NS   doc-func-count
+.\" NS   doc-in-authors-section
+.\" NS   doc-in-files-section
+.\" NS   doc-in-see-also-section
+.\" NS   doc-in-synopsis-section
+.\" NS   doc-indent-synopsis
+.\" NS   doc-indent-synopsis-active
+.\" NS   doc-is-func
+.\" NS   doc-num-func-args
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-Sh
+.\" NS   doc-reg-Sh1
+.\" NS   doc-section-XXX
+.\" NS
+.\" NS width register `Sh' set in doc-common
+.
+.eo
+.
+.de Sh
+.  ie \n[doc-arg-limit] \{\
+.    \" we only allow `Sh' within `Sh'; it will change the font back to
+.    \" `doc-Sh-font'
+.    ie "\*[doc-macro-name]"Sh" \{\
+.      nr doc-arg-ptr +1
+.      ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.        nr doc-curr-font \n[.f]
+.        nr doc-curr-size \n[.ps]
+.        nop \*[doc-Sh-font]\c
+.        doc-print-recursive
+.      \}
+.      el \{\
+.        tm Usage: .Sh section_name ... (#\n[.c])
+.        doc-reset-args
+.    \}\}
+.    el \{\
+.      tm Usage: .Sh not callable by other macros (#\n[.c])
+.      doc-reset-args
+.  \}\}
+.  el \{\
+.    if !\n[.$] \{\
+.      tm Usage: .Sh section_name ... (#\n[.c])
+.      return
+.    \}
+.
+.    ds doc-macro-name Sh
+.    doc-parse-args \$@
+.
+.    if t \
+.      ad
+.
+.    \" this resolves e.g. `.Sh "SEE ALSO"'
+.    doc-first-parameter \$*
+.
+.    ie "\*[doc-str-dfp]"NAME" \{\
+.      doc-setup-header
+.      in 0
+.    \}
+.    el \{\
+.      ie "\*[doc-str-dfp]"名前" \{\
+.        doc-setup-header
+.        in 0
+.      \}
+.      el \{\
+.        ie "\*[doc-str-dfp]"名称" \{\
+.          doc-setup-header
+.          in 0
+.        \}
+.        el \{\
+.          nr doc-in-synopsis-section 0
+.          nr doc-in-see-also-section 0
+.          nr doc-in-files-section 0
+.          nr doc-in-authors-section 0
+.
+.          ie "\*[doc-str-dfp]"SYNOPSYS" \{\
+.            if t \
+.              na
+.            nr doc-in-synopsis-section 1
+.            nr doc-indent-synopsis 0
+.            nr doc-indent-synopsis-active 0
+.          \}
+.          el \{ .ie "\*[doc-str-dfp]"書式" \{\
+.            if t \
+.              na
+.            nr doc-in-synopsis-section 1
+.            nr doc-indent-synopsis 0
+.            nr doc-indent-synopsis-active 0
+.          \}
+.          el \{ .ie "\*[doc-str-dfp]"DESCRIPTION" \{\
+.            nr doc-is-func 0
+.            nr doc-func-count 0
+.            nr doc-func-args-processed 0
+.            nr doc-num-func-args 0
+.          \}
+.          el \{ .ie "\*[doc-str-dfp]"説明" \{\
+.            nr doc-is-func 0
+.            nr doc-func-count 0
+.            nr doc-func-args-processed 0
+.            nr doc-num-func-args 0
+.          \}
+.          el \{ .ie "\*[doc-str-dfp]"解説" \{\
+.            nr doc-is-func 0
+.            nr doc-func-count 0
+.            nr doc-func-args-processed 0
+.            nr doc-num-func-args 0
+.          \}
+.          el \{ .ie "\*[doc-str-dfp]"SEE" \{\
+.            if t \
+.              na
+.            nr doc-in-see-also-section 1
+.          \}
+.          el \{ .ie "\*[doc-str-dfp]"関連項目" \{\
+.            if t \
+.              na
+.            nr doc-in-see-also-section 1
+.          \}
+.          el \{ .ie "\*[doc-str-dfp]"FILES" \
+.            nr doc-in-files-section 1
+.          el \{ .ie "\*[doc-str-dfp]"ファイル" \
+.            nr doc-in-files-section 1
+.          el .ie "\*[doc-str-dfp]"関連ファイル" \
+.            nr doc-in-files-section 1
+.          el .ie "\*[doc-str-dfp]"AUTHORS" \
+.            nr doc-in-authors-section 1
+.          el .ie "\*[doc-str-dfp]"著者" \
+.            nr doc-in-authors-section 1
+.          el .if "\*[doc-str-dfp]"作者" \
+.            nr doc-in-authors-section 1
+.          \}\}\}\}\}\}\}
+.
+.          in 0
+.          nr doc-have-author 0
+.        \}
+.      \}
+.    \}
+.
+.    doc-setup-page-layout
+.    sp
+.    ns
+.    ta T .5i
+.    if !\n[cR] \
+.      ne 3
+.    fi
+.
+.    if t \{\
+.      nr doc-reg-Sh \n[.ss]
+.      nr doc-reg-Sh1 \n[.sss]
+.      ss (\n[.ss] * 5 / 3) (\n[.sss] * 5 / 3)
+.    \}
+.
+.    nr doc-arg-ptr +1
+.    nr doc-curr-font \n[.f]
+.    nr doc-curr-size \n[.ps]
+.    nop \*[doc-Sh-font]\c
+.    doc-print-recursive
+.
+.    if t \
+.      ss \n[doc-reg-Sh] \n[doc-reg-Sh1]
+.
+.    in +\n[doc-subheader-indent]u
+.    ns
+.  \}
+..
+.
+.
+.ec
+.
+.\" EOF
diff -uNr groff-1.19.1.orig/tmac/docj.tmac groff-1.19.1/tmac/docj.tmac
--- groff-1.19.1.orig/tmac/docj.tmac	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/tmac/docj.tmac	2005-02-23 16:32:33.238762432 +0900
@@ -0,0 +1,6357 @@
+.\" Copyright (c) 1991, 1993
+.\"	The Regents of the University of California.  All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. All advertising materials mentioning features or use of this software
+.\"    must display the following acknowledgement:
+.\"      This product includes software developed by the University of
+.\"      California, Berkeley and its contributors.
+.\" 4. Neither the name of the University nor the names of its contributors
+.\"    may be used to endorse or promote products derived from this software
+.\"    without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\"     @(#)doc	8.1 (Berkeley) 06/08/93
+.\"
+.\" Modified by jjc@jclark.com as follows: the doc-* files are assumed to be
+.\" installed as mdoc/doc-* rather than tmac.doc-* (the filename
+.\" `tmac.doc-common' would be too long); when using groff, the doc-* files
+.\" are loaded using the `mso' request.
+.\"
+.\" Modified by
+.\"
+.\"   Werner LEMBERG <wl@gnu.org>      and
+.\"   Ruslan Ermilov <ru@freebsd.org>
+.\"
+.\" to make it more readable: using long names and many groff features,
+.\" updating and extending documentation, etc.
+.\"
+.\" %beginstrip%
+.
+.
+.if !\n(.g \
+.  ab This version of mdoc can be run with GNU troff only!
+.
+.
+.do if d Dd .nx
+.
+.
+.cp 0
+.
+.
+.if (\n[.x]\n[.y] < 118) \
+.  ab You need GNU troff version 1.18 or higher to run this version of mdoc!
+.
+.
+.\" Load start-up files
+.ie t \
+.  mso mdoc/doc-ditroff
+.el \
+.  mso mdoc/doc-nroff
+.
+.mso mdoc/doc-common
+.mso mdoc/doc-syms
+.mso mdoc/doc-nippon
+.
+.
+.eo
+.
+.
+.\" NS doc-macro-name global string
+.\" NS   name of calling request (set in each user-requestable macro)
+.
+.ds doc-macro-name
+.als doc-arg0 doc-macro-name
+.
+.
+.\" NS doc-arg-limit global register
+.\" NS   total number of arguments
+.
+.nr doc-arg-limit 0
+.
+.
+.\" NS doc-num-args global register
+.\" NS   number of arguments to handle (must be set to \n[.$] prior to
+.\" NS   `doc-parse-arg-vector' request)
+.
+.nr doc-num-args 0
+.
+.
+.\" NS doc-arg-ptr global register
+.\" NS   argument pointer
+.
+.nr doc-arg-ptr 0
+.
+.
+.\" NS doc-argXXX global string
+.\" NS   argument vector
+.\" NS
+.\" NS limit:
+.\" NS   doc-arg-limit
+.
+.ds doc-arg1
+.
+.
+.\" NS doc-typeXXX global register
+.\" NS   argument type vector (macro=1, string=2, punctuation suffix=3,
+.\" NS   punctuation prefix=4)
+.\" NS
+.\" NS limit:
+.\" NS   doc-arg-limit
+.
+.nr doc-type1 0
+.
+.
+.\" NS doc-spaceXXX global string
+.\" NS   space vector
+.\" NS
+.\" NS limit:
+.\" NS   doc-arg-limit
+.
+.ds doc-space1
+.
+.
+.\" NS doc-parse-args macro
+.\" NS   parse arguments (recursively) (`.doc-parse-args arg ...')
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-limit
+.\" NS   doc-arg-ptr
+.\" NS   doc-argXXX
+.\" NS   doc-spaceXXX
+.\" NS   doc-typeXXX
+.\" NS   doc-arg-ptr
+.\" NS   doc-have-space
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dpa
+.\" NS   doc-reg-dpa1
+.\" NS   doc-str-dpa
+.
+.de doc-parse-args
+.  if !\n[doc-arg-limit] \
+.    doc-set-spacing-1
+.
+.  nr doc-have-space 0
+.
+.  if !\n[.$] \
+.    return
+.
+.  nr doc-arg-limit +1
+.
+.  \" handle `|' and `...' specially
+.  ie        "\$1"|" \
+.    ds doc-arg\n[doc-arg-limit] \f[R]|\f[]
+.  el \{ .ie "\$1"..." \
+.    ds doc-arg\n[doc-arg-limit] \|.\|.\|.
+.  el \
+.    ds doc-arg\n[doc-arg-limit] "\$1
+.  \}
+.
+.  \" get argument type and set spacing
+.  doc-get-arg-type* \n[doc-arg-limit]
+.  nr doc-type\n[doc-arg-limit] \n[doc-arg-type]
+.  doc-set-spacing-\n[doc-arg-type]
+.
+.  \" check whether we have processed the last parameter
+.  ie (\n[.$] == 1) \
+.    nr doc-arg-ptr 0
+.  el \{\
+.    shift
+.    doc-parse-args \$@
+.  \}
+.
+.  nh
+..
+.
+.
+.\" NS doc-parse-arg-vector macro
+.\" NS   parse argument vector (recursive)
+.\" NS
+.\" NS   cf. comments in doc-parse-args
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-limit
+.\" NS   doc-arg-ptr
+.\" NS   doc-argXXX
+.\" NS   doc-num-args
+.\" NS   doc-spaceXXX
+.\" NS   doc-typeXXX
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dpav
+.\" NS   doc-reg-dpav1
+.\" NS   doc-str-dpav
+.
+.de doc-parse-arg-vector
+.  if !\n[doc-arg-limit] \
+.    doc-set-spacing-1
+.
+.  nr doc-arg-limit +1
+.
+.  ie        "\*[doc-arg\n[doc-arg-limit]]"|" \
+.    ds doc-arg\n[doc-arg-limit] \f[R]|\f[]
+.  el \{ .if "\*[doc-arg\n[doc-arg-limit]]"..." \
+.    ds doc-arg\n[doc-arg-limit] \|.\|.\|.
+.  \}
+.
+.  doc-get-arg-type* \n[doc-arg-limit]
+.  nr doc-type\n[doc-arg-limit] \n[doc-arg-type]
+.  doc-set-spacing-\n[doc-arg-type]
+.
+.  ie (\n[doc-num-args] == 1) \{\
+.    nr doc-arg-ptr 0
+.    nr doc-num-args 0
+.  \}
+.  el \{\
+.    nr doc-num-args -1
+.    doc-parse-arg-vector
+.  \}
+.
+.  nh
+..
+.
+.
+.\" NS doc-parse-space-vector macro
+.\" NS   parse space vector (recursive)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-limit
+.\" NS   doc-num-args
+.\" NS   doc-spaceXXX
+.
+.de doc-parse-space-vector
+.  nr doc-arg-limit +1
+.
+.  doc-set-spacing-\n[doc-type\n[doc-arg-limit]]
+.
+.  ie (\n[doc-num-args] == 1) \
+.    nr doc-num-args 0
+.  el \{\
+.    nr doc-num-args -1
+.    doc-parse-space-vector
+.  \}
+..
+.
+.
+.\" NS doc-remaining-args macro
+.\" NS   output remaining arguments as-is, separated by spaces (until
+.\" NS   `doc-num-args' is exhausted)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-num-args
+.
+.de doc-remaining-args
+.  nr doc-arg-ptr +1
+.  nop \)\*[doc-arg\n[doc-arg-ptr]]\c
+.
+.  ie (\n[doc-num-args] == 1) \{\
+.    nr doc-arg-ptr 0
+.    nr doc-num-args 0
+.  \}
+.  el \{\
+.    nop \)\*[doc-space]\c
+.    nr doc-num-args -1
+.    doc-remaining-args
+.  \}
+..
+.
+.
+.\" NS doc-append-arg macro
+.\" NS   append one argument to argument vector:
+.\" NS   `.doc-append-arg [arg] [type]'
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-limit
+.\" NS   doc-argXXX
+.\" NS   doc-typeXXX
+.
+.de doc-append-arg
+.  nr doc-arg-limit +1
+.  ds doc-arg\n[doc-arg-limit] "\$1
+.  nr doc-type\n[doc-arg-limit] \$2
+.  doc-set-spacing-\$2
+..
+.
+.
+.\" NS doc-print-and-reset macro
+.\" NS   finish input line and clean up argument vectors
+.
+.de doc-print-and-reset
+.  if \n[doc-space-mode] \
+.    nop \)
+.  doc-reset-args
+..
+.
+.
+.\" NS doc-reset-args macro
+.\" NS   reset argument counters
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-limit
+.\" NS   doc-arg-ptr
+.\" NS   doc-have-slot
+.
+.de doc-reset-args
+.  nr doc-arg-limit 0
+.  nr doc-arg-ptr 0
+.  nr doc-have-slot 0
+.
+.  hy \n[doc-hyphen-flags]
+..
+.
+.
+.ec
+.
+.\" NS doc-curr-font global register
+.\" NS   saved current font
+.
+.nr doc-curr-font \n[.f]
+.
+.
+.\" NS doc-curr-size global register
+.\" NS   saved current font size
+.
+.nr doc-curr-size \n[.ps]
+.
+.eo
+.
+.
+.\" NS Fl user macro
+.\" NS   handle flags (appends `-' and prints flags): `.Fl [arg ...]'
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-Fl (for communication with doc-flag-recursion)
+.\" NS
+.\" NS width register `Fl' set in doc-common
+.
+.de Fl
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.  nop \*[doc-Fl-font]\c
+.
+.  if !\n[doc-arg-limit] \{\
+.    ds doc-macro-name Fl
+.    doc-parse-args \$@
+.
+.    if !\n[.$] \{\
+.      \" no arguments
+.      nop \|\-\|\f[]\s[0]
+.  \}\}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
+.    \" last argument
+.    nop \|\-\f[]\s[0]\c
+.    doc-print-and-reset
+.  \}
+.  el \{\
+.    ie (\n[doc-type\n[doc-arg-ptr]] == 1) \{\
+.      nop \|\-\f[]\s[0]\c
+.      \*[doc-arg\n[doc-arg-ptr]]
+.    \}
+.    el \{\
+.      if (\n[doc-type\n[doc-arg-ptr]] == 3) \
+.        nop \|\-\|\c
+.
+.      nr doc-reg-Fl 1
+.      doc-flag-recursion
+.  \}\}
+..
+.
+.
+.\" NS doc-flag-recursion macro
+.\" NS   `Fl' flag recursion routine (special handling)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dfr
+.\" NS   doc-reg-dfr1
+.\" NS   doc-str-dfr
+.
+.de doc-flag-recursion
+.  nr doc-reg-dfr1 \n[doc-type\n[doc-arg-ptr]]
+.  ds doc-str-dfr "\*[doc-arg\n[doc-arg-ptr]]
+.
+.  ie (\n[doc-reg-dfr1] == 1) \{\
+.    nop \f[]\s[0]\c
+.    \*[doc-str-dfr]
+.  \}
+.  el \{\
+.    nr doc-reg-dfr \n[doc-arg-ptr]
+.
+.    ie (\n[doc-reg-dfr1] == 2) \{\
+.      \" handle vertical bar -- doc-reg-Fl is set for the first call of
+.      \" doc-flag-recursion only; we need this to make `.Fl | ...' work
+.      \" correctly
+.      ie "\*[doc-str-dfr]"\*[Ba]" \{\
+.        if \n[doc-reg-Fl] \
+.          nop \|\-\*[doc-space]\c
+.        nop \)\*[Ba]\c
+.      \}
+.      el \{\
+.        ie "\*[doc-str-dfr]"\f[R]|\f[]" \{\
+.          if \n[doc-reg-Fl] \
+.            nop \|\-\*[doc-space]\c
+.          nop \f[R]|\f[]\c
+.        \}
+.        el \{\
+.          \" two consecutive hyphen characters?
+.          ie "\*[doc-str-dfr]"-" \
+.            nop \|\-\^\-\|\c
+.          el \
+.            nop \|\%\-\*[doc-str-dfr]\&\c
+.    \}\}\}
+.    el \{\
+.      nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]\c
+.      nop \)\*[doc-str-dfr]\f[]\s[0]\c
+.    \}
+.
+.    ie (\n[doc-arg-limit] == \n[doc-arg-ptr]) \{\
+.      \" last argument
+.      if (\n[doc-reg-dfr1] == 4) \
+.        nop \|\-\c
+.      nop \f[]\s[0]\c
+.      doc-print-and-reset
+.    \}
+.    el \{\
+.      nr doc-arg-ptr +1
+.      ie (\n[doc-type\n[doc-arg-ptr]] == 3) \{\
+.        ie (\n[doc-type\n[doc-reg-dfr]] == 4) \
+.          nop \|\-\c
+.        el \
+.          nop \)\*[doc-space\n[doc-reg-dfr]]\c
+.      \}
+.      el \
+.        nop \)\*[doc-space\n[doc-reg-dfr]]\c
+.
+.      shift
+.      nr doc-reg-Fl 0
+.      doc-flag-recursion \$@
+.  \}\}
+..
+.
+.
+.\" NS doc-print-recursive macro
+.\" NS   general name recursion routine (print remaining arguments)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dpr
+.\" NS   doc-reg-dpr1
+.\" NS   doc-str-dpr
+.
+.de doc-print-recursive
+.  nr doc-reg-dpr1 \n[doc-type\n[doc-arg-ptr]]
+.  ds doc-str-dpr "\*[doc-arg\n[doc-arg-ptr]]
+.
+.  ie (\n[doc-reg-dpr1] == 1) \{\
+.    nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]\c
+.    \*[doc-str-dpr]
+.  \}
+.  el \{\
+.    nr doc-reg-dpr \n[doc-arg-ptr]
+.
+.    ie (\n[doc-reg-dpr1] == 2) \
+.      \" the `\%' prevents hyphenation on a dash (`-')
+.      nop \%\*[doc-str-dpr]\&\c
+.    el \{\
+.      \" punctuation character
+.      nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]\c
+.      nop \)\*[doc-str-dpr]\f[]\s[0]\c
+.    \}
+.
+.    nr doc-arg-ptr +1
+.    ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
+.      \" last argument
+.      nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]\c
+.      doc-print-and-reset
+.    \}
+.    el \{\
+.      nop \)\*[doc-space\n[doc-reg-dpr]]\c
+.      doc-print-recursive
+.  \}\}
+..
+.
+.
+.\" NS doc-print-prefixes macro
+.\" NS   print leading prefixes
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.
+.de doc-print-prefixes
+.  while (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    if !(\n[doc-type\n[doc-arg-ptr]] == 4) \
+.      break
+.    nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]\c
+.    nop \)\*[doc-arg\n[doc-arg-ptr]]\f[]\s[0]\c
+.    nr doc-arg-ptr +1
+.  \}
+..
+.
+.
+.\" NS doc-generic-macro macro
+.\" NS   this is the skeleton for most simple macros
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.
+.de doc-generic-macro
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name \$0
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      tm Usage: .\$0 \*[doc-\$0-usage] ... (#\n[.c])
+.  \}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    if (\n[doc-type\n[doc-arg-ptr]] == 1) \{\
+.      tmc mdoc warning: Using a macro as first argument
+.      tm1 " cancels effect of .\$0 (#\n[.c])
+.
+.      \" the right action here would be to reset the argument counters
+.      \" and bail out -- unfortunately, a small number of manual pages
+.      \" (less than 2% for FreeBSD which has been used for testing)
+.      \" relied on the old behaviour (silently ignore this error),
+.      \" so it is commented out
+.
+.\"    doc-reset-args
+.    \}
+.\"  el \{\
+.      nr doc-curr-font \n[.f]
+.      nr doc-curr-size \n[.ps]
+.      nop \*[doc-\$0-font]\c
+.      doc-print-recursive
+.\"  \}
+.  \}
+.  el \{\
+.    tm Usage: .\$0 \*[doc-\$0-usage] ... (#\n[.c])
+.    doc-reset-args
+.  \}
+..
+.
+.
+.\" NS Ar user macro
+.\" NS   command line `argument' macro: `.Ar [args ...]'
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS
+.\" NS local variable:
+.\" NS   doc-str-Ar-default
+.\" NS
+.\" NS width register `Ar' set in doc-common
+.
+.ds doc-str-Ar-default "file\ .\|.\|.
+.
+.de Ar
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.  nop \*[doc-Ar-font]\c
+.
+.  if !\n[doc-arg-limit] \{\
+.    ds doc-macro-name Ar
+.    doc-parse-args \$@
+.
+.    if !\n[.$] \{\
+.      \" no argument
+.      nop \)\*[doc-str-Ar-default]\&\f[]\s[0]
+.  \}\}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  doc-print-prefixes
+.  ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
+.    nop \)\*[doc-str-Ar-default]\&\f[]\s[0]\c
+.    doc-print-and-reset
+.  \}
+.  el \{\
+.    if !(\n[doc-type\n[doc-arg-ptr]] == 2) \{\
+.      \" replace previous argument (Ar) with default value
+.      nr doc-arg-ptr -1
+.      ds doc-arg\n[doc-arg-ptr] "\*[doc-str-Ar-default]
+.      nr doc-type\n[doc-arg-ptr] 2
+.      ds doc-space\n[doc-arg-ptr] "\*[doc-space]
+.
+.      \" recompute space vector for remaining arguments
+.      nr doc-num-args (\n[doc-arg-limit] - \n[doc-arg-ptr])
+.      nr doc-arg-limit \n[doc-arg-ptr]
+.      doc-parse-space-vector
+.    \}
+.    doc-print-recursive
+.  \}
+..
+.
+.
+.\" NS Ad user macro
+.\" NS   Addresses
+.\" NS
+.\" NS width register `Ad' set in doc-common
+.
+.als Ad doc-generic-macro
+.ds doc-Ad-usage address
+.
+.
+.\" NS doc-indent-synopsis global register
+.\" NS   indentation in synopsis
+.
+.nr doc-indent-synopsis 0
+.
+.
+.\" NS doc-indent-synopsis-active global register (bool)
+.\" NS   indentation in synopsis active
+.
+.nr doc-indent-synopsis-active 0
+.
+.
+.\" NS Cd user macro
+.\" NS   config declaration (for section 4 SYNOPSIS)
+.\" NS
+.\" NS   this function causes a break; it uses the `Nm' font
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-indent-synopsis
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Cd' set in doc-common
+.
+.de Cd
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Cd
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      tm Usage: .Cd configuration_file_declaration ... (#\n[.c])
+.  \}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    nr doc-curr-font \n[.f]
+.    nr doc-curr-size \n[.ps]
+.
+.    ie \n[doc-in-synopsis-section] \{\
+.      if "\*[doc-macro-name]"Cd" \{\
+.        br
+.        if !\n[doc-indent-synopsis] \
+.          nr doc-indent-synopsis \n[doc-display-indent]u
+.        if !\n[doc-indent-synopsis-active] \
+.          in +\n[doc-indent-synopsis]u
+.        ti -\n[doc-indent-synopsis]u
+.        nop \*[doc-Nm-font]\c
+.        doc-print-recursive
+.        if !\n[doc-indent-synopsis-active] \
+.          in -\n[doc-indent-synopsis]u
+.    \}\}
+.    el \{\
+.      nop \*[doc-Nm-font]\c
+.      doc-print-recursive
+.  \}\}
+.  el \{\
+.    tm Usage: .Cd configuration_file_declaration ... (#\n[.c])
+.    doc-reset-args
+.  \}
+..
+.
+.
+.\" NS Cm user macro
+.\" NS   interactive command modifier (flag)
+.\" NS
+.\" NS width register `Cm' set in doc-common
+.
+.als Cm doc-generic-macro
+.ds doc-Cm-usage interactive_command_modifier
+.
+.
+.\" NS Dv user macro
+.\" NS   defined variable
+.\" NS
+.\" NS   this function uses the `Er' font
+.\" NS
+.\" NS width register `Dv' set in doc-common
+.
+.als Dv doc-generic-macro
+.ds doc-Dv-usage defined_variable
+.als doc-Dv-font doc-Er-font
+.
+.
+.\" NS Em user macro
+.\" NS   emphasis
+.\" NS
+.\" NS width register `Em' set in doc-common
+.
+.als Em doc-generic-macro
+.ds doc-Em-usage text
+.
+.
+.\" NS Er user macro
+.\" NS   errno type
+.\" NS
+.\" NS width register `Er' set in doc-common
+.
+.als Er doc-generic-macro
+.ds doc-Er-usage text
+.
+.
+.\" NS Ev user macro
+.\" NS   environment variable
+.\" NS
+.\" NS width register `Ev' set in doc-common
+.
+.als Ev doc-generic-macro
+.ds doc-Ev-usage text
+.
+.
+.\" NS doc-have-decl global register (bool)
+.\" NS   subroutine test (in synopsis only)
+.
+.nr doc-have-decl 0
+.
+.
+.\" NS doc-have-var global register (bool)
+.\" NS   whether last type is a variable type
+.
+.nr doc-have-var 0
+.
+.
+.\" NS doc-do-func-decl macro
+.\" NS   do something special while in SYNOPSIS
+.\" NS
+.\" NS modifies:
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-have-decl
+.\" NS   doc-have-var
+.
+.de doc-do-func-decl
+.  if \n[doc-in-synopsis-section] \{\
+.    \" if a variable type was the last thing given, want vertical space
+.    if \n[doc-have-var] \{\
+.      doc-paragraph
+.      nr doc-have-var 0
+.    \}
+.    \" if a subroutine was the last thing given, want vertical space
+.    if \n[doc-have-func] \{\
+.      ie \n[doc-have-decl] \
+.        br
+.      el \
+.        doc-paragraph
+.    \}
+.    nr doc-have-decl 1
+.  \}
+.
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+..
+.
+.
+.\" NS Fd user macro
+.\" NS   function declaration -- not callable
+.\" NS
+.\" NS   this function causes a break
+.\" NS
+.\" NS width register `Fd' set in doc-common
+.
+.de Fd
+.  ie ((\n[.$] >= 1) & (\n[doc-arg-limit] == 0)) \{\
+.    doc-do-func-decl
+.    nop \*[doc-Fd-font]\$*
+.    br
+.    ft \n[doc-curr-font]
+.    ps \n[doc-curr-size]u
+.  \}
+.  el \{\
+.    tm Usage: .Fd function_declaration -- Fd is not callable (#\n[.c])
+.    doc-reset-args
+.  \}
+..
+.
+.
+.\" NS In user macro
+.\" NS   #include statement - not callable
+.\" NS
+.\" NS   this function causes a break; it uses the `Fd' font
+.\" NS
+.\" NS width register `In' set in doc-common
+.
+.de In
+.  ie ((\n[.$] == 1) & (\n[doc-arg-limit] == 0)) \{\
+.    doc-do-func-decl
+.    nop \*[doc-Fd-font]#include <\$1>
+.    br
+.    ft \n[doc-curr-font]
+.    ps \n[doc-curr-size]u
+.  \}
+.  el \{\
+.    tm Usage: .In include_file -- In is not callable (#\n[.c])
+.    doc-reset-args
+.  \}
+..
+.
+.
+.\" NS Fr user macro
+.\" NS   function return value
+.\" NS
+.\" NS   this function uses the `Ar' font
+.\" NS
+.\" NS width register `Fr' set in doc-common
+.
+.als Fr doc-generic-macro
+.ds doc-Fr-usage function_return_value
+.als doc-Fr-font doc-Ar-font
+.
+.
+.\" NS Ic user macro
+.\" NS   interactive command
+.\" NS
+.\" NS width register `Ic' set in doc-common
+.
+.als Ic doc-generic-macro
+.ds doc-Ic-usage interactive_command
+.
+.
+.\" NS Li user macro
+.\" NS   literals
+.\" NS
+.\" NS width register `Li' set in doc-common
+.
+.als Li doc-generic-macro
+.ds doc-Li-usage argument
+.
+.
+.\" NS Ms user macro
+.\" NS   math symbol
+.\" NS
+.\" NS   this function uses the `Sy' font
+.\" NS
+.\" NS width register `Ms' set in doc-common
+.
+.als Ms doc-generic-macro
+.ds doc-Ms-usage math_symbol
+.als doc-Ms-font doc-Sy-font
+.
+.
+.\" NS doc-command-name global string
+.\" NS   save first invocation of .Nm
+.
+.ds doc-command-name
+.
+.
+.\" NS Nm user macro
+.\" NS   name of command or page topic
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-command-name
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-indent-synopsis
+.\" NS   doc-indent-synopsis-active
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Nm' set in doc-common
+.
+.de Nm
+.  if !\n[doc-arg-limit] \{\
+.    ds doc-macro-name Nm
+.    ie \n[.$] \
+.      doc-parse-args \$@
+.    el \{\
+.      ie "\*[doc-command-name]"" \
+.        tm Usage: .Nm name ... (#\n[.c])
+.      el \
+.        doc-parse-args \*[doc-command-name]
+.  \}\}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  doc-print-prefixes
+.  ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
+.    \" last argument
+.    ie "\*[doc-command-name]"" \{\
+.      tm Usage: .Nm name ... (#\n[.c])
+.      doc-reset-args
+.    \}
+.    el \{\
+.      nop \*[doc-Nm-font]\*[doc-command-name]\f[]\s[0]\c
+.      doc-print-and-reset
+.  \}\}
+.  el \{\
+.    nr doc-curr-font \n[.f]
+.    nr doc-curr-size \n[.ps]
+.
+.    ie !(\n[doc-type\n[doc-arg-ptr]] == 2) \{\
+.      ie "\*[doc-command-name]"" \
+.        tm Usage: .Nm name ... (#\n[.c])
+.      el \{\
+.        \" replace previous argument (Nm) with default value
+.        nr doc-arg-ptr -1
+.        ds doc-arg\n[doc-arg-ptr] "\*[doc-Nm-font]\*[doc-command-name]\f[]\s[0]
+.        nr doc-type\n[doc-arg-ptr] 2
+.        ds doc-space\n[doc-arg-ptr] "\*[doc-space]
+.
+.        \" recompute space vector for remaining arguments
+.        nr doc-num-args (\n[doc-arg-limit] - \n[doc-arg-ptr])
+.        nr doc-arg-limit \n[doc-arg-ptr]
+.        doc-parse-space-vector
+.    \}\}
+.    el \{\
+.      \" handle `.Nm ...' in SYNOPSIS
+.      if \n[doc-in-synopsis-section] \{\
+.        if "\*[doc-macro-name]"Nm" \{\
+.          br
+.          if !\n[doc-indent-synopsis] \{\
+.            doc-get-width "\*[doc-arg\n[doc-arg-ptr]]"
+.            nr doc-indent-synopsis ((\n[doc-width]u + 1u) * \n[doc-fixed-width]u)
+.          \}
+.          if !\n[doc-indent-synopsis-active] \{\
+.            in +\n[doc-indent-synopsis]u
+.            nr doc-indent-synopsis-active 1
+.          \}
+.          ti -\n[doc-indent-synopsis]u
+.      \}\}
+.      if "\*[doc-command-name]"" \
+.        ds doc-command-name "\*[doc-arg\n[doc-arg-ptr]]
+.
+.      nop \*[doc-Nm-font]\c
+.    \}
+.    doc-print-recursive
+.  \}
+..
+.
+.
+.\" NS Pa user macro
+.\" NS   pathname: `.Pa [arg ...]'
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Pa' set in doc-common
+.
+.de Pa
+.  if !\n[doc-arg-limit] \{\
+.    ds doc-macro-name Pa
+.    doc-parse-args \$@
+.
+.    if !\n[.$] \{\
+.      \" default value
+.      nop \*[doc-Pa-font]~\f[]\s[0]
+.  \}\}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  doc-print-prefixes
+.  ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    nr doc-curr-font \n[.f]
+.    nr doc-curr-size \n[.ps]
+.    nop \*[doc-Pa-font]\c
+.    if !(\n[doc-type\n[doc-arg-ptr]] == 2) \{\
+.      \" replace previous argument (Pa) with default value
+.      nr doc-arg-ptr -1
+.      ds doc-arg\n[doc-arg-ptr] ~
+.      nr doc-type\n[doc-arg-ptr] 2
+.      ds doc-space\n[doc-arg-ptr] "\*[doc-space]
+.
+.      \" recompute space vector for remaining arguments
+.      nr doc-num-args (\n[doc-arg-limit] - \n[doc-arg-ptr])
+.      nr doc-arg-limit \n[doc-arg-ptr]
+.      doc-parse-space-vector
+.    \}
+.    doc-print-recursive
+.  \}
+.  el \{\
+.    nop \*[doc-Pa-font]~\f[]\s[0]\c
+.    doc-print-and-reset
+.  \}
+..
+.
+.
+.\" NS Sy user macro
+.\" NS   symbolics
+.\" NS
+.\" NS width register `Sy' set in doc-common
+.
+.als Sy doc-generic-macro
+.ds doc-Sy-usage symbolic_text
+.
+.
+.\" NS Me user macro
+.\" NS   menu entries
+.\" NS
+.\" NS width register `Me' set in doc-common
+.
+.als Me doc-generic-macro
+.ds doc-Me-usage menu_entry
+.
+.
+.\" NS Tn user macro
+.\" NS   trade name
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Tn' set in doc-common
+.
+.de Tn
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Tn
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      tm Usage: .Tn trade_name ... (#\n[.c])
+.  \}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    nr doc-curr-font \n[.f]
+.    nr doc-curr-size \n[.ps]
+.    nop \)\*[doc-Tn-font-size]\c
+.    ie !\n[doc-is-reference] \{\
+.      nop \)\*[doc-Tn-font-shape]\c
+.      doc-print-recursive
+.    \}
+.    el \
+.      doc-do-references
+.  \}
+.  el \{\
+.    tm Usage: .Tn trade_name ... (#\n[.c])
+.    doc-reset-args
+.  \}
+..
+.
+.
+.\" NS Va user macro
+.\" NS   variable name
+.\" NS
+.\" NS width register `Va' set in doc-common
+.
+.als Va doc-generic-macro
+.ds doc-Va-usage variable_name
+.
+.
+.\" NS No user macro
+.\" NS   normal text macro (default text style if mess up)
+.\" NS
+.\" NS width register `No' set in doc-common
+.
+.als No doc-generic-macro
+.ds doc-No-usage normal_text
+.
+.
+.\" NS doc-quote-left global string
+.\" NS   left quotation character for `doc-enclose-string' and
+.\" NS   `doc-enclose-open'
+.
+.ds doc-quote-left
+.
+.
+.\" NS doc-quote-right global string
+.\" NS   right quotation character for `doc-enclose-string' and
+.\" NS   `doc-enclose-close'
+.
+.ds doc-quote-right
+.
+.
+.\" NS Op user macro
+.\" NS   option expression (i.e., enclose string in square brackets)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Op' set in doc-common
+.
+.de Op
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Op
+.
+.  ds doc-quote-left "\*[doc-left-bracket]
+.  ds doc-quote-right "\*[doc-right-bracket]
+.
+.  doc-enclose-string \$@
+..
+.
+.
+.\" NS Aq user macro
+.\" NS   enclose string in angle brackets
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Aq' set in doc-common
+.
+.de Aq
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Aq
+.
+.  ds doc-quote-left \[la]
+.  ds doc-quote-right \[ra]
+.
+.  doc-enclose-string \$@
+..
+.
+.
+.\" NS Bq user macro
+.\" NS   enclose string in square brackets
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Bq' set in doc-common
+.
+.de Bq
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Bq
+.
+.  ds doc-quote-left "\*[doc-left-bracket]
+.  ds doc-quote-right "\*[doc-right-bracket]
+.
+.  doc-enclose-string \$@
+..
+.
+.
+.\" NS Brq user macro
+.\" NS   enclose string in braces
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Brq' set in doc-common
+.
+.de Brq
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Brq
+.
+.  ds doc-quote-left {
+.  ds doc-quote-right }
+.
+.  doc-enclose-string \$@
+..
+.
+.
+.\" NS Dq user macro
+.\" NS   enclose string in double quotes
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Dq' set in doc-common
+.
+.de Dq
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Dq
+.
+.  ds doc-quote-left "\*[Lq]
+.  ds doc-quote-right "\*[Rq]
+.
+.  doc-enclose-string \$@
+..
+.
+.
+.\" NS Eq user macro
+.\" NS   enclose string in user-defined quotes (args 1 and 2)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Eq' set in doc-common
+.
+.de Eq
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Eq
+.
+.  ds doc-quote-left "\$1
+.  ds doc-quote-right "\$2
+.
+.  shift 2
+.  doc-enclose-string \$@
+..
+.
+.
+.\" NS Pq user macro
+.\" NS   enclose string in parentheses
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Pq' set in doc-common
+.
+.de Pq
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Pq
+.
+.  ds doc-quote-left "\*[doc-left-parenthesis]
+.  ds doc-quote-right "\*[doc-right-parenthesis]
+.
+.  doc-enclose-string \$@
+..
+.
+.
+.\" NS Ql user macro
+.\" NS   quoted literal
+.\"
+.\"   is in file doc-[dit|n]roff
+.
+.
+.\" NS Qq user macro
+.\" NS   enclose string in straight double quotes
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Qq' set in doc-common
+.
+.de Qq
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Qq
+.
+.  ds doc-quote-left "\*[q]
+.  ds doc-quote-right "\*[q]
+.
+.  doc-enclose-string \$@
+..
+.
+.
+.\" NS Sq user macro
+.\" NS   enclose string in single quotes
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Sq' set in doc-common
+.
+.de Sq
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Sq
+.
+.  ds doc-quote-left "\*[doc-left-singlequote]
+.  ds doc-quote-right "\*[doc-right-singlequote]
+.
+.  doc-enclose-string \$@
+..
+.
+.
+.\" NS Es user macro
+.\" NS   set up arguments (i.e., the left and right quotation character as
+.\" NS   first and second argument) for .En call
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.
+.de Es
+.  if !\n[doc-arg-limit] \{\
+.    ie (\n[.$] > 2) \{\
+.      ds doc-macro-name Es
+.      doc-parse-args \$@
+.    \}
+.    el \{\
+.      ds doc-quote-left "\$1
+.      ds doc-quote-right "\$2
+.  \}\}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  ds doc-quote-left "\*[doc-arg\n[doc-arg-ptr]]
+.  nr doc-arg-ptr +1
+.  ds doc-quote-right "\*[doc-arg\n[doc-arg-ptr]]
+.  nr doc-arg-ptr +1
+.  ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \
+.    doc-do-\n[doc-type\n[doc-arg-ptr]]
+.  el \
+.    doc-print-and-reset
+..
+.
+.
+.\" NS doc-have-slot global register (bool)
+.\" NS   set if `doc-enclose-string' has created a slot for closing
+.\" NS   delimiter
+.
+.nr doc-have-slot 0
+.
+.
+.\" NS doc-enclose-string macro
+.\" NS   enclose string with given args (e.g. [ and ])
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-argXXX
+.\" NS   doc-have-slot
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-des
+.\" NS   doc-reg-des1
+.\" NS   doc-reg-des2
+.\" NS
+.\" NS requires:
+.\" NS   doc-quote-left
+.\" NS   doc-quote-right
+.
+.de doc-enclose-string
+.  if \n[doc-in-synopsis-section] \
+.    doc-set-hard-space
+.
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \
+.      doc-parse-args \$@
+.    el \{\
+.      nop \)\*[doc-quote-left]\*[doc-quote-right]
+.  \}\}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  nr doc-arg-ptr +1
+.  doc-print-prefixes
+.  \" the final `\)' prevents hyphenation in case the next character is `\%'
+.  nop \)\*[doc-quote-left]\)\c
+.  ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
+.    \" last argument
+.    nop \)\*[doc-quote-right]\)\c
+.    doc-print-and-reset
+.  \}
+.  el \{\
+.    \" test whether last arguments are of type closing punctuation
+.    \" resp. suffix
+.    ie (\n[doc-type\n[doc-arg-limit]] == 3) \{\
+.      nr doc-reg-des (\n[doc-arg-limit] - 1)
+.      while (\n[doc-type\n[doc-reg-des]] == 3) \
+.        nr doc-reg-des -1
+.
+.      \" prepend closing delimiter
+.      nr doc-reg-des +1
+.      ds doc-arg\n[doc-reg-des] "\*[doc-quote-right]\)\*[doc-arg\n[doc-reg-des]]
+.    \}
+.    el \{\
+.      \" test whether last arguments are macros which continue the line
+.      \" logically
+.      nr doc-reg-des \n[doc-arg-limit]
+.      while (\n[doc-reg-des] >= \n[doc-arg-ptr]) \{\
+.        if !\A\*[doc-arg\n[doc-reg-des]] \
+.          break
+.        if !d doc-after-\*[doc-arg\n[doc-reg-des]] \
+.          break
+.        nr doc-reg-des -1
+.      \}
+.
+.      \" if there are no trailing macros to be skipped, append argument
+.      ie (\n[doc-reg-des] == \n[doc-arg-limit]) \
+.        doc-append-arg "\)\*[doc-quote-right]\)" 3
+.      el \{\
+.        \" if a previous call to `doc-enclose-string' has already created
+.        \" a slot, prepend argument
+.        ie \n[doc-have-slot] \
+.          ds doc-arg\n[doc-reg-des] "\*[doc-quote-right]\)\*[doc-arg\n[doc-reg-des]]
+.        el \{\
+.          \" we have to shift all arguments to the right
+.          nr doc-reg-des +1
+.          nr doc-reg-des1 \n[doc-arg-limit]
+.          nr doc-reg-des2 (\n[doc-arg-limit] + 1)
+.          while (\n[doc-reg-des1] >= \n[doc-reg-des]) \{\
+.            rn doc-arg\n[doc-reg-des1] doc-arg\n[doc-reg-des2]
+.            rnn doc-type\n[doc-reg-des1] doc-type\n[doc-reg-des2]
+.            rn doc-space\n[doc-reg-des1] doc-space\n[doc-reg-des2]
+.            nr doc-reg-des1 -1
+.            nr doc-reg-des2 -1
+.          \}
+.          nr doc-arg-limit +1
+.
+.          \" finally, insert closing delimiter into the freed slot and
+.          \" recompute spacing vector
+.          ds doc-arg\n[doc-reg-des] "\)\*[doc-quote-right]\)
+.          nr doc-type\n[doc-reg-des] 3
+.          nr doc-num-args (\n[doc-arg-limit] - \n[doc-reg-des] + 1)
+.          nr doc-arg-limit (\n[doc-reg-des] - 1)
+.          doc-parse-space-vector
+.          nr doc-have-slot 1
+.    \}\}\}
+.
+.    doc-do-\n[doc-type\n[doc-arg-ptr]]
+.  \}
+.
+.  if \n[doc-in-synopsis-section] \
+.    doc-set-soft-space
+..
+.
+.
+.\" NS En user macro
+.\" NS   enclose arguments with quotation characters set up with `.Es'
+.
+.als En doc-enclose-string
+.
+.
+.\" NS Ao user macro
+.\" NS   angle open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Ao' set in doc-common
+.
+.de Ao
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Ao
+.
+.  ds doc-quote-left \[la]
+.
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Ac user macro
+.\" NS   angle close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Ac' set in doc-common
+.
+.de Ac
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Ac
+.
+.  ds doc-quote-right \[ra]
+.
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS Bo user macro
+.\" NS   bracket open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Bo' set in doc-common
+.
+.de Bo
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Bo
+.
+.  ds doc-quote-left "\*[doc-left-bracket]
+.
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Bc user macro
+.\" NS   bracket close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Bc' set in doc-common
+.
+.de Bc
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Bc
+.
+.  ds doc-quote-right "\*[doc-right-bracket]
+.
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS Bro user macro
+.\" NS   brace open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Bro' set in doc-common
+.
+.de Bro
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Bo
+.
+.  ds doc-quote-left {
+.
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Brc user macro
+.\" NS   brace close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Brc' set in doc-common
+.
+.de Brc
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Bc
+.
+.  ds doc-quote-right }
+.
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS Do user macro
+.\" NS   double quote open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Do' set in doc-common
+.
+.de Do
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Do
+.
+.  ds doc-quote-left "\*[Lq]
+.
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Dc user macro
+.\" NS   double quote close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Dc' set in doc-common
+.
+.de Dc
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Dc
+.
+.  ds doc-quote-right "\*[Rq]
+.
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS Eo user macro
+.\" NS   enclose open (using first argument as beginning of enclosure)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Eo' set in doc-common
+.
+.de Eo
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Eo
+.
+.  ds doc-quote-left "\$1
+.
+.  shift
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Ec user macro
+.\" NS   enclose close (using first argument as end of enclosure)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Ec' set in doc-common
+.
+.de Ec
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Ec
+.
+.  ds doc-quote-right "\$1
+.
+.  shift
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS Oo user macro
+.\" NS   option open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Oo' set in doc-common
+.
+.de Oo
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Oo
+.
+.  ds doc-quote-left [
+.
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Oc user macro
+.\" NS   option close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Oc' set in doc-common
+.
+.de Oc
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Oc
+.
+.  ds doc-quote-right ]
+.
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS Po user macro
+.\" NS   parenthesis open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Po' set in doc-common
+.
+.de Po
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Po
+.
+.  ds doc-quote-left "\*[doc-left-parenthesis]
+.
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Pc user macro
+.\" NS   parenthesis close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Pc' set in doc-common
+.
+.de Pc
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Pc
+.
+.  ds doc-quote-right "\*[doc-right-parenthesis]
+.
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS Qo user macro
+.\" NS   straight double quote open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Qo' set in doc-common
+.
+.de Qo
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Qo
+.
+.  ds doc-quote-left "\*[q]
+.
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Qc user macro
+.\" NS   straight double quote close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Qc' set in doc-common
+.
+.de Qc
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Qc
+.
+.  ds doc-quote-right "\*[q]
+.
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS So user macro
+.\" NS   single quote open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `So' set in doc-common
+.
+.de So
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name So
+.
+.  ds doc-quote-left "\*[doc-left-singlequote]
+.
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Sc user macro
+.\" NS   single quote close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Sc' set in doc-common
+.
+.de Sc
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Sc
+.
+.  ds doc-quote-right "\*[doc-right-singlequote]
+.
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS Xo user macro
+.\" NS   extend open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Xo' set in doc-common
+.
+.de Xo
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Xo
+.
+.  ds doc-quote-left
+.
+.  doc-enclose-open \$@
+..
+.
+.
+.\" NS Xc user macro
+.\" NS   extend close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS   doc-quote-right
+.\" NS
+.\" NS width register `Xc' set in doc-common
+.
+.de Xc
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Xc
+.
+.  ds doc-quote-right
+.
+.  doc-enclose-close \$@
+..
+.
+.
+.\" NS doc-nesting-level global register
+.\" NS   used by `doc-enclose-open' and `doc-enclose-close'
+.
+.nr doc-nesting-level 0
+.
+.
+.\" NS doc-in-list global register (bool)
+.\" NS   whether we are in (logical) .It
+.
+.nr doc-in-list 0
+.
+.
+.\" NS doc-enclose-open macro
+.\" NS   enclose string open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-nesting-level
+.
+.de doc-enclose-open
+.  if !\n[doc-arg-limit] \
+.    doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  doc-print-prefixes
+.  nr doc-arg-ptr -1
+.
+.  nop \)\*[doc-quote-left]\)\c
+.
+.  \" start enclosure box
+.  box doc-enclosure-box\n[doc-nesting-level]
+.  ev doc-enclosure-env\n[doc-nesting-level]
+.  evc 0
+.  in 0
+.  nf
+.  \" we insert something to make .chop always work
+.  nop \&\c
+.
+.  \" increase nesting level *after* parsing of arguments
+.  nr doc-nesting-level +1
+.
+.  if \n[doc-arg-limit] \{\
+.    nr doc-arg-ptr +1
+.    ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \
+.      doc-print-recursive
+.    el \
+.      doc-reset-args
+.  \}
+..
+.
+.
+.\" NS doc-enclose-close macro
+.\" NS   enclose string close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-nesting-level
+.
+.de doc-enclose-close
+.  nr doc-nesting-level -1
+.
+.  \" finish enclosure box
+.  br
+.  ev
+.  box
+.  chop doc-enclosure-box\n[doc-nesting-level]
+.  unformat doc-enclosure-box\n[doc-nesting-level]
+.
+.  nh
+.  nop \*[doc-enclosure-box\n[doc-nesting-level]]\c
+.  nop \)\*[doc-quote-right]\)\c
+.
+.  if !\n[doc-arg-limit] \{\
+.    doc-parse-args \$@
+.
+.    if !\n[.$] \
+.      doc-print-and-reset
+.  \}
+.
+.  if \n[doc-arg-limit] \{\
+.    ie (\n[doc-arg-limit] > \n[doc-arg-ptr]) \{\
+.      nop \)\*[doc-space\n[doc-arg-ptr]]\c
+.      nr doc-arg-ptr +1
+.      doc-print-recursive
+.    \}
+.    el \
+.      doc-print-and-reset
+.  \}
+.
+.  \" shall we finish .It macro?
+.  if !"\*[doc-macro-name]"It" \
+.    if \n[doc-in-list] \
+.      if !\n[doc-nesting-level] \
+.        doc-\*[doc-list-type-stack\n[doc-list-depth]]
+..
+.
+.
+.\" NS Pf user macro
+.\" NS   prefix: `.Pf prefix arg ...'
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-macro-name
+.\" NS   doc-quote-left
+.\" NS
+.\" NS width register `Pf' set in doc-common
+.
+.de Pf
+.  if !\n[doc-arg-limit] \
+.    ds doc-macro-name Pf
+.
+.  ie \n[doc-arg-limit] \{\
+.    ie ((\n[doc-arg-limit] - \n[doc-arg-ptr]) > 1) \{\
+.      nr doc-arg-ptr +1
+.      nop \)\*[doc-arg\n[doc-arg-ptr]]\c
+.    \}
+.    el \
+.      tm mdoc warning: .Pf: trailing prefix (#\n[.c])
+.  \}
+.  el \{\
+.    nop \)\$1\)\c
+.    shift
+.    ie \n[.$] \
+.      doc-parse-args \$@
+.    el \{\
+.      tm mdoc warning: .Pf: missing arguments (#\n[.c])
+.      nop \)
+.  \}\}
+.
+.  if \n[doc-arg-limit] \{\
+.    nr doc-arg-ptr +1
+.    ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \
+.      doc-print-and-reset
+.    el \
+.      doc-do-\n[doc-type\n[doc-arg-ptr]]
+.  \}
+..
+.
+.
+.\" NS Ns user macro
+.\" NS   remove space (space removal done by `doc-parse-args')
+.\" NS
+.\" NS modifies:
+.\" NS   doc-argXXX
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Ns' set in doc-common
+.
+.de Ns
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Ns
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      tm Usage: .Ns must be called with arguments (#\n[.c])
+.  \}
+.
+.  if \n[doc-arg-limit] \{\
+.    nr doc-arg-ptr +1
+.    ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \
+.      doc-print-recursive
+.    el \
+.      doc-reset-args
+.  \}
+..
+.
+.
+.\" NS Ap user macro
+.\" NS   append an apostrophe
+.\" NS
+.\" NS width register `Ap' set in doc-common
+.
+.de Ap
+.  ie !\n[doc-arg-limit] \
+.    tm Usage: `Ap' cannot be first macro on a line (no `.Ap') (#\n[.c])
+.  el \{\
+.    nop \)'\)\c
+.    nr doc-arg-ptr +1
+.    ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \
+.      doc-print-recursive
+.    el \
+.      doc-reset-args
+.  \}
+..
+.
+.
+.\" NS doc-space global string
+.\" NS   current inter-argument space
+.
+.ds doc-space "\*[doc-soft-space]
+.
+.
+.\" NS doc-soft-space constant string
+.\" NS   soft (stretchable) space (defined in doc-common)
+.
+.
+.\" NS doc-hard-space constant string
+.\" NS   hard (unpaddable) space (defined in doc-common)
+.
+.
+.\" NS doc-set-hard-space macro
+.\" NS   set current space string to hard (unpaddable) space.
+.\" NS
+.\" NS modifies:
+.\" NS   doc-saved-space
+.\" NS   doc-space
+.
+.de doc-set-hard-space
+.  ie "\*[doc-space]"" \
+.    ds doc-saved-space "\*[doc-hard-space]
+.  el \
+.    ds doc-space "\*[doc-hard-space]
+..
+.
+.
+.\" NS doc-set-soft-space macro
+.\" NS   set current space string to soft space
+.\" NS
+.\" NS modifies:
+.\" NS   doc-saved-space
+.\" NS   doc-space
+.
+.de doc-set-soft-space
+.  ie "\*[doc-space]"" \
+.    ds doc-saved-space "\*[doc-soft-space]
+.  el \
+.    ds doc-space "\*[doc-soft-space]
+..
+.
+.
+.\" NS doc-space-mode global register (bool)
+.\" NS   default is one (space mode on)
+.
+.nr doc-space-mode 1
+.
+.
+.\" NS doc-saved-space global string
+.\" NS   saved value of `doc-space'
+.
+.ds doc-saved-space "\*[doc-space]
+.
+.
+.\" NS doc-have-space global register (bool)
+.\" NS   set if last command was horizontal space
+.
+.nr doc-have-space 0
+.
+.
+.\" NS Sm user macro
+.\" NS   space mode (`.Sm'/`.Sm on'/`.Sm off')
+.\" NS
+.\" NS   without argument, toggle space mode
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-limit
+.\" NS   doc-arg-ptr
+.\" NS   doc-argXXX
+.\" NS   doc-macro-name
+.\" NS   doc-num-args
+.\" NS   doc-saved-space
+.\" NS   doc-space
+.\" NS   doc-space-mode
+.\" NS   doc-spaceXXX
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-Sm
+.\" NS
+.\" NS width register `Sm' set in doc-common
+.
+.de Sm
+.  ie \n[doc-have-space] \
+.    nr doc-reg-Sm 0
+.  el \
+.    nr doc-reg-Sm 1
+.
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Sm
+.      doc-parse-args \$@
+.    \}
+.    el \{\
+.      ie \n[doc-space-mode] \
+.        nr doc-space-mode 0
+.      el \
+.        nr doc-space-mode 1
+.  \}\}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.
+.  \" avoid a warning message in case `Sm' is the last parameter
+.  if !d doc-arg\n[doc-arg-ptr] \
+.    ds doc-arg\n[doc-arg-ptr]
+.
+.  ie "\*[doc-arg\n[doc-arg-ptr]]"on" \{\
+.    ds doc-space "\*[doc-saved-space]
+.    nr doc-space-mode 1
+.  \}
+.  el \{\
+.    ie "\*[doc-arg\n[doc-arg-ptr]]"off" \{\
+.      ds doc-saved-space "\*[doc-space]
+.      ds doc-space
+.      nr doc-space-mode 0
+.    \}
+.    el \{\
+.      \" no argument for Sm
+.      nr doc-arg-ptr -1
+.      ie \n[doc-space-mode] \
+.        nr doc-space-mode 0
+.      el \
+.        nr doc-space-mode 1
+.  \}\}
+.
+.  ie \n[doc-space-mode] \{\
+.    \" recompute space vector for remaining arguments
+.    nr doc-num-args (\n[doc-arg-limit] - \n[doc-arg-ptr])
+.    nr doc-arg-limit \n[doc-arg-ptr]
+.    if \n[doc-num-args] \
+.      doc-parse-space-vector
+.
+.    \" finish line only if it is interrupted and `doc-have-space'
+.    \" isn't set
+.    if \n[doc-reg-Sm] \
+.      if \n[.int] \
+.        nop \)
+.  \}
+.  el \{\
+.    \" reset remaining space vector elements
+.    nr doc-reg-Sm (\n[doc-arg-ptr] + 1)
+.    while (\n[doc-reg-Sm] <= \n[doc-arg-limit]) \{\
+.      ds doc-space\n[doc-reg-Sm]
+.      nr doc-reg-Sm +1
+.      \" the body of a `while' request must end with the fitting `\}'!
+.    \}
+.  \}
+.
+.  \" do we have parameters to print?
+.  ie (\n[doc-arg-limit] <= \n[doc-arg-ptr]) \{\
+.    \" ignore `.Sm on' and `.Sm off' without additional parameters
+.    ie (\n[doc-arg-ptr] > 1) \
+.      doc-print-and-reset
+.    el \
+.      doc-reset-args
+.  \}
+.  el \{\
+.    \" skip `Sm' argument
+.    nr doc-arg-ptr +1
+.    doc-print-recursive
+.  \}
+..
+.
+.
+.\" NS doc-arg-type immediate register
+.\" NS   argument type (macro=1, string=2, punctuation suffix=3,
+.\" NS   punctuation prefix=4)
+.
+.nr doc-arg-type 0
+.
+.
+.\" NS doc-get-arg-type macro
+.\" NS   get argument type
+.\" NS
+.\" NS   this macro expects the width of the argument in `doc-width'
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-type
+.
+.de doc-get-arg-type
+.  nr doc-arg-type 2
+.
+.  if ((\n[doc-width] < 4) & \A\$1) \{\
+.    ie (\n[doc-width] == 1) \{\
+.      if r doc-punct\$1 \
+.        nr doc-arg-type \n[doc-punct\$1]
+.    \}
+.    el \
+.      if r \$1 \
+.        if d \$1 \
+.          nr doc-arg-type 1
+.  \}
+..
+.
+.
+.\" NS doc-get-arg-type* macro
+.\" NS   similar to as `doc-get-arg-type' but uses doc-argXXX strings
+.\" NS
+.\" NS   this macro sets the `doc-width' register using the `length' request
+.\" NS   to get the number of characters in a string literally
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-type
+.\" NS   doc-width
+.
+.de doc-get-arg-type*
+.  nr doc-arg-type 2
+.  length doc-width "\*[doc-arg\$1]
+.
+.  if ((\n[doc-width] < 4) & \A\*[doc-arg\$1]) \{\
+.    ie (\n[doc-width] == 1) \{\
+.      if r doc-punct\*[doc-arg\$1] \
+.        nr doc-arg-type \n[doc-punct\*[doc-arg\$1]]
+.    \}
+.    el \
+.      if r \*[doc-arg\$1] \
+.        if d \*[doc-arg\$1] \
+.          nr doc-arg-type 1
+.  \}
+..
+.
+.
+.\" NS doc-set-spacing-1 macro
+.\" NS   set spacing for macros
+.\" NS
+.\" NS modifies:
+.\" NS   doc-spaceXXX
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dssfm
+.\" NS   doc-reg-dssfm1
+.
+.de doc-set-spacing-1
+.  nr doc-reg-dssfm1 \n[\*[doc-arg\n[doc-arg-limit]]]
+.
+.  \" closing macros like .Ac, Bc., etc. have value 3 (remove space before
+.  \" argument)
+.  ie (\n[doc-reg-dssfm1] == 3) \{\
+.    if \n[doc-arg-limit] \{\
+.      nr doc-reg-dssfm (\n[doc-arg-limit] - 1)
+.      ds doc-space\n[doc-reg-dssfm]
+.    \}
+.    ds doc-space\n[doc-arg-limit] "\*[doc-space]
+.  \}
+.  el \{\
+.    \" macros like .Ap and .Ns have value 2 (remove space before and after
+.    \" argument)
+.    ie (\n[doc-reg-dssfm1] == 2) \{\
+.      if \n[doc-arg-limit] \{\
+.        nr doc-reg-dssfm (\n[doc-arg-limit] - 1)
+.        ds doc-space\n[doc-reg-dssfm]
+.      \}
+.      ds doc-space\n[doc-arg-limit]
+.    \}
+.    el \
+.      ds doc-space\n[doc-arg-limit]
+.  \}
+..
+.
+.
+.\" NS doc-set-spacing-2 macro
+.\" NS   set spacing for strings
+.\" NS
+.\" NS modifies:
+.\" NS   doc-spaceXXX
+.
+.de doc-set-spacing-2
+.  ds doc-space\n[doc-arg-limit] "\*[doc-space]
+..
+.
+.
+.\" NS doc-set-spacing-3 macro
+.\" NS   set spacing for punctuation suffixes
+.\" NS
+.\" NS modifies:
+.\" NS   doc-spaceXXX
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dssfps
+.
+.de doc-set-spacing-3
+.  if \n[doc-arg-limit] \{\
+.    nr doc-reg-dssfps (\n[doc-arg-limit] - 1)
+.    ds doc-space\n[doc-reg-dssfps]
+.  \}
+.
+.  ds doc-space\n[doc-arg-limit] "\*[doc-space]
+..
+.
+.
+.\" NS doc-set-spacing-4 macro
+.\" NS   set spacing for punctuation prefixes
+.\" NS
+.\" NS modifies:
+.\" NS   doc-spaceXXX
+.
+.de doc-set-spacing-4
+.  ds doc-space\n[doc-arg-limit]
+..
+.
+.
+.\" type switches (on current argument doc-arg-ptr)
+.
+.
+.\" NS doc-do-1 macro
+.\" NS   call request if macro
+.
+.de doc-do-1
+.  \*[doc-arg\n[doc-arg-ptr]]
+..
+.
+.
+.\" NS doc-do-2 macro
+.\" NS   call .doc-print-recursive if string
+.
+.als doc-do-2 doc-print-recursive
+.
+.
+.\" NS doc-do-3 macro
+.\" NS   call .doc-print-recursive if punctuation suffix
+.
+.als doc-do-3 doc-print-recursive
+.
+.
+.\" NS doc-do-4 macro
+.\" NS   call .doc-print-recursive if punctuation prefix
+.
+.als doc-do-4 doc-print-recursive
+.
+.
+.\" NS doc-fontmode-depth global register
+.\" NS   font mode level
+.
+.nr doc-fontmode-depth 0
+.
+.
+.\" NS doc-fontmode-font-stackXXX global register
+.\" NS   stack of saved current font values from `Bf' macro
+.\" NS
+.\" NS limit:
+.\" NS   doc-fontmode-depth
+.
+.nr doc-fontmode-font-stack0 0
+.
+.
+.\" NS doc-fontmode-size-stackXXX global register
+.\" NS   stack of saved current size values from `Bf' macro
+.\" NS
+.\" NS limit:
+.\" NS   doc-fontmode-depth
+.
+.nr doc-fontmode-size-stack0 0
+.
+.
+.\" NS Bf user macro
+.\" NS   begin font mode (will be begin-mode/end-mode in groff & TeX)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-fontmode-depth
+.\" NS   doc-fontmode-font-stackXXX
+.\" NS   doc-fontmode-size-stackXXX
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Bf' set in doc-common
+.
+.de Bf
+.  ds doc-macro-name Bf
+.
+.  ie \n[.$] \{\
+.    nr doc-fontmode-depth +1
+.
+.    \" save current font and size
+.    nr doc-fontmode-font-stack\n[doc-fontmode-depth] \n[.f]
+.    nr doc-fontmode-size-stack\n[doc-fontmode-depth] \n[.ps]
+.
+.    ie        "\$1"Em" \
+.      nop \*[doc-Em-font]\c
+.    el \{ .ie "\$1"Li" \
+.      nop \*[doc-Li-font]\c
+.    el \{ .ie "\$1"Sy" \
+.      nop \*[doc-Sy-font]\c
+.    el \{ .ie "\$1"-emphasis" \
+.      nop \*[doc-Em-font]\c
+.    el \{ .ie "\$1"-literal" \
+.      nop \*[doc-Li-font]\c
+.    el \{ .ie "\$1"-symbolic" \
+.      nop \*[doc-Sy-font]\c
+.    el \{\
+.      tmc mdoc warning: Unknown keyword `\$1' in .Bf macro
+.      tm1 " (#\n[.c])
+.  \}\}\}\}\}\}\}
+.  el \
+.    tm Usage: .Bf [Em | -emphasis | Li | -literal | Sy | -symbolic] (#\n[.c])
+..
+.
+.
+.\" NS Ef user macro
+.\" NS   end font mode
+.\" NS
+.\" NS modifies:
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Ef' set in doc-common
+.
+.de Ef
+.  ds doc-macro-name Ef
+.
+.  ie \n[doc-fontmode-depth] \{\
+.    \" restore saved font and size
+.    nop \)\f[\n[doc-fontmode-font-stack\n[doc-fontmode-depth]]]\c
+.    nop \)\s[\n[doc-fontmode-size-stack\n[doc-fontmode-depth]]u]\c
+.
+.    nr doc-fontmode-font-stack\n[doc-fontmode-depth] 0
+.    nr doc-fontmode-size-stack\n[doc-fontmode-depth] 0
+.    nr doc-fontmode-depth -1
+.  \}
+.  el \
+.    tm mdoc warning: Extraneous .Ef (#\n[.c])
+..
+.
+.
+.\" NS doc-keep-type global register
+.\" NS   current keep type; 1 is `-words', 2 is `-lines', 3 is unknown
+.
+.nr doc-keep-type 0
+.
+.
+.\" NS Bk user macro
+.\" NS   begin keep
+.\" NS
+.\" NS modifies:
+.\" NS   doc-keep-type
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Bk' set in doc-common
+.
+.de Bk
+.  ds doc-macro-name Bk
+.
+.  if \n[doc-keep-type] \
+.    tm .Bk: nesting keeps not implemented yet. (#\n[.c])
+.
+.  ie        "\$1"-lines" \{\
+.    nr doc-keep-type 2
+.    tm .Bk -lines: Not implemented yet. (#\n[.c])
+.  \}
+.  el \{ .ie "\$1"-words" \{\
+.    nr doc-keep-type 1
+.    doc-set-hard-space
+.  \}
+.  el \{ .ie "\$1"" \{\
+.    \" default
+.    nr doc-keep-type 1
+.    doc-set-hard-space
+.  \}
+.  el \{\
+.    tm mdoc warning: Unknown keyword `\$1' in .Bk macro (#\n[.c])
+.    nr doc-keep-type 3
+.  \}\}\}
+.
+\#.  nr doc-nesting-level +1
+..
+.
+.
+.\" NS Ek user macro
+.\" NS   end keep
+.\" NS
+.\" NS modifies:
+.\" NS   doc-keep-type
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Ek' set in doc-common
+.
+.de Ek
+.  ds doc-macro-name Ek
+.
+\#.  nr doc-nesting-level -1
+.
+.  ie \n[.$] \
+.    tm Usage: .Ek (does not take arguments) (#\n[.c])
+.  el \{\
+.    if !\n[doc-keep-type] \
+.      tm mdoc warning: .Ek found without .Bk before (#\n[.c])
+.
+.    ie        (\n[doc-keep-type] == 1) \
+.      doc-set-soft-space
+.    el \{ .if (\n[doc-keep-type] == 2) \
+.      tm .Bk -lines: Not implemented yet. (#\n[.c])
+.  \}\}
+.
+.  nr doc-keep-type 0
+.
+\#.  if !"\*[doc-out-string]"" \
+\#.    doc-print-out-string
+..
+.
+.
+.\" NS doc-display-depth global register
+.\" NS   display level
+.
+.nr doc-display-depth 0
+.
+.
+.\" NS doc-is-compact global register (bool)
+.\" NS   set if the `compact' keyword is given
+.
+.nr doc-is-compact 0
+.
+.
+.\" NS doc-display-type-stackXXX global string
+.\" NS   the display type stack
+.\" NS
+.\" NS limit:
+.\" NS   doc-display-depth
+.
+.ds doc-display-type-stack0
+.
+.
+.\" NS doc-display-indent-stackXXX global register
+.\" NS   stack of display indentation values
+.\" NS
+.\" NS limit:
+.\" NS   doc-display-depth
+.
+.nr doc-display-indent-stack0 0
+.
+.
+.\" NS doc-display-ad-stackXXX global register
+.\" NS   stack of saved adjustment modes
+.\" NS
+.\" NS limit:
+.\" NS   doc-display-depth
+.
+.nr doc-display-ad-stack0 0
+.
+.
+.\" NS doc-display-fi-stackXXX global register
+.\" NS   stack of saved fill modes
+.\" NS
+.\" NS limit:
+.\" NS   doc-display-depth
+.
+.nr doc-display-fi-stack0 0
+.
+.
+.\" NS doc-display-ft-stackXXX global register
+.\" NS   stack of saved fonts
+.\" NS
+.\" NS limit:
+.\" NS   doc-display-depth
+.
+.nr doc-display-ft-stack0 0
+.
+.
+.\" NS doc-display-ps-stackXXX global register
+.\" NS   stack of saved font sizes
+.\" NS
+.\" NS limit:
+.\" NS   doc-display-depth
+.
+.nr doc-display-ps-stack0 0
+.
+.
+.\" NS Bd user macro
+.\" NS   begin display
+.\" NS
+.\" NS width register `Bd' set in doc-common
+.\" NS
+.\" NS modifies:
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-display-depth
+.\" NS   doc-display-ad-stackXXX
+.\" NS   doc-display-fi-stackXXX
+.\" NS   doc-display-ft-stackXXX
+.\" NS   doc-display-ps-stackXXX
+.\" NS   doc-display-file
+.\" NS   doc-display-indent-stackXXX
+.\" NS   doc-display-type-stackXXX
+.\" NS   doc-is-compact
+.\" NS   doc-macro-name
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-Bd
+.
+.de Bd
+.  ds doc-macro-name Bd
+.
+.  if !\n[.$] \{\
+.    tm1 "Usage: .Bd {-literal | -filled | -ragged | -centered | -unfilled}
+.    tm1 "           [-offset [string]] [-compact] [-file name] (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-is-compact 0
+.  ds doc-display-file
+.  nr doc-reg-Bd 1
+.  nr doc-display-depth +1
+.
+.  \" save current adjustment and fill modes
+.  nr doc-display-ad-stack\n[doc-display-depth] \n[.j]
+.  nr doc-display-fi-stack\n[doc-display-depth] \n[.u]
+.
+.  ie        "\$1"-literal" \{\
+.    ds doc-display-type-stack\n[doc-display-depth] literal
+.    nr doc-display-ft-stack\n[doc-display-depth] \n[.f]
+.    nr doc-display-ps-stack\n[doc-display-depth] \n[.ps]
+.
+.    ie t \{\
+.      nop \*[doc-Li-font]\c
+.      ta T 9n
+.    \}
+.    el \
+.      ta T 8n
+.    nf
+.  \}
+.  el \{ .ie "\$1"-filled" \{\
+.    ds doc-display-type-stack\n[doc-display-depth] filled
+.    ad b
+.    fi
+.  \}
+.  el \{ .ie "\$1"-ragged" \{\
+.    ds doc-display-type-stack\n[doc-display-depth] ragged
+.    na
+.    fi
+.  \}
+.  el \{ .ie "\$1"-centered" \{\
+.    ds doc-display-type-stack\n[doc-display-depth] centered
+.    ad c
+.    fi
+.  \}
+.  el \{ .ie "\$1"-unfilled" \{\
+.    ds doc-display-type-stack\n[doc-display-depth] unfilled
+.    nf
+.  \}
+.  el \{\
+.    tm1 "mdoc warning: Unknown keyword `\$1' (or missing display type)
+.    tm1 "              in .Bd macro (#\n[.c])
+.    nr doc-reg-Bd 0
+.  \}\}\}\}\}
+.
+.  \" have we seen an argument?
+.  if \n[doc-reg-Bd] \{\
+.    shift
+.    \" check other arguments
+.    if \n[.$] \
+.      doc-do-Bd-args \$@
+.  \}
+.
+.  \" avoid warning about non-existent register
+.  if !r doc-display-indent-stack\n[doc-display-depth] \
+.    nr doc-display-indent-stack\n[doc-display-depth] 0
+.
+.  if \n[doc-display-indent-stack\n[doc-display-depth]] \
+.    in +\n[doc-display-indent-stack\n[doc-display-depth]]u
+.
+.  if !\n[doc-is-compact] \
+.    sp \n[doc-display-vertical]u
+.
+.  if !\n[cR] \
+.    ne 2v
+.
+.  if !"\*[doc-display-file]"" \
+.    so \*[doc-display-file]
+.
+.  nr doc-is-compact 0
+.  ds doc-display-file
+..
+.
+.
+.\" NS doc-do-Bd-args macro
+.\" NS   resolve remaining .Bd arguments
+.\" NS
+.\" NS modifies:
+.\" NS   doc-display-file
+.\" NS   doc-display-indent-stackXXX
+.\" NS   doc-is-compact
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-ddBa
+.\" NS   doc-reg-ddBa1
+.\" NS   doc-reg-ddBa2
+.\" NS   doc-reg-ddBa3
+.\" NS   doc-reg-ddBa4
+.\" NS   doc-str-ddBa
+.
+.de doc-do-Bd-args
+.  nr doc-reg-ddBa 1
+.
+.  ie        "\$1"-offset" \{\
+.    nr doc-reg-ddBa 2
+.
+.    ie        "\$2"left" \
+.      nr doc-display-indent-stack\n[doc-display-depth] 0
+.    el \{ .ie "\$2"right" \
+.      nr doc-display-indent-stack\n[doc-display-depth] (\n[.l]u / 3u)
+.    el \{ .ie "\$2"center" \
+.      nr doc-display-indent-stack\n[doc-display-depth] ((\n[.l]u - \n[.i]u) / 4u)
+.    el \{ .ie "\$2"indent" \
+.      nr doc-display-indent-stack\n[doc-display-depth] \n[doc-display-indent]u
+.    el \{ .ie "\$2"indent-two" \
+.      nr doc-display-indent-stack\n[doc-display-depth] (\n[doc-display-indent]u + \n[doc-display-indent]u)
+.    el \
+.      nr doc-reg-ddBa 1
+.    \}\}\}\}
+.
+.    \" not a known keyword
+.    if (\n[doc-reg-ddBa] == 1) \{\
+.      nr doc-reg-ddBa 2
+.
+.      nr doc-reg-ddBa1 0
+.      if \B(\$2) \{\
+.        \" disable warnings related to scaling indicators (32)
+.        nr doc-reg-ddBa2 \n[.warn]
+.        warn (\n[.warn] - (\n[.warn] / 32 % 2 * 32))
+.
+.        \" values without a scaling indicator are taken as strings;
+.        \" we test whether the parameter string with and without the last
+.        \" character yields identical numerical results (ignoring the
+.        \" scaling indicator)
+.        ds doc-str-ddBa "\$2
+.        substring doc-str-ddBa 0 -2
+.        if \B(\*[doc-str-ddBa]) \{\
+.          nr doc-reg-ddBa3 (;(\$2))
+.          nr doc-reg-ddBa4 (\*[doc-str-ddBa])
+.          if (\n[doc-reg-ddBa3] == \n[doc-reg-ddBa4]) \
+.            nr doc-reg-ddBa1 1
+.        \}
+.
+.        \" enable all warnings again
+.        warn \n[doc-reg-ddBa2]
+.      \}
+.
+.      ie \n[doc-reg-ddBa1] \
+.        nr doc-display-indent-stack\n[doc-display-depth] \$2
+.      el \{\
+.        doc-get-width "\$2"
+.        ie (\n[doc-width] <= 3) \{\
+.          \" if the offset parameter is a macro, use the macro's
+.          \" width as specified in doc-common
+.          doc-get-arg-type "\$2"
+.          ie (\n[doc-arg-type] == 1) \
+.            nr doc-display-indent-stack\n[doc-display-depth] \n[\$2]
+.          el \
+.            nr doc-display-indent-stack\n[doc-display-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
+.        \}
+.        el \
+.          nr doc-display-indent-stack\n[doc-display-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
+.    \}\}
+.  \}
+.  el \{ .ie "\$1"-compact" \
+.    nr doc-is-compact 1
+.  el \{ .ie "\$1"-file" \{\
+.    ie !"\$2"" \{\
+.      ds doc-display-file "\$2
+.      nr doc-reg-ddBa 2
+.    \}
+.    el \
+.      tm mdoc warning: .Bd `-file' keyword requires argument (#\n[.c])
+.  \}
+.  el \
+.      tm mdoc warning: Unknown keyword `\$1' in .Bd macro (#\n[.c])
+.  \}\}
+.
+.  if (\n[doc-reg-ddBa] < \n[.$]) \{\
+.    shift \n[doc-reg-ddBa]
+.    doc-do-Bd-args \$@
+.  \}
+..
+.
+.
+.\" NS Ed user macro
+.\" NS   end display
+.\" NS
+.\" NS modifies:
+.\" NS   doc-display-depth
+.\" NS   doc-display-indent-stackXXX
+.\" NS   doc-display-type-stackXXX
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Ed' set in doc-common
+.
+.de Ed
+.  ds doc-macro-name Ed
+.
+.  br
+.
+.  if !\n[doc-display-depth] \{\
+.    tm mdoc warning: Extraneous .Ed (#\n[.c])
+.    nr doc-display-depth 1
+.  \}
+.
+.  if "\*[doc-display-type-stack\n[doc-display-depth]]"literal" \{\
+.    ft \n[doc-display-ft-stack\n[doc-display-depth]]
+.    ps \n[doc-display-ps-stack\n[doc-display-depth]]u
+.  \}
+.
+.  in -\n[doc-display-indent-stack\n[doc-display-depth]]u
+.
+.  \" restore saved adjustment and fill modes
+.  ie \n[doc-display-fi-stack\n[doc-display-depth]] \
+.    fi
+.  el \
+.    nf
+.  ad \n[doc-display-ad-stack\n[doc-display-depth]]
+.
+.  nr doc-display-indent-stack\n[doc-display-depth] 0
+.  ds doc-display-type-stack\n[doc-display-depth]
+.  nr doc-display-depth -1
+..
+.
+.
+.\" NS doc-list-type-stackXXX global string
+.\" NS   stack of list types
+.\" NS
+.\" NS limit:
+.\" NS   doc-list-depth
+.
+.ds doc-list-type-stack1
+.
+.
+.\" NS doc-list-indent-stackXXX global register
+.\" NS   stack of list indentation values
+.\" NS
+.\" NS limit:
+.\" NS   doc-list-depth
+.
+.nr doc-list-indent-stack1 0
+.
+.
+.\" NS doc-list-have-indent-stackXXX global register (bool)
+.\" NS   an indentation value is active
+.\" NS
+.\" NS limit:
+.\" NS   doc-list-depth
+.
+.nr doc-list-have-indent-stack1 0
+.
+.
+.\" NS Bl user macro
+.\" NS   begin list
+.\" NS
+.\" NS width register `Bl' set in doc-common
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-argXXX
+.\" NS   doc-list-depth
+.\" NS   doc-list-have-indent-stackXXX
+.\" NS   doc-list-indent-stackXXX
+.\" NS   doc-list-type-stackXXX
+.\" NS   doc-macro-name
+.\" NS   doc-num-args
+.\" NS   doc-num-columns
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-Bl
+.
+.de Bl
+.  if !\n[.$] \{\
+.    doc-Bl-usage
+.    return
+.  \}
+.
+.  ds doc-macro-name Bl
+.  nr doc-list-depth +1
+.  nr doc-arg-ptr 1
+.
+.  ie        "\$1"-hang" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] hang-list
+.    nr doc-list-indent-stack\n[doc-list-depth] 6n
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.  \}
+.  el \{ .ie "\$1"-tag" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] tag-list
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.  \}
+.  el \{ .ie "\$1"-item" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] item-list
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.  \}
+.  el \{ .ie "\$1"-enum" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] enum-list
+.    nr doc-list-indent-stack\n[doc-list-depth] 3n
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.  \}
+.  el \{ .ie "\$1"-bullet" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] bullet-list
+.    nr doc-list-indent-stack\n[doc-list-depth] 2n
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.  \}
+.  el \{ .ie "\$1"-dash" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] dash-list
+.    nr doc-list-indent-stack\n[doc-list-depth] 2n
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.  \}
+.  el \{ .ie "\$1"-hyphen" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] dash-list
+.    nr doc-list-indent-stack\n[doc-list-depth] 2n
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.  \}
+.  el \{ .ie "\$1"-inset" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] inset-list
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.  \}
+.  el \{ .ie "\$1"-diag" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] diag-list
+.  \}
+.  el \{ .ie "\$1"-ohang" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] ohang-list
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.  \}
+.  el \{ .ie "\$1"-column" \{\
+.    ds doc-list-type-stack\n[doc-list-depth] column-list
+.    linetabs 1
+.  \}
+.  el \{\
+.    tm1 "mdoc warning: Unknown list type `\$1' (or missing list type)
+.    tm1 "              in .Bl macro
+.    tm
+.    nr doc-arg-ptr 0
+.  \}\}\}\}\}\}\}\}\}\}\}
+.
+.  \" we have seen a list type
+.  if !\n[doc-arg-ptr] \{\
+.    doc-Bl-usage
+.    doc-reset-args
+.    nr doc-list-depth -1
+.    return
+.  \}
+.
+.  shift
+.
+.  \" fill argument vector
+.  nr doc-reg-Bl 1
+.  while (\n[doc-reg-Bl] <= \n[.$]) \{\
+.    ds doc-arg\n[doc-reg-Bl] "\$[\n[doc-reg-Bl]]
+.    \" dummy type and space so that doc-save-global-vars() doesn't warn
+.    nr doc-type\n[doc-reg-Bl] 0
+.    ds doc-space\n[doc-reg-Bl]
+.    nr doc-reg-Bl +1
+.  \}
+.
+.  doc-increment-list-stack
+.
+.  if \n[.$] \{\
+.    nr doc-arg-limit \n[.$]
+.    nr doc-arg-ptr 0
+.    doc-do-Bl-args
+.
+.    in +\n[doc-list-offset-stack\n[doc-list-depth]]u
+.
+.    \" initialize column list
+.    if "\*[doc-list-type-stack\n[doc-list-depth]]"column-list" \{\
+.      doc-set-column-tab \n[doc-num-columns]
+'      in -\n[doc-column-indent-width]u
+.      if !\n[doc-compact-list-stack\n[doc-list-depth]] \
+.        sp \n[doc-display-vertical]u
+.
+.      nf
+.      nr doc-num-columns 0
+.  \}\}
+.
+.  doc-reset-args
+..
+.
+.
+.\" NS doc-Bl-usage macro
+.
+.de doc-Bl-usage
+.  tm1 "Usage: .Bl {-hang | -ohang | -tag | -diag | -inset}
+.  tm1 "             [-width <string>]
+.  tm1 "             [-offset <string>] [-compact]
+.  tm1 "       .Bl -column [-offset <string>] <string1> <string2> ...
+.  tm1 "       .Bl {-item | -enum [-nested] | -bullet | -hyphen | -dash}
+.  tm1 "             [-offset <string>] [-compact] (#\n[.c])
+..
+.
+.
+.\" NS doc-do-Bl-args macro
+.\" NS   resolve remaining .Bl arguments
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-argXXX
+.\" NS   doc-compact-list-stackXXX
+.\" NS   doc-list-indent-stackXXX
+.\" NS   doc-list-offset-stackXXX
+.\" NS   doc-num-columns
+.\" NS   doc-tag-prefix-stackXXX
+.\" NS   doc-tag-width-stackXXX
+.\" NS
+.\" NS local variables:
+.\" NS   doc-box-dBla
+.\" NS   doc-env-dBla
+.\" NS   doc-reg-dBla
+.\" NS   doc-reg-dBla1
+.\" NS   doc-reg-dBla2
+.\" NS   doc-reg-dBla3
+.\" NS   doc-reg-dBla4
+.\" NS   doc-str-dBla
+.\" NS   doc-str-dBla1
+.
+.de doc-do-Bl-args
+.  nr doc-arg-ptr +1
+.
+.  if (\n[doc-arg-limit] < \n[doc-arg-ptr]) \
+.    return
+.
+.  \" avoid a warning message in case e.g. `-offset' has no parameter
+.  nr doc-reg-dBla (\n[doc-arg-ptr] + 1)
+.  if !d doc-arg\n[doc-reg-dBla] \
+.    ds doc-arg\n[doc-reg-dBla]
+.
+.  nr doc-reg-dBla 1
+.
+.  ie        "\*[doc-arg\n[doc-arg-ptr]]"-compact" \
+.    nr doc-compact-list-stack\n[doc-list-depth] 1
+.
+.  el \{ .ie "\*[doc-arg\n[doc-arg-ptr]]"-nested" \{\
+.    ie (\n[doc-list-depth] > 1) \{\
+.      nr doc-reg-dBla1 (\n[doc-list-depth] - 1)
+.      ds doc-tag-prefix-stack\n[doc-list-depth] "\*[doc-tag-prefix-stack\n[doc-reg-dBla1]]
+.      as doc-tag-prefix-stack\n[doc-list-depth] \n[doc-enum-list-count-stack\n[doc-reg-dBla1]].
+.      length doc-reg-dBla1 "\*[doc-tag-prefix-stack\n[doc-list-depth]]
+.      nr doc-list-indent-stack\n[doc-list-depth] +\n[doc-reg-dBla1]n
+.    \}
+.    el \
+.      tm mdoc warning: `-nested' allowed with nested .Bl macros only (#\n[.c])
+.  \}
+.
+.  el \{ .ie "\*[doc-arg\n[doc-arg-ptr]]"-width" \{\
+.    nr doc-arg-ptr +1
+.    ds doc-tag-width-stack\n[doc-list-depth] TagwidtH
+.
+.    ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
+.    substring doc-str-dBla 0 0
+.    ie .\*[doc-str-dBla] \{\
+.      ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
+.      substring doc-str-dBla 1
+.      doc-first-parameter \*[doc-str-dBla]
+.      doc-get-width "\*[doc-str-dfp]
+.      doc-get-arg-type "\*[doc-str-dfp]
+.      ie (\n[doc-arg-type] == 1) \
+.        nr doc-reg-dBla1 1
+.      el \
+.        nr doc-reg-dBla1 0
+.    \}
+.    el \
+.      nr doc-reg-dBla1 0
+.    ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
+.
+.    ie \n[doc-reg-dBla1] \{\
+.      \" execute string in a box to get the width of the diversion
+.      ds doc-str-dBla \*[doc-arg\n[doc-arg-ptr]]
+.      doc-save-global-vars
+.      doc-reset-args
+.      box doc-box-dBla
+.      ev doc-env-dBla
+.      evc 0
+.      in 0
+.      nf
+.      nop \*[doc-str-dBla]
+.      br
+.      ev
+.      box
+.      doc-restore-global-vars
+.      doc-get-width \h'\n[dl]u'
+.      nr doc-list-indent-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
+.    \}
+.    el \{\
+.      \" test whether argument is a valid numeric expression
+.      nr doc-reg-dBla1 0
+.      if \B(\*[doc-str-dBla]) \{\
+.        \" disable warnings related to scaling indicators (32)
+.        nr doc-reg-dBla2 \n[.warn]
+.        warn (\n[.warn] - (\n[.warn] / 32 % 2 * 32))
+.
+.        \" values without a scaling indicator are taken as strings;
+.        \" we test whether the parameter string with and without the last
+.        \" character yields identical numerical results (ignoring the
+.        \" scaling indicator)
+.        ds doc-str-dBla1 "\*[doc-str-dBla]
+.        substring doc-str-dBla1 0 -2
+.        if \B(\*[doc-str-dBla1]) \{\
+.          nr doc-reg-dBla3 (;(\*[doc-str-dBla]))
+.          nr doc-reg-dBla4 (\*[doc-str-dBla1])
+.          if (\n[doc-reg-dBla3] == \n[doc-reg-dBla4]) \
+.            nr doc-reg-dBla1 1
+.        \}
+.
+.        \" enable all warnings again
+.        warn \n[doc-reg-dBla2]
+.      \}
+.
+.      ie \n[doc-reg-dBla1] \
+.        nr doc-list-indent-stack\n[doc-list-depth] (\*[doc-str-dBla])
+.      el \{\
+.        doc-get-arg-width \n[doc-arg-ptr]
+.        ie (\n[doc-width] == 2) \{\
+.          \" if the width parameter is a macro, use the macro's
+.          \" width as specified in doc-common
+.          doc-get-arg-type \*[doc-str-dBla]
+.          ie (\n[doc-arg-type] == 1) \
+.            nr doc-list-indent-stack\n[doc-list-depth] \n[\*[doc-str-dBla]]
+.          el \
+.            nr doc-list-indent-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
+.        \}
+.        el \
+.          nr doc-list-indent-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
+.  \}\}\}
+.
+.  el \{ .ie "\*[doc-arg\n[doc-arg-ptr]]"-offset" \{\
+.    nr doc-arg-ptr +1
+.
+.    ie "\*[doc-arg\n[doc-arg-ptr]]"indent" \
+.      nr doc-list-offset-stack\n[doc-list-depth] \n[doc-display-indent]u
+.    el \{\
+.      ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
+.      nr doc-reg-dBla1 0
+.      if \B(\*[doc-str-dBla]) \{\
+.        nr doc-reg-dBla2 \n[.warn]
+.        warn (\n[.warn] - (\n[.warn] / 32 % 2 * 32))
+.
+.        ds doc-str-dBla1 "\*[doc-str-dBla]
+.        substring doc-str-dBla1 0 -2
+.        if \B(\*[doc-str-dBla1]) \{\
+.          nr doc-reg-dBla3 (;(\*[doc-str-dBla]))
+.          nr doc-reg-dBla4 (\*[doc-str-dBla1])
+.          if (\n[doc-reg-dBla3] == \n[doc-reg-dBla4]) \
+.            nr doc-reg-dBla1 1
+.        \}
+.
+.        warn \n[doc-reg-dBla2]
+.      \}
+.
+.      ie \n[doc-reg-dBla1] \
+.        nr doc-list-offset-stack\n[doc-list-depth] \*[doc-str-dBla]
+.      el \{\
+.        doc-get-arg-width \n[doc-arg-ptr]
+.        ie (\n[doc-width] <= 3) \{\
+.          \" if the offset parameter is a macro, use the macro's
+.          \" width as specified in doc-common
+.          doc-get-arg-type \*[doc-str-dBla]
+.          ie (\n[doc-arg-type] == 1) \
+.            nr doc-list-offset-stack\n[doc-list-depth] \n[\*[doc-str-dBla]]
+.          el \
+.            nr doc-list-offset-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
+.        \}
+.        el \
+.          nr doc-list-offset-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
+.  \}\}\}
+.  el \
+.    nr doc-reg-dBla 0
+.  \}\}\}
+.
+.  \" not a known keyword, so it specifies the width of the next column
+.  \" (if it is a column list)
+.  if !\n[doc-reg-dBla] \{\
+.    ie "\*[doc-list-type-stack\n[doc-list-depth]]"column-list" \{\
+.      nr doc-num-columns +1
+.      ds doc-str-dBla \*[doc-arg\n[doc-arg-ptr]]
+.      substring doc-str-dBla 0 0
+.      ie .\*[doc-str-dBla] \{\
+.        ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
+.        substring doc-str-dBla 1
+.        doc-first-parameter \*[doc-str-dBla]
+.        doc-get-width "\*[doc-str-dfp]
+.        doc-get-arg-type "\*[doc-str-dfp]
+.        ie (\n[doc-arg-type] == 1) \
+.          nr doc-reg-dBla1 1
+.        el \
+.          nr doc-reg-dBla1 0
+.      \}
+.      el \
+.        nr doc-reg-dBla1 0
+.      ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
+.
+.      ie \n[doc-reg-dBla1] \{\
+.        \" execute string in a box to get the width of the diversion
+.        ds doc-str-dBla \*[doc-arg\n[doc-arg-ptr]]
+.        doc-save-global-vars
+.        doc-reset-args
+.        box doc-box-dBla
+.        ev doc-env-dBla
+.        evc 0
+.        in 0
+.        nf
+.        nop \*[doc-str-dBla]
+.        br
+.        ev
+.        box
+.        doc-restore-global-vars
+.        ds doc-arg\n[doc-num-columns] "\h'\n[dl]u'
+.      \}
+.      el \
+.        ds doc-arg\n[doc-num-columns] "\*[doc-arg\n[doc-arg-ptr]]
+.    \}
+.    el \{\
+.      tmc mdoc warning: Unknown keyword `\*[doc-arg\n[doc-arg-ptr]]'
+.      tm1 " in .Bl macro (#\n[.c])
+.  \}\}
+.
+.  if (\n[doc-arg-limit] > \n[doc-arg-ptr]) \
+.    doc-do-Bl-args
+..
+.
+.
+.\" NS doc-save-global-vars macro
+.\" NS   save all global variables
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dsgv
+.
+.de doc-save-global-vars
+.  ds doc-macro-name-saved "\*[doc-macro-name]
+.  nr doc-arg-limit-saved \n[doc-arg-limit]
+.  nr doc-num-args-saved \n[doc-num-args]
+.  nr doc-arg-ptr-saved \n[doc-arg-ptr]
+.
+.  nr doc-reg-dsgv 1
+.  while (\n[doc-reg-dsgv] <= \n[doc-arg-limit]) \{\
+.    ds doc-arg\n[doc-reg-dsgv]-saved "\*[doc-arg\n[doc-reg-dsgv]]
+.    nr doc-type\n[doc-reg-dsgv]-saved \n[doc-type\n[doc-reg-dsgv]]
+.    ds doc-space\n[doc-reg-dsgv]-saved "\*[doc-space\n[doc-reg-dsgv]]
+.    nr doc-reg-dsgv +1
+.  \}
+.
+.  nr doc-curr-font-saved \n[doc-curr-font]
+.  nr doc-curr-size-saved \n[doc-curr-size]
+.  nr doc-in-synopsis-section-saved \n[doc-in-synopsis-section]
+.  nr doc-indent-synopsis-saved \n[doc-indent-synopsis]
+.  nr doc-indent-synopsis-active-saved \n[doc-indent-synopsis-active]
+.  nr doc-have-decl-saved \n[doc-have-decl]
+.  nr doc-have-var-saved \n[doc-have-var]
+.  ds doc-command-name-saved "\*[doc-command-name]
+.  ds doc-quote-left-saved "\*[doc-quote-left]
+.  ds doc-quote-right-saved "\*[doc-quote-right]
+.  nr doc-nesting-level-saved \n[doc-nesting-level]
+.  nr doc-in-list-saved \n[doc-in-list]
+.  ds doc-space-saved "\*[doc-space]
+.  ds doc-saved-space-saved "\*[doc-saved-space]
+.  nr doc-space-mode-saved \n[doc-space-mode]
+.  nr doc-have-space-saved \n[doc-have-space]
+.  nr doc-have-slot-saved \n[doc-have-slot]
+.  nr doc-keep-type-saved \n[doc-keep-type]
+.  nr doc-display-depth-saved \n[doc-display-depth]
+.  nr doc-is-compact-saved \n[doc-is-compact]
+.
+.  nr doc-reg-dsgv 0
+.  while (\n[doc-reg-dsgv] <= \n[doc-display-depth]) \{\
+.    ds doc-display-type-stack\n[doc-reg-dsgv]-saved "\*[doc-display-type-stack\n[doc-reg-dsgv]]
+.    nr doc-display-indent-stack\n[doc-reg-dsgv]-saved \n[doc-display-indent-stack\n[doc-reg-dsgv]]
+.    nr doc-display-ad-stack\n[doc-reg-dsgv]-saved \n[doc-display-ad-stack\n[doc-reg-dsgv]]
+.    nr doc-display-fi-stack\n[doc-reg-dsgv]-saved \n[doc-display-fi-stack\n[doc-reg-dsgv]]
+.    nr doc-display-ft-stack\n[doc-reg-dsgv]-saved \n[doc-display-ft-stack\n[doc-reg-dsgv]]
+.    nr doc-display-ps-stack\n[doc-reg-dsgv]-saved \n[doc-display-ps-stack\n[doc-reg-dsgv]]
+.    nr doc-reg-dsgv +1
+.  \}
+.
+.  nr doc-fontmode-depth-saved \n[doc-fontmode-depth]
+.
+.  nr doc-reg-dsgv 1
+.  while (\n[doc-reg-dsgv] <= \n[doc-fontmode-depth]) \{\
+.    nr doc-fontmode-font-stack\n[doc-reg-dsgv]-saved \n[doc-fontmode-font-stack\n[doc-reg-dsgv]]
+.    nr doc-fontmode-size-stack\n[doc-reg-dsgv]-saved \n[doc-fontmode-size-stack\n[doc-reg-dsgv]]
+.    nr doc-reg-dsgv +1
+.  \}
+.
+.  nr doc-list-depth-saved \n[doc-list-depth]
+.
+.  nr doc-reg-dsgv 1
+.  while (\n[doc-reg-dsgv] <= \n[doc-list-depth]) \{\
+.    ds doc-list-type-stack\n[doc-reg-dsgv]-saved "\*[doc-list-type-stack\n[doc-reg-dsgv]]
+.    nr doc-list-have-indent-stack\n[doc-reg-dsgv]-saved \n[doc-list-have-indent-stack\n[doc-reg-dsgv]]
+.    nr doc-list-indent-stack\n[doc-reg-dsgv]-saved \n[doc-list-indent-stack\n[doc-reg-dsgv]]
+.    nr doc-compact-list-stack\n[doc-reg-dsgv]-saved \n[doc-compact-list-stack\n[doc-reg-dsgv]]
+.    ds doc-tag-prefix-stack\n[doc-reg-dsgv]-saved "\*[doc-tag-prefix-stack\n[doc-reg-dsgv]]
+.    ds doc-tag-width-stack\n[doc-reg-dsgv]-saved "\*[doc-tag-width-stack\n[doc-reg-dsgv]]
+.    nr doc-list-offset-stack\n[doc-reg-dsgv]-saved \n[doc-list-offset-stack\n[doc-reg-dsgv]]
+.    nr doc-enum-list-count-stack\n[doc-reg-dsgv]-saved \n[doc-enum-list-count-stack\n[doc-reg-dsgv]]
+.    nr doc-reg-dsgv +1
+.  \}
+.
+.  ds doc-saved-Pa-font-saved "\*[doc-saved-Pa-font]
+.  nr doc-curr-type-saved \n[doc-curr-type]
+.  ds doc-curr-arg-saved "\*[doc-curr-arg]
+.  nr doc-diag-list-input-line-count-saved \n[doc-diag-list-input-line-count]
+.  nr doc-num-columns-saved \n[doc-num-columns]
+.  nr doc-column-indent-width-saved \n[doc-column-indent-width]
+.  nr doc-is-func-saved \n[doc-is-func]
+.  nr doc-have-old-func-saved \n[doc-have-old-func]
+.  nr doc-func-arg-count-saved \n[doc-func-arg-count]
+.  ds doc-func-arg-saved "\*[doc-func-arg]
+.  nr doc-num-func-args-saved \n[doc-num-func-args]
+.  nr doc-func-args-processed-saved \n[doc-func-args-processed]
+.  nr doc-have-func-saved \n[doc-have-func]
+.  nr doc-is-reference-saved \n[doc-is-reference]
+.  nr doc-reference-count-saved \n[doc-reference-count]
+.  nr doc-author-count-saved \n[doc-author-count]
+.
+.  nr doc-reg-dsgv 0
+.  while (\n[doc-reg-dsgv] <= \n[doc-author-count]) \{\
+.    ds doc-author-name\n[doc-reg-dsgv]-saved "\*[doc-author-name\n[doc-reg-dsgv]]
+.    nr doc-reg-dsgv +1
+.  \}
+.
+.  nr doc-book-count-saved \n[doc-book-count]
+.  ds doc-book-name-saved "\*[doc-book-name]
+.  nr doc-date-count-saved \n[doc-date-count]
+.  ds doc-date-saved "\*[doc-date]
+.  nr doc-publisher-count-saved \n[doc-publisher-count]
+.  ds doc-publisher-name-saved "\*[doc-publisher-name]
+.  nr doc-journal-count-saved \n[doc-journal-count]
+.  ds doc-journal-name-saved "\*[doc-journal-name]
+.  nr doc-issue-count-saved \n[doc-issue-count]
+.  ds doc-issue-name-saved "\*[doc-issue-name]
+.  nr doc-optional-count-saved \n[doc-optional-count]
+.  ds doc-optional-string-saved "\*[doc-optional-string]
+.  nr doc-page-number-count-saved \n[doc-page-number-count]
+.  ds doc-page-number-string-saved "\*[doc-page-number-string]
+.  nr doc-corporate-count-saved \n[doc-corporate-count]
+.  ds doc-corporate-name-saved "\*[doc-corporate-name]
+.  nr doc-report-count-saved \n[doc-report-count]
+.  ds doc-report-name-saved "\*[doc-report-name]
+.  nr doc-reference-title-count-saved \n[doc-reference-title-count]
+.  ds doc-reference-title-name-saved "\*[doc-reference-title-name]
+.  ds doc-reference-title-name-for-book-saved "\*[doc-reference-title-name-for-book]
+.  nr doc-volume-count-saved \n[doc-volume-count]
+.  ds doc-volume-name-saved "\*[doc-volume-name]
+.  nr doc-have-author-saved \n[doc-have-author]
+.
+.  ds doc-document-title-saved "\*[doc-document-title]
+.  ds doc-volume-saved "\*[doc-volume]
+.  ds doc-section-saved "\*[doc-section]
+.  ds doc-operating-system-saved "\*[doc-operating-system]
+.  ds doc-date-string-saved "\*[doc-date-string]
+.  nr doc-header-space-saved \n[doc-header-space]
+.  nr doc-footer-space-saved \n[doc-footer-space]
+.  nr doc-display-vertical-saved \n[doc-display-vertical]
+.  ds doc-header-string-saved "\*[doc-header-string]
+.  nr doc-in-see-also-section-saved \n[doc-in-see-also-section]
+.  nr doc-in-files-section-saved \n[doc-in-files-section]
+.  nr doc-in-authors-section-saved \n[doc-in-authors-section]
+..
+.
+.
+.\" NS doc-restore-global-vars macro
+.\" NS   restore all global variables
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-drgv
+.
+.de doc-restore-global-vars
+.  ds doc-macro-name "\*[doc-macro-name-saved]
+.  nr doc-arg-limit \n[doc-arg-limit-saved]
+.  nr doc-num-args \n[doc-num-args-saved]
+.  nr doc-arg-ptr \n[doc-arg-ptr-saved]
+.
+.  nr doc-reg-drgv 1
+.  while (\n[doc-reg-drgv] <= \n[doc-arg-limit]) \{\
+.    ds doc-arg\n[doc-reg-drgv] "\*[doc-arg\n[doc-reg-drgv]-saved]
+.    nr doc-type\n[doc-reg-drgv] \n[doc-type\n[doc-reg-drgv]-saved]
+.    ds doc-space\n[doc-reg-drgv] "\*[doc-space\n[doc-reg-drgv]-saved]
+.    nr doc-reg-drgv +1
+.  \}
+.
+.  nr doc-curr-font \n[doc-curr-font-saved]
+.  nr doc-curr-size \n[doc-curr-size-saved]
+.  nr doc-in-synopsis-section \n[doc-in-synopsis-section-saved]
+.  nr doc-indent-synopsis \n[doc-indent-synopsis-saved]
+.  nr doc-indent-synopsis-active \n[doc-indent-synopsis-active-saved]
+.  nr doc-have-decl \n[doc-have-decl-saved]
+.  nr doc-have-var \n[doc-have-var-saved]
+.  ds doc-command-name "\*[doc-command-name-saved]
+.  ds doc-quote-left "\*[doc-quote-left-saved]
+.  ds doc-quote-right "\*[doc-quote-right-saved]
+.  nr doc-nesting-level \n[doc-nesting-level-saved]
+.  nr doc-in-list \n[doc-in-list-saved]
+.  ds doc-space "\*[doc-space-saved]
+.  ds doc-saved-space "\*[doc-saved-space-saved]
+.  nr doc-space-mode \n[doc-space-mode-saved]
+.  nr doc-have-space \n[doc-have-space-saved]
+.  nr doc-have-slot \n[doc-have-slot-saved]
+.  nr doc-keep-type \n[doc-keep-type-saved]
+.  nr doc-display-depth \n[doc-display-depth-saved]
+.  nr doc-is-compact \n[doc-is-compact-saved]
+.
+.  nr doc-reg-drgv 0
+.  while (\n[doc-reg-drgv] <= \n[doc-display-depth]) \{\
+.    ds doc-display-type-stack\n[doc-reg-drgv] "\*[doc-display-type-stack\n[doc-reg-drgv]-saved]
+.    nr doc-display-indent-stack\n[doc-reg-drgv] \n[doc-display-indent-stack\n[doc-reg-drgv]-saved]
+.    nr doc-display-ad-stack\n[doc-reg-drgv] \n[doc-display-ad-stack\n[doc-reg-drgv]-saved]
+.    nr doc-display-fi-stack\n[doc-reg-drgv] \n[doc-display-fi-stack\n[doc-reg-drgv]-saved]
+.    nr doc-display-ft-stack\n[doc-reg-drgv] \n[doc-display-ft-stack\n[doc-reg-drgv]-saved]
+.    nr doc-display-ps-stack\n[doc-reg-drgv] \n[doc-display-ps-stack\n[doc-reg-drgv]-saved]
+.    nr doc-reg-drgv +1
+.  \}
+.
+.  nr doc-fontmode-depth \n[doc-fontmode-depth-saved]
+.
+.  nr doc-reg-drgv 1
+.  while (\n[doc-reg-drgv] <= \n[doc-fontmode-depth]) \{\
+.    nr doc-fontmode-font-stack\n[doc-reg-drgv] \n[doc-fontmode-font-stack\n[doc-reg-drgv]]-saved
+.    nr doc-fontmode-size-stack\n[doc-reg-drgv] \n[doc-fontmode-size-stack\n[doc-reg-drgv]]-saved
+.    nr doc-reg-drgv +1
+.  \}
+.
+.  nr doc-list-depth \n[doc-list-depth-saved]
+.
+.  nr doc-reg-drgv 1
+.  while (\n[doc-reg-drgv] <= \n[doc-list-depth]) \{\
+.    ds doc-list-type-stack\n[doc-reg-drgv] "\*[doc-list-type-stack\n[doc-reg-drgv]-saved]
+.    nr doc-list-have-indent-stack\n[doc-reg-drgv] \n[doc-list-have-indent-stack\n[doc-reg-drgv]-saved]
+.    nr doc-list-indent-stack\n[doc-reg-drgv] \n[doc-list-indent-stack\n[doc-reg-drgv]-saved]
+.    nr doc-compact-list-stack\n[doc-reg-drgv] \n[doc-compact-list-stack\n[doc-reg-drgv]-saved]
+.    ds doc-tag-prefix-stack\n[doc-reg-drgv] "\*[doc-tag-prefix-stack\n[doc-reg-drgv]-saved]
+.    ds doc-tag-width-stack\n[doc-reg-drgv] "\*[doc-tag-width-stack\n[doc-reg-drgv]-saved]
+.    nr doc-list-offset-stack\n[doc-reg-drgv] \n[doc-list-offset-stack\n[doc-reg-drgv]-saved]
+.    nr doc-enum-list-count-stack\n[doc-reg-drgv] \n[doc-enum-list-count-stack\n[doc-reg-drgv]-saved]
+.    nr doc-reg-drgv +1
+.  \}
+.
+.  ds doc-saved-Pa-font "\*[doc-saved-Pa-font-saved]
+.  nr doc-curr-type \n[doc-curr-type-saved]
+.  ds doc-curr-arg "\*[doc-curr-arg-saved]
+.  nr doc-diag-list-input-line-count \n[doc-diag-list-input-line-count-saved]
+.  nr doc-num-columns \n[doc-num-columns-saved]
+.  nr doc-column-indent-width \n[doc-column-indent-width-saved]
+.  nr doc-is-func \n[doc-is-func-saved]
+.  nr doc-have-old-func \n[doc-have-old-func-saved]
+.  nr doc-func-arg-count \n[doc-func-arg-count-saved]
+.  ds doc-func-arg "\*[doc-func-arg-saved]
+.  nr doc-num-func-args \n[doc-num-func-args-saved]
+.  nr doc-func-args-processed \n[doc-func-args-processed-saved]
+.  nr doc-have-func \n[doc-have-func-saved]
+.  nr doc-is-reference \n[doc-is-reference-saved]
+.  nr doc-reference-count \n[doc-reference-count-saved]
+.  nr doc-author-count \n[doc-author-count-saved]
+.
+.  nr doc-reg-drgv 0
+.  while (\n[doc-reg-drgv] <= \n[doc-author-count]) \{\
+.    ds doc-author-name\n[doc-reg-drgv] "\*[doc-author-name\n[doc-reg-drgv]-saved]
+.    nr doc-reg-drgv +1
+.  \}
+.
+.  nr doc-book-count \n[doc-book-count-saved]
+.  ds doc-book-name "\*[doc-book-name-saved]
+.  nr doc-date-count \n[doc-date-count-saved]
+.  ds doc-date "\*[doc-date-saved]
+.  nr doc-publisher-count \n[doc-publisher-count-saved]
+.  ds doc-publisher-name "\*[doc-publisher-name-saved]
+.  nr doc-journal-count \n[doc-journal-count-saved]
+.  ds doc-journal-name "\*[doc-journal-name-saved]
+.  nr doc-issue-count \n[doc-issue-count-saved]
+.  ds doc-issue-name "\*[doc-issue-name-saved]
+.  nr doc-optional-count \n[doc-optional-count-saved]
+.  ds doc-optional-string "\*[doc-optional-string-saved]
+.  nr doc-page-number-count \n[doc-page-number-count-saved]
+.  ds doc-page-number-string "\*[doc-page-number-string-saved]
+.  nr doc-corporate-count \n[doc-corporate-count-saved]
+.  ds doc-corporate-name "\*[doc-corporate-name-saved]
+.  nr doc-report-count \n[doc-report-count-saved]
+.  ds doc-report-name "\*[doc-report-name-saved]
+.  nr doc-reference-title-count \n[doc-reference-title-count-saved]
+.  ds doc-reference-title-name "\*[doc-reference-title-name-saved]
+.  ds doc-reference-title-name-for-book "\*[doc-reference-title-name-for-book-saved]
+.  nr doc-volume-count \n[doc-volume-count-saved]
+.  ds doc-volume-name "\*[doc-volume-name-saved]
+.  nr doc-have-author \n[doc-have-author-saved]
+.
+.  ds doc-document-title "\*[doc-document-title-saved]
+.  ds doc-volume "\*[doc-volume-saved]
+.  ds doc-section "\*[doc-section-saved]
+.  ds doc-operating-system "\*[doc-operating-system-saved]
+.  ds doc-date-string "\*[doc-date-string-saved]
+.  nr doc-header-space \n[doc-header-space-saved]
+.  nr doc-footer-space \n[doc-footer-space-saved]
+.  nr doc-display-vertical \n[doc-display-vertical-saved]
+.  ds doc-header-string "\*[doc-header-string-saved]
+.  nr doc-in-see-also-section \n[doc-in-see-also-section-saved]
+.  nr doc-in-files-section \n[doc-in-files-section-saved]
+.  nr doc-in-authors-section \n[doc-in-authors-section-saved]
+..
+.
+.
+.\" NS El user macro
+.\" NS   end list
+.\" NS
+.\" NS modifies:
+.\" NS   doc-list-depth
+.\" NS   doc-macro-name
+.\" NS
+.\" NS local variables:
+.\" NS   doc-str-El
+.\" NS
+.\" NS width register `El' set in doc-common
+.
+.de El
+.  if \n[.$] \{\
+.    tm Usage: .El (does not take arguments) (#\n[.c])
+.    return
+.  \}
+.
+.  ds doc-macro-name El
+.  ds doc-str-El \*[doc-list-type-stack\n[doc-list-depth]]
+.
+.  ie        "\*[doc-str-El]"diag-list" \
+.    doc-end-list 0
+.  el \{ .ie "\*[doc-str-El]"column-list" \
+.    doc-end-column-list
+.  el \{ .ie "\*[doc-str-El]"item-list" \
+.    doc-end-list 0
+.  el \{ .ie "\*[doc-str-El]"ohang-list" \
+.    doc-end-list 0
+.  el \{ .ie "\*[doc-str-El]"inset-list" \
+.    doc-end-list 0
+.  el \
+.    doc-end-list 1
+.  \}\}\}\}
+.
+.  br
+..
+.
+.
+.\" NS doc-saved-Pa-font global string
+.\" NS   saved doc-Pa-font string for section FILES (no underline if
+.\" NS   nroff)
+.
+.ds doc-saved-Pa-font
+.
+.
+.\" NS doc-curr-type global register
+.\" NS   current argument type
+.
+.nr doc-curr-type 0
+.
+.
+.\" NS doc-curr-arg global string
+.\" NS   current argument
+.
+.ds doc-curr-arg
+.
+.
+.\" NS doc-item-boxXXX global box
+.\" NS   item boxes associated list depth
+.\" NS
+.\" NS limit:
+.\" NS   doc-list-depth
+.
+.
+.\" NS It user macro
+.\" NS   list item
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-argXXX
+.\" NS   doc-curr-arg
+.\" NS   doc-curr-type
+.\" NS   doc-in-list
+.\" NS   doc-macro-name
+.\" NS   doc-num-args
+.\" NS   doc-saved-Pa-font
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-It
+.\" NS   doc-str-It
+.\" NS   doc-XXX-list-type
+.\" NS
+.\" NS width register `It' set in doc-common
+.
+.nr doc-bullet-list-type 1
+.nr doc-column-list-type 0
+.nr doc-dash-list-type 1
+.nr doc-diag-list-type 0
+.nr doc-enum-list-type 1
+.nr doc-hang-list-type 2
+.nr doc-inset-list-type 2
+.nr doc-item-list-type 1
+.nr doc-ohang-list-type 2
+.nr doc-tag-list-type 2
+.
+.de It
+.  ds doc-str-It \*[doc-list-type-stack\n[doc-list-depth]]
+.
+.  if "\*[doc-str-It]"" \
+.    tm mdoc error: .It without preceding .Bl (#\n[.c])
+.
+.  if \n[doc-nesting-level] \{\
+.    tmc "mdoc error: .It found in enclosing (e.g. .Ac ... .It ... .Ao)
+.    tm1 " (#\n[.c])
+.  \}
+.
+.  br
+.  if !\n[cR] \
+.    ne 3v
+.
+.  if \n[.$] \{\
+.    ds doc-macro-name It
+.
+.    \" fill argument vector
+.    nr doc-reg-It 1
+.    while (\n[doc-reg-It] <= \n[.$]) \{\
+.      ds doc-arg\n[doc-reg-It] "\$[\n[doc-reg-It]]
+.      nr doc-reg-It +1
+.    \}
+.
+.    nr doc-num-args \n[.$]
+.    nr doc-arg-ptr 0
+.  \}
+.
+.  nr doc-reg-It \n[doc-\*[doc-str-It]-type]
+.
+.  if \n[doc-reg-It] \{\
+.    \" start item box
+.    box doc-item-box\n[doc-list-depth]
+.    ev doc-item-env\n[doc-list-depth]
+.    evc 0
+.    in 0
+.    nf
+.  \}
+.
+.  ie (\n[doc-reg-It] == 1) \{\
+.    if \n[.$] \{\
+.      tm1 "mdoc warning: .It macros in lists of type `\*[doc-str-It]'
+.      tm1 "              don't take arguments (#\n[.c])
+.  \}\}
+.  el \{\
+.    ie \n[.$] \{\
+.      if (\n[doc-reg-It] == 2) \{\
+.        \" handle list types with arguments
+.        doc-parse-arg-vector
+.
+.        nr doc-in-list 1
+.        nr doc-arg-ptr 1
+.        nr doc-curr-type \n[doc-type1]
+.        ds doc-curr-arg "\*[doc-arg1]
+.
+.        if \n[doc-in-files-section] \{\
+.          ds doc-saved-Pa-font "\*[doc-Pa-font]
+.          if n \
+.            ds doc-Pa-font "\*[doc-No-font]
+.        \}
+.
+.        ie (\n[doc-type1] == 1) \
+.          \*[doc-arg1]
+.        el \{\
+.          nr doc-arg-ptr 1
+.          doc-print-recursive
+.    \}\}\}
+.    el \{\
+.      tm1 "mdoc warning: .It macros in lists of type `\*[doc-str-It]'
+.      tm1 "              require arguments (#\n[.c])
+.    \}
+.  \}
+.
+.  \" the previous call of `.doc-print-recursive' can contain calls to
+.  \" opening macros like `.Ao'; we then defer the call of `doc-xxx-list'
+.  if !\n[doc-nesting-level] \
+.    doc-\*[doc-str-It]
+..
+.
+.
+.\" NS doc-inset-list macro
+.\" NS   .It item of list-type inset
+.\" NS
+.\" NS modifies:
+.\" NS   doc-in-list
+.
+.de doc-inset-list
+.  \" finish item box
+.  br
+.  ev
+.  box
+.  unformat doc-item-box\n[doc-list-depth]
+.
+.  doc-set-vertical-and-indent 0
+.  br
+.
+.  nh
+.  doc-item-box\n[doc-list-depth]
+.
+.  if \n[doc-in-files-section] \
+.    if n \
+.      ds doc-Pa-font "\*[doc-saved-Pa-font]
+.
+.  nr doc-in-list 0
+.  doc-reset-args
+..
+.
+.
+.\" NS doc-hang-list macro
+.\" NS   .It item of list-type hanging tag (as opposed to tagged)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-have-space
+.\" NS   doc-in-list
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dhl
+.\" NS   doc-reg-dhl1
+.
+.de doc-hang-list
+.  \" finish item box
+.  br
+.  ev
+.  box
+.  unformat doc-item-box\n[doc-list-depth]
+.
+.  doc-set-vertical-and-indent 1
+.  nr doc-reg-dhl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
+.  ti -\n[doc-reg-dhl]u
+.
+.  nh
+.  ie (\n[dl]u > \n[doc-list-indent-stack\n[doc-list-depth]]u) \
+.    doc-item-box\n[doc-list-depth]
+.  el \{\
+.    chop doc-item-box\n[doc-list-depth]
+.    nr doc-reg-dhl1 \n[.k]u
+.    nop \*[doc-item-box\n[doc-list-depth]]\c
+.    nop \h'|(\n[doc-reg-dhl1]u - \n[.k]u + \n[doc-reg-dhl]u)'\c
+.    nr doc-have-space 1
+.  \}
+.
+.  if \n[doc-in-files-section] \
+.    if n \
+.      ds doc-Pa-font "\*[doc-saved-Pa-font]
+.
+.  nr doc-in-list 0
+.  doc-reset-args
+..
+.
+.
+.\" NS doc-ohang-list macro
+.\" NS   .It item of list-type overhanging tag
+.\" NS
+.\" NS modifies:
+.\" NS   doc-in-list
+.
+.de doc-ohang-list
+.  \" finish item box
+.  br
+.  ev
+.  box
+.  unformat doc-item-box\n[doc-list-depth]
+.
+.  doc-set-vertical-and-indent 0
+.  nh
+.  doc-item-box\n[doc-list-depth]
+.  br
+.
+.  if \n[doc-in-files-section] \
+.    if n \
+.      ds doc-Pa-font "\*[doc-saved-Pa-font]
+.
+.  nr doc-in-list 0
+.  doc-reset-args
+..
+.
+.
+.\" NS doc-item-list macro
+.\" NS   .It item of list-type [empty tag]
+.
+.de doc-item-list
+.  \" finish (dummy) item box
+.  br
+.  ev
+.  box
+.
+.  doc-set-vertical-and-indent 0
+.  br
+.
+.  doc-reset-args
+..
+.
+.
+.\" NS doc-enum-list-count-stackXXX global register
+.\" NS   stack of current enum count values
+.\" NS
+.\" NS limit:
+.\" NS   doc-list-depth
+.
+.nr doc-enum-list-count-stack1 0
+.
+.
+.\" NS doc-enum-list macro
+.\" NS   enumerated list
+.\" NS
+.\" NS modifies:
+.\" NS   doc-enum-list-count-stackXXX
+.\" NS   doc-in-list
+.
+.de doc-enum-list
+.  nr doc-in-list 1
+.  nr doc-enum-list-count-stack\n[doc-list-depth] +1
+\# XXX
+\#.ll \n[doc-list-indent-stack\n[doc-list-depth]]u
+\#.rj
+.  nop \*[doc-tag-prefix-stack\n[doc-list-depth]]\c
+.  nop \n[doc-enum-list-count-stack\n[doc-list-depth]].\&
+.  doc-do-list
+..
+.
+.
+.\" NS doc-bullet-list macro
+.\" NS   bullet paragraph list
+.\" NS
+.\" NS modifies:
+.\" NS   doc-in-list
+.
+.de doc-bullet-list
+.  nr doc-in-list 1
+.  nop \)\*[doc-Sy-font]\[bu]\f[]
+.  doc-do-list
+..
+.
+.
+.\" NS doc-dash-list macro
+.\" NS   hyphen paragraph list (sub bullet list)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-in-list
+.
+.de doc-dash-list
+.  nr doc-in-list 1
+.  nop \)\*[doc-Sy-font]\-\f[]
+.  doc-do-list
+..
+.
+.
+.\" NS doc-do-list macro
+.\" NS   .It item of list-type enum/bullet/hyphen
+.
+.als doc-do-list doc-hang-list
+.
+.
+.\" NS doc-diag-list-input-line-count global register
+.\" NS   saved line number to be checked in next diag-list item
+.
+.nr doc-diag-list-input-line-count 0
+.
+.
+.\" NS doc-diag-list macro
+.\" NS   .It item of list-type diagnostic-message
+.\" NS
+.\" NS modifies:
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-diag-list-input-line-count
+.
+.de doc-diag-list
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  ie ((\n[.c] - \n[doc-diag-list-input-line-count]) > 1) \{\
+.    ie !\n[doc-compact-list-stack\n[doc-list-depth]] \
+.      doc-paragraph
+.    el \
+.      br
+.  \}
+.  el \
+.    br
+.  nr doc-diag-list-input-line-count \n[.c]
+.
+.  nh
+.  nop \*[doc-Sy-font]\c
+.  if \n[doc-num-args] \
+.    doc-remaining-args
+.  nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]\*[doc-hard-space]\c
+.
+.  doc-print-and-reset
+..
+.
+.
+.\" NS doc-tag-list macro
+.\" NS   .It item of list-type `tag'
+.\" NS
+.\" NS modifies:
+.\" NS   doc-have-space
+.\" NS   doc-in-list
+.\" NS
+.\" NS local variables:
+.\" NS   doc-box-dtl
+.\" NS   doc-reg-dtl
+.\" NS   doc-reg-dtl1
+.
+.de doc-tag-list
+.  \" finish item box
+.  br
+.  ev
+.  box
+.  unformat doc-item-box\n[doc-list-depth]
+.
+.  \" we use a box without `.nf' to compute the tag width (via `dl' register)
+.  box doc-box-dtl
+.  ev doc-env-dtl
+.  evc 0
+.  fi
+.  ad 0
+.  in 0
+.  doc-item-box\n[doc-list-depth]
+.  br
+.  ev
+.  box
+.
+.  if !"TagwidtH"\*[doc-tag-width-stack\n[doc-list-depth]]" \{\
+.    if !\n[doc-list-have-indent-stack\n[doc-list-depth]] \{\
+.      in -(\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
+.      nr doc-list-have-indent-stack\n[doc-list-depth] 1
+.    \}
+.    doc-get-tag-width
+.  \}
+.  doc-set-vertical-and-indent 1
+.  nr doc-reg-dtl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
+.  ti -\n[doc-reg-dtl]u
+.
+.  nh
+.  ie (\n[dl]u > \n[doc-list-indent-stack\n[doc-list-depth]]u) \{\
+.    doc-item-box\n[doc-list-depth]
+.    br
+.  \}
+.  el \{\
+.    chop doc-item-box\n[doc-list-depth]
+.    \" Using \Z prevents stretching of the spaces in the tag
+.    nop \Z'\*[doc-item-box\n[doc-list-depth]]'\c
+.    nop \h'\n[doc-reg-dtl]u'\c
+.    nr doc-have-space 1
+.  \}
+.
+.  if \n[doc-in-files-section] \
+.    if n \
+.      ds doc-Pa-font "\*[doc-saved-Pa-font]
+.
+.  nr doc-in-list 0
+.  doc-reset-args
+..
+.
+.
+.\" NS doc-get-tag-width macro
+.\" NS   resolve unknown tag width (`tag' list-type only)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-list-indent-stackXXX
+.\" NS   doc-tag-width-stackXXX
+.\" NS
+.\" NS requires:
+.\" NS   doc-curr-arg
+.\" NS   doc-curr-type
+.
+.de doc-get-tag-width
+.  ie (\n[doc-curr-type] == 1) \{\
+.    ds doc-tag-width-stack\n[doc-list-depth] \*[doc-curr-arg]
+.    nr doc-list-indent-stack\n[doc-list-depth] \n[\*[doc-curr-arg]]
+.  \}
+.  el \{\
+.    ds doc-tag-width-stack\n[doc-list-depth] No
+.    nr doc-list-indent-stack\n[doc-list-depth] \n[No]
+.  \}
+..
+.
+.
+.\" NS doc-set-vertical-and-indent macro
+.\" NS   set up vertical spacing (if not compact) and indentation (with
+.\" NS   offset if argument is non-zero)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-list-have-indent-stackXXX
+.
+.de doc-set-vertical-and-indent
+.  if !\n[doc-compact-list-stack\n[doc-list-depth]] \
+.    sp \n[doc-display-vertical]u
+.
+.  if \n[doc-list-have-indent-stack\n[doc-list-depth]] \{\
+.    nr doc-list-have-indent-stack\n[doc-list-depth] 0
+.    if \$1 \
+.      in +(\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
+.  \}
+.
+.  if !\n[cR] \
+.    ne 2v
+..
+.
+.
+.\" NS doc-list-depth global register
+.\" NS   list type stack counter
+.
+.nr doc-list-depth 0
+.
+.
+.\" NS doc-num-columns global register
+.\" NS   number of columns
+.
+.nr doc-num-columns 0
+.
+.
+.\" NS doc-compact-list-stackXXX global register (bool)
+.\" NS   stack of flags to indicate whether a particular list is compact
+.\" NS
+.\" NS limit:
+.\" NS   doc-list-depth
+.
+.nr doc-compact-list-stack1 0
+.
+.
+.\" NS doc-tag-prefix-stackXXX global string
+.\" NS   stack of tag prefixes (currently used for -nested -enum lists)
+.\" NS
+.\" NS limit:
+.\" NS   doc-list-depth
+.
+.ds doc-tag-prefix-stack1
+.
+.
+.\" NS doc-tag-width-stackXXX global string
+.\" NS   stack of strings indicating how to set up current element of
+.\" NS   doc-list-indent-stackXXX -- if set to TagwidtH, user has set it
+.\" NS   directly; if it is a macro name, use the macro's width value;
+.\" NS   otherwise, `doc-get-tag-width' uses width value of `No'.
+.\" NS
+.\" NS limit:
+.\" NS   doc-list-depth
+.
+.ds doc-tag-width-stack0
+.ds doc-tag-width-stack1
+.
+.
+.\" NS doc-list-offset-stackXXX global register
+.\" NS   stack of list offsets
+.\" NS
+.\" NS limit:
+.\" NS   doc-list-depth
+.
+.nr doc-list-offset-stack1 0
+.
+.
+.\" NS doc-end-list macro
+.\" NS   list end function; resets indentation (and offset if argument is
+.\" NS   non-zero)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-list-depth
+.\" NS   doc-list-offset-stackXXX
+.
+.de doc-end-list
+.  if \$1 \
+'    in -(\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
+.
+'  in -\n[doc-list-offset-stack\n[doc-list-depth]]u
+.
+.  if (\n[doc-list-depth] <= 0) \
+.    tm mdoc warning: extraneous .El call (#\n[.c])
+.
+.  doc-decrement-list-stack
+.  nr doc-list-depth -1
+..
+.
+.
+.\" NS doc-increment-list-stack macro
+.\" NS   set up next block for list
+.\" NS
+.\" NS modifies:
+.\" NS   doc-compact-list-stackXXX
+.\" NS   doc-list-have-indent-stackXXX
+.\" NS   doc-list-indent-stackXXX
+.\" NS   doc-list-offset-stackXXX
+.\" NS   doc-list-type-stackXXX
+.\" NS   doc-tag-prefix-stackXXX
+.\" NS   doc-tag-width-stackXXX
+.\" NS   doc-enum-list-count-stackXXX
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dils
+.
+.de doc-increment-list-stack
+.  nr doc-reg-dils (\n[doc-list-depth] + 1)
+.  nr doc-list-have-indent-stack\n[doc-reg-dils] 0
+.  nr doc-list-indent-stack\n[doc-reg-dils] 0
+.  nr doc-list-offset-stack\n[doc-reg-dils] 0
+.  ds doc-tag-prefix-stack\n[doc-reg-dils]
+.  ds doc-tag-width-stack\n[doc-reg-dils] \*[doc-tag-width-stack\n[doc-list-depth]]
+.  ds doc-list-type-stack\n[doc-reg-dils]
+.  nr doc-compact-list-stack\n[doc-reg-dils] 0
+.  nr doc-enum-list-count-stack\n[doc-reg-dils] 0
+..
+.
+.
+.\" NS doc-decrement-list-stack macro
+.\" NS   decrement stack
+.\" NS
+.\" NS modifies:
+.\" NS   doc-compact-list-stackXXX
+.\" NS   doc-list-have-indent-stackXXX
+.\" NS   doc-list-indent-stackXXX
+.\" NS   doc-list-offset-stackXXX
+.\" NS   doc-list-type-stackXXX
+.\" NS   doc-tag-prefix-stackXXX
+.\" NS   doc-tag-width-stackXXX
+.\" NS   doc-enum-list-count-stackXXX
+.
+.de doc-decrement-list-stack
+.  ds doc-list-type-stack\n[doc-list-depth]
+.  nr doc-list-have-indent-stack\n[doc-list-depth] 0
+.  nr doc-list-indent-stack\n[doc-list-depth] 0
+.  nr doc-list-offset-stack\n[doc-list-depth] 0
+.  ds doc-tag-prefix-stack\n[doc-list-depth]
+.  ds doc-tag-width-stack\n[doc-list-depth]
+.  nr doc-compact-list-stack\n[doc-list-depth] 0
+.  nr doc-enum-list-count-stack\n[doc-list-depth] 0
+..
+.
+.
+.\" NS Xr user macro
+.\" NS   cross reference (for man pages only)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-macro-name
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-Xr
+.\" NS
+.\" NS width register `Xr' set in doc-common
+.
+.de Xr
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Xr
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      doc-Xr-usage
+.  \}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  doc-print-prefixes
+.  ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    \" first argument must be a string
+.    ie (\n[doc-type\n[doc-arg-ptr]] == 2) \{\
+.      nr doc-curr-font \n[.f]
+.      nr doc-curr-size \n[.ps]
+.      ds doc-arg\n[doc-arg-ptr] \*[doc-Xr-font]\*[doc-arg\n[doc-arg-ptr]]\f[]\s[0]
+.
+.      if (\n[doc-arg-limit] > \n[doc-arg-ptr]) \{\
+.        nr doc-reg-Xr (\n[doc-arg-ptr] + 1)
+.        \" modify second argument if it is a string and
+.        \" remove space inbetween
+.        if (\n[doc-type\n[doc-reg-Xr]] == 2) \{\
+.          ds doc-arg\n[doc-reg-Xr] \*[lp]\*[doc-arg\n[doc-reg-Xr]]\*[rp]
+.          ds doc-space\n[doc-arg-ptr]
+.        \}
+.      \}
+.      doc-print-recursive
+.    \}
+.    el \
+.      doc-Xr-usage
+.  \}
+.  el \
+.    doc-Xr-usage
+..
+.
+.
+.\" NS doc-Xr-usage macro
+.
+.de doc-Xr-usage
+.  tm Usage: .Xr manpage_name [section#] ... (#\n[.c])
+.  doc-reset-args
+..
+.
+.
+.\" NS Sx user macro
+.\" NS   cross section reference
+.\" NS
+.\" NS width register `Sx' set in doc-common
+.
+.als Sx doc-generic-macro
+.ds doc-Sx-usage section_header
+.
+.
+.\" NS doc-end-column-list macro
+.\" NS   column-list end-list
+.\" NS
+.\" NS modifies:
+.\" NS   doc-list-depth
+.
+.de doc-end-column-list
+.  linetabs 0
+'  in -(\n[doc-list-offset-stack\n[doc-list-depth]]u + \n[doc-list-indent-stack\n[doc-list-depth]]u)
+.  ta T .5i
+.  fi
+.  doc-decrement-list-stack
+.  nr doc-list-depth -1
+..
+.
+.
+.\" NS doc-column-indent-width global register
+.\" NS   holds the indent width for a column list
+.
+.nr doc-column-indent-width 0
+.
+.
+.\" NS doc-set-column-tab macro
+.\" NS   establish tabs for list-type column: `.doc-set-column-tab num_cols'
+.\" NS
+.\" NS modifies:
+.\" NS   doc-column-indent-width
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dsct
+.\" NS   doc-str-dsct
+.\" NS   doc-str-dsct1
+.
+.de doc-set-column-tab
+.  ds doc-str-dsct
+.  nr doc-reg-dsct 1
+.  nr doc-column-indent-width 0
+.
+.  ie (\$1 < 5) \
+.    ds doc-str-dsct1 "    \"
+.  el \{\
+.    ie (\$1 == 5) \
+.      ds doc-str-dsct1 "   \"
+.    el \{\
+.      \" XXX: this is packed abnormally close -- intercolumn width
+.      \"      should be configurable
+.      ds doc-str-dsct1 " \"
+.  \}\}
+.
+.  while (\n[doc-reg-dsct] <= \$1) \{\
+.    as doc-str-dsct " +\w\*[doc-arg\n[doc-reg-dsct]]\*[doc-str-dsct1]u
+.    nr doc-column-indent-width +\w\*[doc-arg\n[doc-reg-dsct]]\*[doc-str-dsct1]u
+.    nr doc-reg-dsct +1
+.  \}
+.
+.  ta \*[doc-str-dsct]
+'  in +\n[doc-column-indent-width]u
+..
+.
+.
+.\" NS doc-column-list macro
+.\" NS   column items
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-list-indent-stackXXX
+.\" NS   doc-spaceXXX
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dcl
+.
+.de doc-column-list
+.  if \n[doc-num-args] \
+.    doc-parse-arg-vector
+.  nr doc-arg-ptr +1
+.
+.  if (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
+.    tm Usage: .It column_string [Ta [column_string ...] ] (#\n[.c])
+.    return
+.  \}
+.
+.  if "\*[doc-arg\n[doc-arg-ptr]]"Ta" \{\
+.    nr doc-reg-dcl (\n[doc-arg-ptr] - 1)
+.    ds doc-space\n[doc-reg-dcl]
+.  \}
+.
+.  if !\n[doc-list-indent-stack\n[doc-list-depth]] \
+.    nr doc-list-indent-stack\n[doc-list-depth] \n[doc-column-indent-width]u
+.  if !\n[.u] \{\
+.    fi
+.    in +\n[doc-column-indent-width]u
+.  \}
+.  ti -\n[doc-column-indent-width]u
+.
+.  doc-do-\n[doc-type\n[doc-arg-ptr]]
+..
+.
+.
+.\" NS Ta user macro
+.\" NS   append tab (\t)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS
+.\" NS width register `Ta' set in doc-common
+.
+.de Ta
+.  ie \n[doc-arg-limit] \{\
+.    nr doc-arg-ptr +1
+.    nop \*[doc-tab]\c
+.    ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \
+.      doc-do-\n[doc-type\n[doc-arg-ptr]]
+.    el \
+.      doc-reset-args
+.  \}
+.  el \{\
+.    tm1 "Usage: Ta must follow column entry: e.g.
+.    tm1 "         .It column_string [Ta [column_string ...]] (#\n[.c])
+.  \}
+..
+.
+.
+.\" NS Dl user macro
+.\" NS   display (one line) literal
+.\" NS
+.\" NS   this function uses the `Li' font
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Dl' set in doc-common
+.
+.de Dl
+.  ta T .5i
+.  in +\n[doc-display-indent]u
+.
+.  ie \n[doc-arg-limit] \{\
+.    tm Usage: .Dl not callable by other macros (#\n[.c])
+.    doc-reset-args
+.  \}
+.  el \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Dl
+.      doc-parse-args \$@
+.      nr doc-arg-ptr 1
+.      nr doc-curr-font \n[.f]
+.      nr doc-curr-size \n[.ps]
+.      nop \*[doc-Li-font]\c
+.      doc-print-recursive
+.    \}
+.    el \
+.      tm Usage: .Dl argument ... (#\n[.c])
+.  \}
+.
+.  in -\n[doc-display-indent]u
+..
+.
+.
+.\" NS D1 user macro
+.\" NS   display (one line)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `D1' set in doc-common
+.
+.de D1
+.  ta T .5i
+.  in +\n[doc-display-indent]u
+.
+.  ie \n[doc-arg-limit] \{\
+.    tm Usage: .D1 not callable by other macros (#\n[.c])
+.    doc-reset-args
+.  \}
+.  el \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name D1
+.      doc-parse-args \$@
+.      nr doc-arg-ptr 1
+.      doc-print-recursive
+.    \}
+.    el \
+.      tm Usage: .D1 argument ... (#\n[.c])
+.  \}
+.
+.  in -\n[doc-display-indent]u
+..
+.
+.
+.\" NS Vt user macro
+.\" NS   variable type (for forcing old style variable declarations);
+.\" NS   this is not done in the same manner as .Ot for fortrash --
+.\" NS   clean up later
+.\" NS
+.\" NS modifies:
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-have-decl
+.\" NS   doc-have-var
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Vt' set in doc-common
+.
+.de Vt
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Vt
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      tm Usage: .Vt variable_type ... (#\n[.c])
+.  \}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  if (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
+.    tm Usage: .Vt variable_type ... (#\n[.c])
+.    doc-reset-args
+.    return
+.  \}
+.
+.  if \n[doc-in-synopsis-section] \{\
+.    \" if a function declaration was the last thing given,
+.    \" want vertical space
+.    if \n[doc-have-decl] \{\
+.      doc-paragraph
+.      nr doc-have-decl 0
+.    \}
+.
+.    \" if a subroutine was the last thing given, want vertical space
+.    if \n[doc-have-func] \{\
+.      ie \n[doc-have-var] \
+.        br
+.      el \
+.        doc-paragraph
+.    \}
+.
+.    nr doc-have-var 1
+.  \}
+.
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.  nop \*[doc-Ft-font]\c
+.  doc-print-recursive
+.
+.  if \n[doc-in-synopsis-section] \{\
+.    ie \n[doc-have-old-func] \
+.      nop \*[doc-soft-space]\c
+.    el \
+.      br
+.  \}
+..
+.
+.
+.\" NS doc-is-func global register (bool)
+.\" NS   set if subroutine (in synopsis only) (fortran only)
+.
+.nr doc-is-func 0
+.
+.
+.\" NS Ft user macro
+.\" NS   function type
+.\" NS
+.\" NS modifies:
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-have-decl
+.\" NS   doc-have-var
+.\" NS   doc-is-func
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Ft' set in doc-common
+.
+.de Ft
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Ft
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      tm Usage: .Ft function_type ... (#\n[.c])
+.  \}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  nr doc-arg-ptr +1
+.  if (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
+.    tm Usage: .Ft function_type ... (#\n[.c])
+.    doc-reset-args
+.    return
+.  \}
+.
+.  if \n[doc-in-synopsis-section] \{\
+.    if (\n[doc-have-func] : \n[doc-have-decl]) \{\
+.      doc-paragraph
+.      nr doc-have-decl 0
+.      nr doc-have-var 0
+.    \}
+.
+.    if \n[doc-have-var] \{\
+.      doc-paragraph
+.      nr doc-have-var 0
+.    \}
+.
+.    nr doc-is-func 1
+.  \}
+.
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.  nop \*[doc-Ft-font]\c
+.  doc-print-recursive
+..
+.
+.
+.\" NS doc-have-old-func global register (bool)
+.\" NS   set if `Ot' has been called
+.
+.nr doc-have-old-func 0
+.
+.
+.\" NS Ot user macro
+.\" NS   old function type (fortran -- no newline)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-have-decl
+.\" NS   doc-have-old-func
+.\" NS   doc-have-var
+.\" NS   doc-is-func
+.\" NS
+.\" NS width register `Ot' set in doc-common
+.
+.de Ot
+.  nr doc-have-old-func 1
+.
+.  if \n[doc-in-synopsis-section] \{\
+.    if (\n[doc-have-func] : \n[doc-have-decl]) \{\
+.      doc-paragraph
+.      nr doc-have-decl 0
+.      nr doc-have-var 0
+.    \}
+.
+.    if \n[doc-have-var] \{\
+.      doc-paragraph
+.      nr doc-have-var 0
+.    \}
+.
+.    nr doc-is-func 1
+.  \}
+.
+.  if \n[.$] \
+.    nop \*[doc-Ft-font]\$*\c
+.  nop \ \f[]\c
+..
+.
+.
+.\" NS Fa user macro
+.\" NS   function arguments
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Fa' set in doc-common
+.
+.de Fa
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Fa
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      tm Usage: .Fa function_arguments ... (#\n[.c])
+.  \}
+.
+.  ie \n[doc-func-arg-count] \
+.    doc-do-func
+.  el \{\
+.    nr doc-arg-ptr +1
+.    if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.      nr doc-curr-font \n[.f]
+.      nr doc-curr-size \n[.ps]
+.      nop \*[doc-Fa-font]\c
+.      doc-print-recursive
+.
+.      if \n[doc-in-synopsis-section] \
+.        if \n[doc-have-func] \
+.          br
+.  \}\}
+..
+.
+.
+.\" NS doc-func-arg-count global register
+.\" NS   how many function arguments have been processed so far
+.
+.nr doc-func-arg-count 0
+.
+.
+.\" NS doc-func-arg global string
+.\" NS   work buffer for function name strings
+.
+.ds doc-func-arg
+.
+.
+.\" NS doc-num-func-args global register
+.\" NS   number of function arguments
+.
+.nr doc-num-func-args 0
+.
+.
+.\" NS doc-func-args-processed global register
+.\" NS   function arguments processed so far
+.
+.nr doc-func-args-processed 0
+.
+.
+.\" NS doc-do-func macro
+.\" NS   internal .Fa for .Fc
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-argXXX
+.\" NS   doc-func-arg
+.\" NS   doc-func-arg-count
+.\" NS   doc-func-args-processed
+.\" NS   doc-num-func-args
+.
+.de doc-do-func
+.  if (\n[doc-arg-limit] <= \n[doc-arg-ptr]) \{\
+.    doc-reset-args
+.    return
+.  \}
+.
+.  nr doc-arg-ptr +1
+.
+.  ds doc-func-arg
+.  nr doc-num-func-args 0
+.  nr doc-func-args-processed 0
+.
+.  doc-build-func-string \*[doc-arg\n[doc-arg-ptr]]
+.  if (\n[doc-num-func-args] > 1) \
+.    ds doc-arg\n[doc-arg-ptr] "\*[doc-func-arg]
+.
+.  if (\n[doc-func-arg-count] > 1) \{\
+.    nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]\|,\)\c
+.    nop \)\*[doc-space\n[doc-arg-ptr]]\*[doc-Fa-font]\c
+.    nop \)\*[doc-arg\n[doc-arg-ptr]]\f[]\s[0]\c
+.  \}
+.
+.  if (\n[doc-func-arg-count] == 1) \{\
+.    nop \|\*[doc-Fa-font]\*[doc-arg\n[doc-arg-ptr]]\c
+.    nop \f[]\s[0]\c
+.  \}
+.  nr doc-func-arg-count +1
+.  doc-do-func
+..
+.
+.
+.\" NS doc-have-func global register (bool)
+.\" NS   whether we have more than one function in synopsis
+.
+.nr doc-have-func 0
+.
+.
+.\" NS Fn user macro
+.\" NS   functions
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-have-decl
+.\" NS   doc-have-func
+.\" NS   doc-have-var
+.\" NS   doc-indent-synopsis
+.\" NS   doc-is-func
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Fn' set in doc-common
+.
+.de Fn
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Fn
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      tm Usage: .Fn function_name [function_arg] ... (#\n[.c])
+.  \}
+.
+.  if !\n[doc-arg-limit] \
+.    return
+.
+.  if \n[doc-in-synopsis-section] \{\
+.    \" if there is/has been more than one subroutine declaration
+.    ie \n[doc-is-func] \{\
+.      br
+.      nr doc-have-var 0
+.      nr doc-have-decl 0
+.      nr doc-is-func 0
+.    \}
+.    el \{\
+.      if \n[doc-have-func] \{\
+.        doc-paragraph
+.        nr doc-have-var 0
+.        nr doc-have-decl 0
+.    \}\}
+.
+.    if \n[doc-have-decl] \{\
+.      doc-paragraph
+.      nr doc-have-var 0
+.    \}
+.
+.    if \n[doc-have-var] \{\
+.      doc-paragraph
+.      nr doc-have-decl 0
+.    \}
+.
+.    nr doc-have-func 1
+.    nr doc-is-func 0
+.
+.    br
+.    if !\n[doc-indent-synopsis] \
+.      nr doc-indent-synopsis (8u * \n[doc-fixed-width]u)
+.    if !\n[doc-indent-synopsis-active] \
+.      in +\n[doc-indent-synopsis]u
+.    ti -\n[doc-indent-synopsis]u
+.  \}
+.
+.  nr doc-arg-ptr +1
+.  doc-print-prefixes
+.  if (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
+.    tm Usage: .Fn function_name [function_arg] ... (#\n[.c])
+.    doc-reset-args
+.    return
+.  \}
+.
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.  nop \*[doc-Fn-font]\*[doc-arg\n[doc-arg-ptr]]\c
+.  nop \f[]\s[0]\*[lp]\)\c
+.
+.  nr doc-arg-ptr +1
+.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    if (\n[doc-type\n[doc-arg-ptr]] == 2) \{\
+.      nop \*[doc-Fa-font]\c
+.      doc-do-func-args
+.      nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]\c
+.  \}\}
+.
+.  nop \)\*[rp]\)\c
+.  if \n[doc-in-synopsis-section] \
+.    nop \);\)\c
+.
+.  ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    \" output the space (if needed)
+.    nr doc-arg-ptr -1
+.    nop \)\*[doc-space\n[doc-arg-ptr]]\c
+.    nr doc-arg-ptr +1
+.
+.    doc-print-recursive
+.  \}
+.  el \
+.    doc-print-and-reset
+.
+.  if \n[doc-in-synopsis-section] \
+.    if !\n[doc-indent-synopsis-active] \
+.      in -\n[doc-indent-synopsis]u
+..
+.
+.
+.\" NS doc-do-func-args macro
+.\" NS   handle function arguments
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-argXXX
+.\" NS   doc-func-arg
+.\" NS   doc-func-args-processed
+.\" NS   doc-num-func-args
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-ddfa
+.
+.de doc-do-func-args
+.  if \n[doc-in-synopsis-section] \{\
+.    ds doc-func-arg
+.    nr doc-num-func-args 0
+.    nr doc-func-args-processed 0
+.
+.    doc-build-func-string \*[doc-arg\n[doc-arg-ptr]]
+.    if (\n[doc-num-func-args] > 1) \
+.      ds doc-arg\n[doc-arg-ptr] "\*[doc-func-arg]
+.  \}
+.
+.  nop \)\*[doc-arg\n[doc-arg-ptr]]\c
+.  nr doc-arg-ptr +1
+.
+.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    if (\n[doc-type\n[doc-arg-ptr]] == 2) \{\
+.      nr doc-reg-ddfa (\n[doc-arg-ptr] - 1)
+.      nop \|\f[\n[doc-curr-font]]\s[\n[doc-curr-size]u],\)\c
+.      nop \)\*[doc-space\n[doc-reg-ddfa]]\f[]\s[0]\|\c
+.      doc-do-func-args
+.  \}\}
+..
+.
+.
+.\" NS doc-saved-nesting-level global register
+.
+.nr doc-saved-nesting-level 0
+.
+.
+.\" NS doc-in-func-enclosure global register (bool)
+.
+.nr doc-in-func-enclosure 0
+.
+.
+.\" NS Fo user macro
+.\" NS   function open
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-func-arg-count
+.\" NS   doc-have-decl
+.\" NS   doc-have-func
+.\" NS   doc-have-var
+.\" NS   doc-in-func-enclosure
+.\" NS   doc-indent-synopsis
+.\" NS   doc-is-func
+.\" NS   doc-macro-name
+.\" NS   doc-saved-nesting-level
+.\" NS
+.\" NS width register `Fo' set in doc-common
+.
+.de Fo
+.  if (\n[doc-in-func-enclosure]) \{\
+.    tm mdoc error: .Fo/.Fc can't be nested (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-saved-nesting-level \n[doc-nesting-level]
+.  nr doc-in-func-enclosure 1
+.
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ds doc-macro-name Fo
+.      doc-parse-args \$@
+.    \}
+.    el \
+.      tm Usage: .Fo function_name (#\n[.c])
+.  \}
+.
+.  if \n[doc-in-synopsis-section] \{\
+.    \" if there is/has been more than one subroutine declaration
+.    ie \n[doc-is-func] \{\
+.      br
+.      nr doc-have-var 0
+.      nr doc-have-decl 0
+.      nr doc-is-func 0
+.    \}
+.    el \{\
+.      if \n[doc-have-func] \{\
+.        doc-paragraph
+.        nr doc-have-var 0
+.        nr doc-have-decl 0
+.    \}\}
+.
+.    if \n[doc-have-decl] \{\
+.      doc-paragraph
+.      nr doc-have-var 0
+.    \}
+.
+.    if \n[doc-have-var] \{\
+.      doc-paragraph
+.      nr doc-have-decl 0
+.    \}
+.
+.    nr doc-have-func 1
+.    nr doc-is-func 0
+.
+.    br
+.    if !\n[doc-indent-synopsis] \
+.      nr doc-indent-synopsis (8u * \n[doc-fixed-width]u)
+.  \}
+.
+.  \" start function box
+.  box doc-func-box
+.  ev doc-func-env
+.  evc 0
+.  in 0
+.  nf
+.
+.  nr doc-arg-ptr +1
+.  doc-print-prefixes
+.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    nr doc-func-arg-count 1
+.    nr doc-curr-font \n[.f]
+.    nr doc-curr-size \n[.ps]
+.
+.    nop \*[doc-Fn-font]\*[doc-arg\n[doc-arg-ptr]]\c
+.    nop \f[]\s[0]\*[lp]\)\c
+.    doc-reset-args
+.  \}
+..
+.
+.
+.\" NS Fc user macro
+.\" NS   function close
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-func-arg-count
+.\" NS   doc-in-func-enclosure
+.\" NS   doc-saved-nesting-level
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `Fc' set in doc-common
+.
+.de Fc
+.  if !\n[doc-in-func-enclosure] \{\
+.    tm mdoc warning: Extraneous .Fc (#\n[.c])
+.    return
+.  \}
+.
+.  if \n[.$] \{\
+.    ds doc-macro-name Fc
+.    \" the first (dummy) argument is used to get the correct spacing
+.    doc-parse-args \) \$@
+.  \}
+.
+.  if !(\n[doc-saved-nesting-level] == \n[doc-nesting-level]) \
+.    tm mdoc warning: Unbalanced enclosure commands within .Fo/.Fc
+.
+.  nr doc-func-arg-count 0
+.  nr doc-in-func-enclosure 0
+.
+.  ie \n[doc-in-synopsis-section] \
+.    nop \|\*[rp];\)
+.  el \
+.    nop \|\*[rp]\)
+.
+.  \" finish function box
+.  br
+.  ev
+.  box
+.  chop doc-func-box
+.  unformat doc-func-box
+.
+.  if \n[doc-in-synopsis-section] \{\
+.    if !\n[doc-indent-synopsis-active] \
+.      in +\n[doc-indent-synopsis]u
+.    ti -\n[doc-indent-synopsis]u
+.  \}
+.
+.  nh
+.  nop \*[doc-func-box]\c
+.
+.  nr doc-arg-ptr +1
+.  ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.    nr doc-curr-font \n[.f]
+.    nr doc-curr-size \n[.ps]
+.    doc-print-recursive
+.  \}
+.  el \
+.    doc-print-and-reset
+.
+.  if \n[doc-in-synopsis-section] \
+.    if !\n[doc-indent-synopsis-active] \
+.      in -\n[doc-indent-synopsis]u
+..
+.
+.
+.\" NS doc-build-func-string macro
+.\" NS   collect function arguments and set hard spaces inbetween
+.\" NS
+.\" NS modifies:
+.\" NS   doc-func-arg
+.\" NS   doc-func-args-processed
+.\" NS   doc-num-func-args
+.
+.de doc-build-func-string
+.  if !\n[doc-num-func-args] \{\
+.    nr doc-num-func-args \n[.$]
+.    nr doc-func-args-processed 0
+.    ds doc-func-arg
+.  \}
+.
+.  nr doc-func-args-processed +1
+.  as doc-func-arg "\$1
+.
+.  if (\n[doc-func-args-processed] < \n[doc-num-func-args]) \{\
+.    as doc-func-arg "\*[doc-hard-space]
+.
+.    shift
+.    doc-build-func-string \$@
+.  \}
+..
+.
+.
+.\" Very crude references: Stash all reference info into boxes, print out
+.\" reference on .Re macro and clean up.  Ordering very limited, no fancy
+.\" citations, but can do articles, journals, and books -- need to add
+.\" several missing options (like city etc).  Should be able to grab a refer
+.\" entry, massage it a wee bit (prefix a `.' to the %[A-Z]) and not worry
+.\" (ha!).
+.
+.
+.\" NS doc-is-reference global register (bool)
+.\" NS   set if in reference
+.
+.nr doc-is-reference 0
+.
+.
+.\" NS doc-reference-count global register
+.\" NS   reference element counter
+.
+.nr doc-reference-count 0
+.
+.
+.\" NS Rs user macro
+.\" NS   reference start
+.\" NS
+.\" NS modifies:
+.\" NS   doc-is-reference
+.\" NS   doc-reference-count
+.\" NS
+.\" NS width register `Rs' set in doc-common
+.
+.de Rs
+.  ie \n[.$] \
+.    tm Usage: .Rs (does not take arguments) (#\n[.c])
+.  el \{\
+.    nr doc-is-reference 1
+.    doc-reset-reference
+.    if \n[doc-in-see-also-section] \
+.      doc-paragraph
+.    nr doc-reference-count 0
+.  \}
+..
+.
+.
+.\" NS Re user macro
+.\" NS   reference end
+.\" NS
+.\" NS modifies:
+.\" NS   doc-is-reference
+.\" NS
+.\" NS width register `Re' set in doc-common
+.
+.de Re
+.  ie \n[.$] \
+.    tm Usage: .Re (does not take arguments) (#\n[.c])
+.  el \{\
+.    doc-print-reference
+.    doc-reset-reference
+.    nr doc-is-reference 0
+.  \}
+..
+.
+.
+.\" NS doc-reset-reference macro
+.\" NS   reference cleanup
+.\" NS
+.\" NS modifies:
+.\" NS   doc-author-count
+.\" NS   doc-author-nameXXX
+.\" NS   doc-book-count
+.\" NS   doc-book-name
+.\" NS   doc-corporate-count
+.\" NS   doc-corporate-name
+.\" NS   doc-date
+.\" NS   doc-date-count
+.\" NS   doc-issue-count
+.\" NS   doc-issue-name
+.\" NS   doc-journal-count
+.\" NS   doc-journam-name
+.\" NS   doc-optional-count
+.\" NS   doc-optional-string
+.\" NS   doc-page-number-count
+.\" NS   doc-page-number-string
+.\" NS   doc-reference-title-count
+.\" NS   doc-reference-title-name
+.\" NS   doc-reference-title-name-for-book
+.\" NS   doc-report-count
+.\" NS   doc-report-name
+.\" NS   doc-volume-count
+.\" NS   doc-volume-name
+.
+.de doc-reset-reference
+.  while (\n[doc-author-count]) \{\
+.    ds doc-author-name\n[doc-author-count]
+.    nr doc-author-count -1
+.  \}
+.  nr doc-journal-count 0
+.  nr doc-issue-count 0
+.  nr doc-optional-count 0
+.  nr doc-corporate-count 0
+.  nr doc-report-count 0
+.  nr doc-reference-title-count 0
+.  nr doc-volume-count 0
+.  nr doc-date-count 0
+.  nr doc-page-number-count 0
+.  nr doc-book-count 0
+.
+.  ds doc-journal-name
+.  ds doc-issue-name
+.  ds doc-optional-string
+.  ds doc-corporate-name
+.  ds doc-report-name
+.  ds doc-reference-title-name
+.  ds doc-reference-title-name-for-book
+.  ds doc-volume-name
+.  ds doc-date
+.  ds doc-page-number-string
+.  ds doc-book-name
+..
+.
+.
+.\" NS doc-finish-reference macro
+.\" NS   auxiliary macro for doc-print-reference
+.\" NS
+.\" NS modifies:
+.\" NS   doc-reference-count
+.
+.de doc-finish-reference
+.  nr doc-reference-count -1
+.  ie \n[doc-reference-count] \
+.    nop \),
+.  el \
+.    nop \).
+..
+.
+.
+.\" NS doc-print-reference macro
+.\" NS   reference print
+.\" NS
+.\" NS modifies:
+.\" NS   doc-reference-count
+.
+.de doc-print-reference
+.
+.  nh
+.
+.  if \n[doc-author-count] \{\
+.    doc-print-reference-authors
+.    nr doc-reference-count -\n[doc-author-count]
+.  \}
+.
+.  if \n[doc-reference-title-count] \{\
+.    unformat doc-reference-title-name
+.    chop doc-reference-title-name
+.    unformat doc-reference-title-name-for-book
+.    chop doc-reference-title-name-for-book
+.    ie ((\n[doc-journal-count] == 1) : (\n[doc-book-count] == 1)) \{\
+.      nop \)\*[q]\)\*[doc-reference-title-name-for-book]\)\*[q]\c
+.      doc-finish-reference
+.    \}
+.    el \{\
+.      nop \*[doc-reference-title-name]\c
+.      doc-finish-reference
+.  \}\}
+.
+.  if \n[doc-book-count] \{\
+.    unformat doc-book-name
+.    chop doc-book-name
+.    nop \*[doc-book-name]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-publisher-count] \{\
+.    unformat doc-publisher-name
+.    chop doc-publisher-name
+.    nop \*[doc-publisher-name]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-journal-count] \{\
+.    unformat doc-journal-name
+.    chop doc-journal-name
+.    nop \*[doc-journal-name]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-report-count] \{\
+.    unformat doc-report-name
+.    chop doc-report-name
+.    nop \*[doc-report-name]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-issue-count] \{\
+.    unformat doc-issue-name
+.    chop doc-issue-name
+.    nop \*[doc-issue-name]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-volume-count] \{\
+.    unformat doc-volume-name
+.    chop doc-volume-name
+.    nop \*[doc-volume-name]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-page-number-count] \{\
+.    unformat doc-page-number-string
+.    chop doc-page-number-string
+.    nop \*[doc-page-number-string]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-corporate-count] \{\
+.    unformat doc-corporate-name
+.    chop doc-corporate-name
+.    nop \*[doc-corporate-name]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-date-count] \{\
+.    unformat doc-date
+.    chop doc-date
+.    nop \*[doc-date]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-optional-count] \{\
+.    unformat doc-optional-string
+.    chop doc-optional-string
+.    nop \*[doc-optional-string]\c
+.    doc-finish-reference
+.  \}
+.
+.  if \n[doc-reference-count] \
+.    tm mdoc warning: unresolved reference problem
+.
+.  hy \n[doc-hyphen-flags]
+..
+.
+.
+.\" NS doc-print-reference-authors macro
+.\" NS   print out reference authors
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-dpra
+.\" NS   doc-str-dpra
+.
+.ds doc-str-dpra "and
+.
+.de doc-print-reference-authors
+.  nr doc-reg-dpra 1
+.
+.  while (\n[doc-reg-dpra] < \n[doc-author-count]) \{\
+.    unformat doc-author-name\n[doc-reg-dpra]
+.    chop doc-author-name\n[doc-reg-dpra]
+.    ie (\n[doc-author-count] > 2) \
+.      nop \)\*[doc-author-name\n[doc-reg-dpra]],
+.    el \
+.      nop \)\*[doc-author-name\n[doc-reg-dpra]]
+.    nr doc-reg-dpra +1
+.  \}
+.
+.  unformat doc-author-name\n[doc-reg-dpra]
+.  chop doc-author-name\n[doc-reg-dpra]
+.  if (\n[doc-author-count] > 1) \
+.    nop \)\*[doc-str-dpra]
+.  nop \)\*[doc-author-name\n[doc-reg-dpra]],
+..
+.
+.
+.\" NS doc-author-count global register
+.\" NS   counter of author references
+.
+.nr doc-author-count 0
+.
+.
+.\" NS doc-author-nameXXX global box
+.\" NS   array of author names
+.\" NS
+.\" NS limit:
+.\" NS   doc-author-count
+.
+.ds doc-author-name0
+.
+.
+.\" NS %A user macro
+.\" NS   reference author(s)
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-author-count
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS   doc-reference-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%A
+.\" NS
+.\" NS width register `%A' set in doc-common
+.
+.de %A
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%A author_name ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-author-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %A
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" save to reference box
+.  box doc-author-name\n[doc-author-count]
+.  ev doc-env-%A
+.  evc 0
+.  in 0
+.  nf
+.  doc-do-references
+..
+.
+.
+.\" NS doc-book-count global register
+.\" NS   counter of book references
+.
+.nr doc-book-count 0
+.
+.
+.\" NS doc-book-name global box
+.\" NS   string of collected book references
+.
+.ds doc-book-name
+.
+.
+.\" NS %B user macro
+.\" NS   [reference] book name
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-book-count
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS   doc-reference-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%B
+.\" NS
+.\" NS width register `%B' set in doc-common
+.
+.de %B
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%B book_name ... (#\n[.c])
+.    return
+.  \}
+.
+.  if \n[doc-is-reference] \{\
+.    nr doc-book-count +1
+.    nr doc-reference-count +1
+.  \}
+.
+.  ds doc-macro-name %B
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  ie \n[doc-is-reference] \{\
+.    \" append to reference box
+.    boxa doc-book-name
+.    ev doc-env-%B
+.    evc 0
+.    in 0
+.    nf
+.    nop \*[doc-Em-font]\c
+.    doc-do-references
+.  \}
+.  el \{\
+.    nop \*[doc-Em-font]\c
+.    doc-print-recursive
+.  \}
+..
+.
+.
+.\" NS doc-date-count global register
+.\" NS   counter of date references
+.
+.nr doc-date-count 0
+.
+.
+.\" NS doc-date global box
+.\" NS   string of collected date references
+.
+.ds doc-date
+.
+.
+.\" NS %D user macro
+.\" NS   [reference] date
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-date-count
+.\" NS   doc-macro-name
+.\" NS   doc-reference-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%D
+.\" NS
+.\" NS width register `%D' set in doc-common
+.
+.de %D
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%D date ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-date-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %D
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" append to reference box
+.  boxa doc-date
+.  ev doc-env-%D
+.  evc 0
+.  in 0
+.  nf
+.  doc-do-references
+..
+.
+.
+.\" NS doc-publisher-count global register
+.\" NS   counter of publisher references
+.
+.nr doc-publisher-count 0
+.
+.
+.\" NS doc-publisher-name global box
+.\" NS   string of collected publisher references
+.
+.ds doc-publisher-name
+.
+.
+.\" NS %I user macro
+.\" NS   [reference] issuer/publisher name
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS   doc-publisher-count
+.\" NS   doc-reference-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%I
+.\" NS
+.\" NS width register `%I' set in doc-common
+.
+.de %I
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%I issuer/publisher_name ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-publisher-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %I
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" append to reference box
+.  boxa doc-publisher-name
+.  ev doc-env-%I
+.  evc 0
+.  in 0
+.  nf
+.  nop \*[doc-Em-font]\c
+.  doc-do-references
+..
+.
+.
+.\" NS doc-journal-count global register
+.\" NS   counter of journal references
+.
+.nr doc-journal-count 0
+.
+.
+.\" NS doc-journal-name global box
+.\" NS   string of collected journal references
+.
+.ds doc-journal-name
+.
+.
+.\" NS %J user macro
+.\" NS   [reference] Journal Name
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-journal-count
+.\" NS   doc-macro-name
+.\" NS   doc-reference-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%J
+.\" NS
+.\" NS width register `%J' set in doc-common
+.
+.de %J
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%J journal_name ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-journal-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %J
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" append to reference box
+.  boxa doc-journal-name
+.  ev doc-env-%J
+.  evc 0
+.  in 0
+.  nf
+.  nop \*[doc-Em-font]\c
+.  doc-do-references
+..
+.
+.
+.\" NS doc-issue-count global register
+.\" NS   counter of issue number references
+.
+.nr doc-issue-count 0
+.
+.
+.\" NS doc-issue-name global box
+.\" NS   string of collected issue number references
+.
+.ds doc-issue-name
+.
+.
+.\" NS %N user macro
+.\" NS   [reference] issue number
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-issue-count
+.\" NS   doc-macro-name
+.\" NS   doc-reference-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%N
+.\" NS
+.\" NS width register `%N' set in doc-common
+.
+.de %N
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%N issue_number ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-issue-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %N
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" append to reference box
+.  boxa doc-issue-name
+.  ev doc-env-%N
+.  evc 0
+.  in 0
+.  nf
+.  doc-do-references
+..
+.
+.
+.\" NS doc-optional-count global register
+.\" NS   counter of optional information references
+.
+.nr doc-optional-count 0
+.
+.
+.\" NS doc-optional-string global box
+.\" NS   string of collected optional information references
+.
+.ds doc-optional-string
+.
+.
+.\" NS %O user macro
+.\" NS   [reference] optional information
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS   doc-optional-count
+.\" NS   doc-reference-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%O
+.\" NS
+.\" NS width register `%O' set in doc-common
+.
+.de %O
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%O optional_information ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-optional-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %O
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" append to reference box
+.  boxa doc-optional-string
+.  ev doc-env-%O
+.  evc 0
+.  in 0
+.  nf
+.  doc-do-references
+..
+.
+.
+.\" NS doc-page-number-count global register
+.\" NS   counter of page number references
+.
+.nr doc-page-number-count 0
+.
+.
+.\" NS doc-page-number-string global box
+.\" NS   string of collected page number references
+.
+.ds doc-page-number-string
+.
+.
+.\" NS %P user macro
+.\" NS   [reference] page numbers
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS   doc-page-number-count
+.\" NS   doc-reference-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%P
+.\" NS
+.\" NS width register `%P' set in doc-common
+.
+.de %P
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%P page_number ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-page-number-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %P
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" append to reference box
+.  boxa doc-page-number-string
+.  ev doc-env-%P
+.  evc 0
+.  in 0
+.  nf
+.  doc-do-references
+..
+.
+.
+.\" NS doc-corporate-count global register
+.\" NS   counter of corporate references
+.
+.nr doc-corporate-count 0
+.
+.
+.\" NS doc-corporate-name global box
+.\" NS   string of collected corporate references
+.
+.ds doc-corporate-name
+.
+.
+.\" NS %Q user macro
+.\" NS   corporate or foreign author
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-corporate-count
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS   doc-reference-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%Q
+.\" NS
+.\" NS width register `%Q' set in doc-common
+.
+.de %Q
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%Q corporate_or_foreign_author ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-corporate-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %Q
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" append to reference box
+.  boxa doc-corporate-name
+.  ev doc-env-%Q
+.  evc 0
+.  in 0
+.  nf
+.  doc-do-references
+..
+.
+.
+.\" NS doc-report-count global register
+.\" NS   counter of report references
+.
+.nr doc-report-count 0
+.
+.
+.\" NS doc-report-name global box
+.\" NS   string of collected report references
+.
+.ds doc-report-name
+.
+.
+.\" NS %R user macro
+.\" NS   [reference] report name
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS   doc-reference-count
+.\" NS   doc-report-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%R
+.\" NS
+.\" NS width register `%R' set in doc-common
+.
+.de %R
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%R reference_report ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-report-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %R
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" append to reference box
+.  boxa doc-report-name
+.  ev doc-env-%R
+.  evc 0
+.  in 0
+.  nf
+.  doc-do-references
+..
+.
+.
+.\" NS doc-reference-title-count global register
+.\" NS   counter of reference title references
+.
+.nr doc-reference-title-count 0
+.
+.
+.\" NS doc-reference-title-name global box
+.\" NS   string of collected reference title references
+.
+.ds doc-reference-title-name
+.
+.
+.\" NS doc-reference-title-name-for-book global box
+.\" NS   string of collected reference title references
+.\" NS   (saved with another font; this is a shortcoming of groff)
+.
+.ds doc-reference-title-name-for-book
+.
+.
+.\" NS %T user macro
+.\" NS   reference title
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS   doc-reference-title-count
+.\" NS   doc-report-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%T
+.\" NS
+.\" NS width register `%T' set in doc-common
+.
+.de %T
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%T reference_title ... (#\n[.c])
+.    return
+.  \}
+.
+.  if \n[doc-is-reference] \{\
+.    nr doc-reference-title-count +1
+.    nr doc-reference-count +1
+.  \}
+.
+.  ds doc-macro-name %T
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.  ie \n[doc-is-reference] \{\
+.    \" append to reference box
+.    boxa doc-reference-title-name-for-book
+.    ev doc-env-%T
+.    evc 0
+.    in 0
+.    nf
+.    nop \*[doc-No-font]\c
+.    doc-do-references
+.
+.    \" do it a second time with another font
+.    ds doc-macro-name %T
+.    doc-parse-args \$@
+.
+.    nr doc-arg-ptr +1
+.    nr doc-curr-font \n[.f]
+.    nr doc-curr-size \n[.ps]
+.    boxa doc-reference-title-name
+.    ev doc-env-%T
+.    evc 0
+.    in 0
+.    nf
+.    nop \*[doc-Em-font]\c
+.    doc-do-references
+.  \}
+.  el \{\
+.    nop \*[doc-Em-font]\c
+.    doc-print-recursive
+.  \}
+..
+.
+.
+.\" NS doc-volume-count global register
+.\" NS   counter of reference title references
+.
+.nr doc-volume-count 0
+.
+.
+.\" NS doc-volume-name global box
+.\" NS   string of collected volume references
+.
+.ds doc-volume-name
+.
+.
+.\" NS %V user macro
+.\" NS   reference volume
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-macro-name
+.\" NS   doc-reference-title-count
+.\" NS   doc-volume-count
+.\" NS
+.\" NS local variables:
+.\" NS   doc-env-%V
+.\" NS
+.\" NS width register `%V' set in doc-common
+.
+.de %V
+.  if (\n[doc-arg-limit] : (\n[.$] == 0)) \{\
+.    tm Usage: .%V volume ... (#\n[.c])
+.    return
+.  \}
+.
+.  nr doc-volume-count +1
+.  nr doc-reference-count +1
+.
+.  ds doc-macro-name %V
+.  doc-parse-args \$@
+.
+.  nr doc-arg-ptr +1
+.  nr doc-curr-font \n[.f]
+.  nr doc-curr-size \n[.ps]
+.
+.  \" append to reference box
+.  boxa doc-volume-name
+.  ev doc-env-%V
+.  evc 0
+.  in 0
+.  nf
+.  doc-do-references
+..
+.
+.
+.\" NS doc-do-references macro
+.\" NS   reference recursion routine
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-ddr
+.\" NS   doc-reg-ddr1
+.
+.de doc-do-references
+.  if !\n[doc-is-reference] \
+.    tm mdoc error: .\*[doc-macro-name] found outside of .Rs ... .Re (#\n[.c])
+.
+.  nr doc-reg-ddr1 \n[doc-type\n[doc-arg-ptr]]
+.
+.  ie (\n[doc-reg-ddr1] == 1) \{\
+.    \" .nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]\c
+.    doc-append-arg \c 3
+.    \*[doc-arg\n[doc-arg-ptr]]
+.  \}
+.  el \{\
+.    nop \)\*[doc-arg\n[doc-arg-ptr]]\c
+.
+.    ie (\n[doc-arg-limit] == \n[doc-arg-ptr]) \{\
+.      \" finish reference box
+.      br
+.      ev
+.      boxa
+.
+.      doc-reset-args
+.    \}
+.    el \{\
+.      nr doc-reg-ddr \n[doc-arg-ptr]
+.      nr doc-arg-ptr +1
+.      nop \)\*[doc-space\n[doc-reg-ddr]]\c
+.      doc-do-references
+.  \}\}
+..
+.
+.
+.\" NS Hf user macro
+.\" NS   source include header files.
+.\" NS
+.\" NS modifies:
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS
+.\" NS width register `Hf' set in doc-common
+.
+.de Hf
+.  ie ((\n[.$] == 1) & (\n[doc-arg-limit] == 0)) \{\
+.    doc-paragraph
+.    nop File:
+.    Pa \$1
+.
+.    Bd -literal
+.    so \$1
+.    Ed
+.
+.    doc-paragraph
+.  \}
+.  el \
+.    Usage: .Hf file (#\n[.c])
+..
+.
+.
+.\" NS doc-have-author global register (bool)
+.\" NS   set in `An'
+.
+.nr doc-have-author 0
+.
+.
+.\" NS An user macro
+.\" NS   author name
+.\" NS
+.\" NS modifies:
+.\" NS   doc-arg-ptr
+.\" NS   doc-curr-font
+.\" NS   doc-curr-size
+.\" NS   doc-have-author
+.\" NS   doc-macro-name
+.\" NS
+.\" NS width register `An' set in doc-common
+.
+.de An
+.  if !\n[doc-arg-limit] \{\
+.    ie \n[.$] \{\
+.      ie        "\$1"-nosplit" \
+.        nr doc-in-authors-section 0
+.      el \{ .ie "\$1"-split" \
+.        nr doc-in-authors-section 1
+.      el \{\
+.        ds doc-macro-name An
+.        doc-parse-args \$@
+.    \}\}\}
+.    el \{\
+.      tm1 "Usage: .An {-nosplit | -split}
+.      tm1         .An author_name ... (#\n[.c])
+.  \}\}
+.
+.  if \n[doc-in-authors-section] \{\
+.    ie \n[doc-have-author] \
+.      br
+.    el \
+.      nr doc-have-author 1
+.  \}
+.
+.  if \n[doc-arg-limit] \{\
+.    nr doc-arg-ptr +1
+.    ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
+.      nr doc-curr-font \n[.f]
+.      nr doc-curr-size \n[.ps]
+.      doc-print-recursive
+.    \}
+.    el \{\
+.      tm Usage: .An author_name ... (#\n[.c])
+.      doc-reset-args
+.  \}\}
+..
+.
+.
+.\" NS Rv user macro
+.\" NS   return values
+.\" NS
+.\" NS width register `Rv' set in doc-common
+.\" NS
+.\" NS local variables:
+.\" NS   doc-str-Rv-std-prefix
+.\" NS   doc-str-Rv-std-suffix
+.\" NS   doc-str-Rv-stds-prefix
+.\" NS   doc-str-Rv-stds-and
+.\" NS   doc-str-Rv-stds-suffix
+.\" NS   doc-str-Rv-std0
+.
+.ds doc-str-Rv-std-prefix "The
+.ds doc-str-Rv-std-suffix "function returns the value\~0 if successful;
+.as doc-str-Rv-std-suffix " otherwise the value\~-1 is returned and
+.as doc-str-Rv-std-suffix " the global variable \*[doc-Va-font]errno\f[]
+.as doc-str-Rv-std-suffix " is set to indicate the error.
+.
+.ds doc-str-Rv-stds-prefix "The
+.ds doc-str-Rv-stds-and    "and
+.ds doc-str-Rv-stds-suffix "functions return the value\~0 if successful;
+.as doc-str-Rv-stds-suffix " otherwise the value\~-1 is returned and
+.as doc-str-Rv-stds-suffix " the global variable \*[doc-Va-font]errno\f[]
+.as doc-str-Rv-stds-suffix " is set to indicate the error.
+.
+.ds doc-str-Rv-std0 "Upon successful completion, the value\~0 is returned;
+.as doc-str-Rv-std0 " otherwise the value\~-1 is returned and
+.as doc-str-Rv-std0 " the global variable \*[doc-Va-font]errno\f[]
+.as doc-str-Rv-std0 " is set to indicate the error.
+.
+.de Rv
+.
+.\" XXX: what does this function without `-std'?
+.
+.  if \n[doc-arg-limit] \{\
+.    tm Usage: .Rv not callable by other macros (#\n[.c])
+.    doc-reset-args
+.    return
+.  \}
+.
+.  if !\n[.$] \{\
+.    tm Usage: .Rv [-std] [<function> ...] (#\n[.c])
+.    return
+.  \}
+.
+.  if "\$1"-std" \{\
+.    nr doc-reg-Rv \*[doc-section]
+.    if ((\n[doc-reg-Rv] < 2) : (\n[doc-reg-Rv] > 3)) \
+.      tm Usage: .Rv -std in sections 2 and 3 only (#\n[.c])
+.    br
+.    shift
+.    ie (\n[.$] > 1) \{\
+.      nop \)\*[doc-str-Rv-stds-prefix]
+.      nr doc-reg-Rv 1
+.      while (\n[doc-reg-Rv] < \n[.$]) \{\
+.        ie (\n[.$] > 2) \
+.          Fn \$\n[doc-reg-Rv] ,
+.        el \
+.          Fn \$\n[doc-reg-Rv]
+.        nr doc-reg-Rv +1
+.      \}
+.      nop \)\*[doc-str-Rv-stds-and]
+.      Fn \$\n[.$]
+.      nop \)\*[doc-str-Rv-stds-suffix]
+.    \}
+.    el \{ .ie (\n[.$] == 1) \{\
+.      nop \)\*[doc-str-Rv-std-prefix]
+.      Fn \$1
+.      nop \)\*[doc-str-Rv-std-suffix]
+.    \}
+.    el \{\
+.      nop \)\*[doc-str-Rv-std0]
+.  \}\}\}
+..
+.
+.
+.\" NS Ex user macro
+.\" NS   exit status
+.\" NS
+.\" NS width register `Ex' set in doc-common
+.\" NS
+.\" NS local variables:
+.\" NS   doc-str-Ex-std-prefix
+.\" NS   doc-str-Ex-std-suffix
+.
+.ds doc-str-Ex-std-prefix "The
+.ds doc-str-Ex-std-suffix "utility exits\~0 on success,
+.as doc-str-Ex-std-suffix " and\~>0 if an error occurs.
+.
+.ds doc-str-Ex-stds-prefix "The
+.als doc-str-Ex-stds-and doc-str-Rv-stds-and
+.ds doc-str-Ex-stds-suffix "utilities exit\~0 on success,
+.as doc-str-Ex-stds-suffix " and\~>0 if an error occurs.
+.
+.de Ex
+.
+.\" XXX: what does this function without `-std'?
+.
+.  if \n[doc-arg-limit] \{\
+.    tm Usage: .Ex not callable by other macros (#\n[.c])
+.    doc-reset-args
+.    return
+.  \}
+.
+.  if !\n[.$] \{\
+.    tm Usage: .Ex [-std] [<utility> ...] (#\n[.c])
+.    return
+.  \}
+.
+.  if "\$1"-std" \{\
+.    nr doc-reg-Ex \*[doc-section]
+.    if !((\n[doc-reg-Ex] == 1) : (\n[doc-reg-Ex] == 6) : (\n[doc-reg-Ex] == 8)) \
+.      tm Usage: .Ex -std in sections 1, 6 and 8 only (#\n[.c])
+.    br
+.    shift
+.    ie (\n[.$] > 1) \{\
+.      nop \)\*[doc-str-Ex-stds-prefix]
+.      nr doc-reg-Ex 1
+.      while (\n[doc-reg-Ex] < \n[.$]) \{\
+.        ie (\n[.$] > 2) \
+.          Nm \$\n[doc-reg-Ex] ,
+.        el \
+.          Nm \$\n[doc-reg-Ex]
+.        nr doc-reg-Ex +1
+.      \}
+.      nop \)\*[doc-str-Ex-stds-and]
+.      Nm \$\n[.$]
+.      nop \)\*[doc-str-Ex-stds-suffix]
+.    \}
+.    el \{\
+.      nop \)\*[doc-str-Ex-std-prefix]
+.      Nm \$1
+.      nop \)\*[doc-str-Ex-std-suffix]
+.  \}\}
+..
+.
+.
+.\" NS Mt user macro
+.\" NS   mailto (for conversion to HTML)
+.
+.de Mt
+.  \" XXX: error handling missing
+.  Pa \$@
+..
+.
+.
+.\" NS Lk user macro
+.\" NS   link (for conversion to HTML)
+.\" NS
+.\" NS local variables:
+.\" NS   doc-reg-Lk
+.\" NS   doc-str-Lk
+.
+.de Lk
+.  ds doc-str-Lk Sy \$@
+.
+.  ie (\n[.$] > 1) \{\
+.    doc-get-arg-type \$2
+.    ie (\n[doc-arg-type] < 3) \{\
+.      Em \)\$2:
+.      ds doc-str-Lk Sy "\$1"
+.      doc-get-width "\$1"
+.      shift 2
+.      if \n[.$] \
+.        as doc-str-Lk " \$@
+.    \}
+.    el \
+.      doc-get-width "\$1"
+.  \}
+.  el \
+.    doc-get-width "\$1"
+.
+.  ie n \
+.    nr doc-reg-Lk 26
+.  el \
+.    nr doc-reg-Lk 38
+.  ie (\n[doc-width] >= \n[doc-reg-Lk]) \
+.    D1 \*[doc-str-Lk]
+.  el \
+.    \*[doc-str-Lk]
+..
+.
+.
+.\" NS doc-defunct-macro macro
+.\" NS   this is the skeleton for defunct macros
+.\" NS
+.
+.de doc-defunct-macro
+.  tmc mdoc error: .\$0 defunct
+.  if d doc-\$0-usage \
+.    tmc , \*[doc-\$0-usage]
+.  tm1 " (#\n[.c])
+..
+.
+.
+.\" obsolete macros
+.
+.als Db doc-defunct-macro
+.
+.als Ds doc-defunct-macro
+.
+.als Or doc-defunct-macro
+.ds doc-Or-usage use `|'
+.
+.als Sf doc-defunct-macro
+.ds doc-Sf-usage use .Pf or .Ns
+.
+.
+.rn em e@
+.
+.de em
+.  tm1 "mdoc error: end-macro (.em) respecification is not allowed. (#\n[.c])
+.  tm1 "            Should this have been `.Em ...'?
+.  ab
+..
+.
+.
+.\" NS doc-empty-line macro
+.\" NS   emit warning and print empty line
+.
+.de doc-empty-line
+.  if !\n[doc-display-depth] \
+.    tm mdoc warning: Empty input line #\n[.c]
+.  sp
+..
+.
+.blm doc-empty-line
+.
+.
+.ec
+.
+.
+.\" load local modifications
+.mso mdoc.local
+.
+.\" EOF
diff -uNr groff-1.19.1.orig/tmac/euc-jp.tmac groff-1.19.1/tmac/euc-jp.tmac
--- groff-1.19.1.orig/tmac/euc-jp.tmac	1970-01-01 09:00:00.000000000 +0900
+++ groff-1.19.1/tmac/euc-jp.tmac	2005-02-23 16:32:33.239762280 +0900
@@ -0,0 +1,7 @@
+.\" euc-jp.tmac
+.\"
+.cflags 256 ,:;>}
+.cflags 256 、。，．・：；？！）〕］｝」』】ぁぃぅぇぉっゃゅょー
+.cflags 256 ァィゥェォッャュョ
+.cflags 512 （〔［｛「『【
+.hc ‐
diff -uNr groff-1.19.1.orig/tmac/troffrc groff-1.19.1/tmac/troffrc
--- groff-1.19.1.orig/tmac/troffrc	2003-12-22 07:39:57.000000000 +0900
+++ groff-1.19.1/tmac/troffrc	2005-02-23 16:32:33.239762280 +0900
@@ -16,7 +16,9 @@
 .do ds troffrc!X100 X.tmac
 .do ds troffrc!X100-12 X.tmac
 .do ds troffrc!ascii tty.tmac
+.do ds troffrc!ascii8 tty.tmac
 .do ds troffrc!latin1 tty.tmac
+.do ds troffrc!nippon tty.tmac
 .do ds troffrc!utf8 tty.tmac
 .do ds troffrc!cp1047 tty.tmac
 .do ds troffrc!lj4 lj4.tmac
@@ -44,3 +46,6 @@
 .do mso papersize.tmac
 .
 .\" Don't let blank lines creep in here.
+.\"
+.\" for Japanese hack
+.if "\V[LANG]"ja_JP.eucJP" .do mso euc-jp.tmac
